###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     10/Nov/2014  12:52:10 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Utilities\Third_Party\efsl\src\ui.c                   #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Utilities\Third_Party\efsl\src\ui.c -D                #
#                    __ARM_CORTEX_MX__ -D DEBUG -D FREE_RTOS -D               #
#                    STM32F40_41xxx -D USE_STM324xG_EVAL -D                   #
#                    USE_STDPERIPH_DRIVER -D HOST_MODE_ENABLED -D             #
#                    IAR_ARM_CM4F -D USE_USB_OTG_FS -D STM32_IAP -D S4051A    #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Release\L #
#                    ist\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Releas #
#                    e\Obj\ --debug --endian=little --cpu=Cortex-M4 -e        #
#                    --fpu=VFPv4_sp --dlib_config "C:\Program Files           #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Projects\STM32_IAP\inc #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\I #
#                    nclude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\C #
#                    MSIS\Device\ST\STM32F4xx\Include\ -I                     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_HO #
#                    ST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\HT68F30\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Utilities\Third_Party\efsl\inc\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    fat_fs\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Project #
#                    s\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utiliti #
#                    es\mainstream_v1\stm32f411\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\it\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\APP_SRC\I #
#                    nclude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\APP_SRC\ -Ohz -I  #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Release\List\u #
#                    i.lst                                                    #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Release\Obj\ui #
#                    .o                                                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Utilities\Third_Party\efsl\src\ui.c
      1          /*****************************************************************************\
      2          *              efs - General purpose Embedded Filesystem library              *
      3          *          --------------------- -----------------------------------          *
      4          *                                                                             *
      5          * Filename : ui.c                                                             *
      6          * Description : This file contains functions which will be presented to the   *
      7          *               user of this library.                                         *
      8          *                                                                             *
      9          * This program is free software; you can redistribute it and/or               *
     10          * modify it under the terms of the GNU General Public License                 *
     11          * as published by the Free Software Foundation; version 2                     *
     12          * of the License.                                                             *
     13                                                                                        *
     14          * This program is distributed in the hope that it will be useful,             *
     15          * but WITHOUT ANY WARRANTY; without even the implied warranty of              *
     16          * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               *
     17          * GNU General Public License for more details.                                *
     18          *                                                                             *
     19          * As a special exception, if other files instantiate templates or             *
     20          * use macros or inline functions from this file, or you compile this          *
     21          * file and link it with other works to produce a work based on this file,     *
     22          * this file does not by itself cause the resulting work to be covered         *
     23          * by the GNU General Public License. However the source code for this         *
     24          * file must still be made available in accordance with section (3) of         *
     25          * the GNU General Public License.                                             *
     26          *                                                                             *
     27          * This exception does not invalidate any other reasons why a work based       *
     28          * on this file might be covered by the GNU General Public License.            *
     29          *                                                                             *
     30          *                                                    (c)2006 Lennart Yseboodt *
     31          *                                                    (c)2006 Michael De Nil   *
     32          \*****************************************************************************/
     33          
     34          /*****************************************************************************/
     35          
     36          #include "ui.h"
     37          /*****************************************************************************/
     38          
     39          /*****************************************************************************
     40           * short listfiles(char *dir)
     41           *
     42           * Deschription: This function returns the number of files / directories
     43           * inside the given directory.
     44           *
     45           * Return value: number of files/directories in the given directory or -1
     46           * if directory does not exist.
     47          \*****************************************************************************/
     48          
     49          short listFiles(FileSystem *fs, char *dirname)
     50          {
     51          	unsigned long startCluster;
     52          	unsigned char fileEntryCount;
     53          	unsigned short counter=0;
     54          	unsigned long offset=0;
     55          	FileRecord fileEntry;
     56          	FileLocation loc;
     57          	unsigned char buf[512];
     58          	File dir;
     59          	unsigned short i;
     60          	
     61          	/* Find out if we are searching in the root dir or in */
     62          	if(dirname[0]=='/' && dirname[1]=='\0')
     63          	{
     64          		if( (fs->type == FAT12) || (fs->type == FAT16) )
     65          		{
     66          			for(i=0;i<=(fs->volumeId.RootEntryCount/16);i++)
     67          			{
     68          				loc.Sector=fs->FirstSectorRootDir + i;
     69          				part_readBuf(fs->part,loc.Sector,buf);
     70          				/* I STOPPED HERE*/
     71          				/* FIXME */
     72          			}
     73          		}
     74          	}
     75          	else /* Normal directory */
     76          	{
     77          		/* Check if path given is a directory */
     78          		if(fs_findFile(fs,dirname,&loc,0)!=2)
     79          		{
     80          #if 0	/*Smith maintain: Fix IAR warning message*/			
     81          			FUNC_OUT((TXT("")));
     82          #endif 
     83          			return(-1);
     84          		}
     85          	
     86          		/* Find out what the startcluster of the directory is */
     87          		part_readBuf(fs->part,loc.Sector, buf);
     88          		fileEntry = *(((FileRecord*)buf) + loc.Offset);
     89          		startCluster = (((unsigned long)fileEntry.FirstClusterHigh)<<16) 
     90          			+ fileEntry.FirstClusterLow;
     91          
     92          	    /* Init of dir */
     93          		dir.fs=fs;
     94          		dir.Cache.LogicCluster=-1;
     95          		dir.Cache.FirstCluster=startCluster;
     96          		dir.DirEntry.Attribute=ATTR_DIRECTORY;
     97          	
     98          		while((file_fread(&dir,offset,512,buf)))
     99          		{
    100          			//DBG((TXT("Read 512 bytes from dir with offset %li.\n"),offset));
    101          			for(fileEntryCount=0;fileEntryCount<16;fileEntryCount++)
    102          			{
    103          				fileEntry = *(((FileRecord*)buf) + fileEntryCount);
    104          				if( !( (fileEntry.Attribute & 0x0F) == 0x0F ) )
    105          				{
    106          					if
    107          					(
    108          					 (fileEntry.FileName[0]>='A' && fileEntry.FileName[0]<='Z')
    109          					 ||
    110          					 (fileEntry.FileName[0]>='0' && fileEntry.FileName[0]<='9')
    111          					)
    112          					{
    113          						//DBG((TXT("Filename: %s\n"),fileEntry.FileName));
    114          						counter++;
    115          					}
    116          				}
    117          			}
    118          			offset+=512;
    119          		}
    120          	}
    121          	
    122          #if 0	/*Smith maintain: Fix IAR warning message*/			
    123          	FUNC_OUT((TXT("")));
    124          #endif         
    125          	return(counter);
    126          	
    127          	//return(-1);
    128          }
    129          /*****************************************************************************/
    130          
    131          /* ****************************************************************************  
    132           * esint16 rmfile(FileSystem *fs,euint8* filename)
    133           * Description: This function takes a filename as argument and deletes it,
    134           * by freeing it's clusterchain, and deleting it's entry from the directory.
    135           * Return value: 0 on success, -1 on errors, like file not found.
    136          */
    137          esint16 rmfile(FileSystem *fs,euint8* filename)
    138          {
    139          	FileLocation loc;
    140          	ClusterChain cache;
    141          	euint8* buf;
    142          	euint32 firstCluster=0;
    143          	
    144          	if((fs_findFile(fs,(eint8*)filename,&loc,0))==1){
    145          		buf=part_getSect(fs->part,loc.Sector,IOM_MODE_READWRITE);
    146          		firstCluster = ex_getb16(buf,loc.Offset*32+20);
    147          		firstCluster <<= 16;
    148          		firstCluster += ex_getb16(buf,loc.Offset*32+26);
    149          		/* Bugfix:
    150          		 * By clearing the entire structure, you mark end of directory.
    151          		 * If this is not the case, files that are further away cannot
    152          		* be opened anymore by implementations that follow the spec. */
    153          		/*memClr(buf+(loc.Offset*32),32);*/
    154          		*(buf+(loc.Offset*32)+0) = 0xE5; /* Mark file deleted */
    155          		part_relSect(fs->part,buf);
    156          		cache.DiscCluster = cache.LastCluster = cache.Linear = cache.LogicCluster = 0;
    157          		cache.FirstCluster = firstCluster;
    158           		fat_unlinkClusterChain(fs,&cache);
    159          		return(0);
    160          	}
    161          	return(-1);
    162          }
    163          
    164          /*****************************************************************************/
    165          esint8 mkdir(FileSystem *fs,eint8* dirname)
    166          {
    167          	FileLocation loc;
    168          	FileRecord direntry;
    169          	euint32 nc,parentdir;
    170          	euint8* buf;
    171          	eint8 ffname[11];
    172          	
    173          	if( fs_findFile(fs,dirname,&loc,&parentdir) ){
    174          		return(-1);
    175          	}
    176          	if(parentdir==0)return(-2);
    177          	
    178          	if(!fs_findFreeFile(fs,dirname,&loc,0))return(-3);
    179          	
    180          	/* You may never search for a free cluster, and the call
    181          	 * functions that may cause changes to the FAT table, that
    182          	 * is why getNextFreeCluster has to be called AFTER calling
    183          	 * fs_findFreeFile, which may have to expand a directory in
    184          	 * order to store the new filerecord !! 
    185          	 */
    186          	
    187          	nc = fs_getNextFreeCluster(fs,fs_giveFreeClusterHint(fs));
    188          	if(nc==0)return(0);
    189          	
    190          	fs_clearCluster(fs,nc);
    191          	
    192          	buf = part_getSect(fs->part,loc.Sector,IOM_MODE_READWRITE);
    193          
    194          	dir_getFatFileName(dirname,ffname);
    195          	memClr(&direntry,sizeof(direntry));
    196          	memCpy(ffname,&direntry,11);
    197          	direntry.FileSize = 0;
    198          	direntry.FirstClusterHigh=nc>>16;
    199          	direntry.FirstClusterLow=nc&0xFFFF;
    200          	direntry.Attribute = ATTR_DIRECTORY;
    201          	memCpy(&direntry,buf+(32*loc.Offset),32);
    202          		
    203          	part_relSect(fs->part,buf);
    204          	
    205          	buf = part_getSect(fs->part,fs_clusterToSector(fs,nc),IOM_MODE_READWRITE);
    206          	
    207          	memClr(&direntry,sizeof(direntry));
    208          	memCpy(".          ",&direntry,11);
    209          	direntry.Attribute = ATTR_DIRECTORY;
    210          	direntry.FileSize = 0;
    211          	direntry.FirstClusterHigh=nc>>16;
    212          	direntry.FirstClusterLow=nc&0xFFFF;
    213          	memCpy(&direntry,buf,32);
    214          	
    215          	if(fs->type == FAT32 && parentdir == fs->volumeId.RootCluster){
    216          		parentdir = 0;
    217          	}
    218          	if(fs->type != FAT32 && parentdir<=1){
    219          		parentdir = 0;
    220          	} 
    221          	
    222          	memClr(&direntry,sizeof(direntry));
    223          	memCpy("..         ",&direntry,11);
    224          	direntry.Attribute = ATTR_DIRECTORY;
    225          	direntry.FileSize = 0;
    226          	direntry.FirstClusterHigh=parentdir>>16;
    227          	direntry.FirstClusterLow=parentdir&0xFFFF;
    228          	memCpy(&direntry,buf+32,32);
    229          
    230          	part_relSect(fs->part,buf);
    231          	
    232          	fat_setNextClusterAddress(fs,nc,fat_giveEocMarker(fs));
    233          
    234          	return(0);
    235          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      656  listFiles
             656 -> __aeabi_memcpy4
             656 -> file_fread
             656 -> fs_findFile
             656 -> part_readBuf
       80  mkdir
              80 -> dir_getFatFileName
              80 -> fat_giveEocMarker
              80 -> fat_setNextClusterAddress
              80 -> fs_clearCluster
              80 -> fs_clusterToSector
              80 -> fs_findFile
              80 -> fs_findFreeFile
              80 -> fs_getNextFreeCluster
              80 -> fs_giveFreeClusterHint
              80 -> memClr
              80 -> memCpy
              80 -> part_getSect
              80 -> part_relSect
       56  rmfile
              56 -> ex_getb16
              56 -> fat_unlinkClusterChain
              56 -> fs_findFile
              56 -> part_getSect
              56 -> part_relSect


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant ".          ">
      12  ?<Constant "..         ">
       8  ?Subroutine0
       8  ?Subroutine1
      12  ?Subroutine2
     230  listFiles
     322  mkdir
     120  rmfile

 
 724 bytes in section .text
 
 724 bytes of CODE memory

Errors: none
Warnings: none

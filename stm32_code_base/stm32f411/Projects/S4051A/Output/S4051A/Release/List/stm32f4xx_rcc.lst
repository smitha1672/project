###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     10/Nov/2014  12:52:07 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rc #
#                    c.c                                                      #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rc #
#                    c.c -D __ARM_CORTEX_MX__ -D DEBUG -D FREE_RTOS -D        #
#                    STM32F40_41xxx -D USE_STM324xG_EVAL -D                   #
#                    USE_STDPERIPH_DRIVER -D HOST_MODE_ENABLED -D             #
#                    IAR_ARM_CM4F -D USE_USB_OTG_FS -D STM32_IAP -D S4051A    #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Release\L #
#                    ist\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Releas #
#                    e\Obj\ --debug --endian=little --cpu=Cortex-M4 -e        #
#                    --fpu=VFPv4_sp --dlib_config "C:\Program Files           #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Projects\STM32_IAP\inc #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\I #
#                    nclude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\C #
#                    MSIS\Device\ST\STM32F4xx\Include\ -I                     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_HO #
#                    ST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\HT68F30\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Utilities\Third_Party\efsl\inc\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    fat_fs\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Project #
#                    s\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utiliti #
#                    es\mainstream_v1\stm32f411\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\it\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\APP_SRC\I #
#                    nclude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\APP_SRC\ -Ohz -I  #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Release\List\s #
#                    tm32f4xx_rcc.lst                                         #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Release\Obj\st #
#                    m32f4xx_rcc.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_rcc.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Reset and clock control (RCC) peripheral:
      9            *           + Internal/external clocks, PLL, CSS and MCO configuration
     10            *           + System, AHB and APB busses clocks configuration
     11            *           + Peripheral clocks configuration
     12            *           + Interrupts and flags management
     13            *
     14           @verbatim                
     15           ===============================================================================
     16                                ##### RCC specific features #####
     17           ===============================================================================
     18              [..]  
     19                After reset the device is running from Internal High Speed oscillator 
     20                (HSI 16MHz) with Flash 0 wait state, Flash prefetch buffer, D-Cache 
     21                and I-Cache are disabled, and all peripherals are off except internal
     22                SRAM, Flash and JTAG.
     23                (+) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
     24                    all peripherals mapped on these busses are running at HSI speed.
     25                (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
     26                (+) All GPIOs are in input floating state, except the JTAG pins which
     27                    are assigned to be used for debug purpose.
     28              [..]          
     29                Once the device started from reset, the user application has to:        
     30                (+) Configure the clock source to be used to drive the System clock
     31                    (if the application needs higher frequency/performance)
     32                (+) Configure the System clock frequency and Flash settings  
     33                (+) Configure the AHB and APB busses prescalers
     34                (+) Enable the clock for the peripheral(s) to be used
     35                (+) Configure the clock source(s) for peripherals which clocks are not
     36                    derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG)                                
     37           @endverbatim    
     38            ******************************************************************************
     39            * @attention
     40            *
     41            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     42            *
     43            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     44            * You may not use this file except in compliance with the License.
     45            * You may obtain a copy of the License at:
     46            *
     47            *        http://www.st.com/software_license_agreement_liberty_v2
     48            *
     49            * Unless required by applicable law or agreed to in writing, software 
     50            * distributed under the License is distributed on an "AS IS" BASIS, 
     51            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     52            * See the License for the specific language governing permissions and
     53            * limitations under the License.
     54            *
     55            ******************************************************************************
     56            */
     57          
     58          /* Includes ------------------------------------------------------------------*/
     59          #include "stm32f4xx_rcc.h"
     60          
     61          /** @addtogroup STM32F4xx_StdPeriph_Driver
     62            * @{
     63            */
     64          
     65          /** @defgroup RCC 
     66            * @brief RCC driver modules
     67            * @{
     68            */ 
     69          
     70          /* Private typedef -----------------------------------------------------------*/
     71          /* Private define ------------------------------------------------------------*/
     72          /* ------------ RCC registers bit address in the alias region ----------- */
     73          #define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
     74          /* --- CR Register ---*/
     75          /* Alias word address of HSION bit */
     76          #define CR_OFFSET                 (RCC_OFFSET + 0x00)
     77          #define HSION_BitNumber           0x00
     78          #define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
     79          /* Alias word address of CSSON bit */
     80          #define CSSON_BitNumber           0x13
     81          #define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
     82          /* Alias word address of PLLON bit */
     83          #define PLLON_BitNumber           0x18
     84          #define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
     85          /* Alias word address of PLLI2SON bit */
     86          #define PLLI2SON_BitNumber        0x1A
     87          #define CR_PLLI2SON_BB            (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLI2SON_BitNumber * 4))
     88          
     89          /* Alias word address of PLLSAION bit */
     90          #define PLLSAION_BitNumber        0x1C
     91          #define CR_PLLSAION_BB            (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLSAION_BitNumber * 4))
     92          
     93          /* --- CFGR Register ---*/
     94          /* Alias word address of I2SSRC bit */
     95          #define CFGR_OFFSET               (RCC_OFFSET + 0x08)
     96          #define I2SSRC_BitNumber          0x17
     97          #define CFGR_I2SSRC_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (I2SSRC_BitNumber * 4))
     98          
     99          /* --- BDCR Register ---*/
    100          /* Alias word address of RTCEN bit */
    101          #define BDCR_OFFSET               (RCC_OFFSET + 0x70)
    102          #define RTCEN_BitNumber           0x0F
    103          #define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
    104          /* Alias word address of BDRST bit */
    105          #define BDRST_BitNumber           0x10
    106          #define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
    107          
    108          /* --- CSR Register ---*/
    109          /* Alias word address of LSION bit */
    110          #define CSR_OFFSET                (RCC_OFFSET + 0x74)
    111          #define LSION_BitNumber           0x00
    112          #define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
    113          
    114          /* --- DCKCFGR Register ---*/
    115          /* Alias word address of TIMPRE bit */
    116          #define DCKCFGR_OFFSET            (RCC_OFFSET + 0x8C)
    117          #define TIMPRE_BitNumber          0x18
    118          #define DCKCFGR_TIMPRE_BB         (PERIPH_BB_BASE + (DCKCFGR_OFFSET * 32) + (TIMPRE_BitNumber * 4))
    119          /* ---------------------- RCC registers bit mask ------------------------ */
    120          /* CFGR register bit mask */
    121          #define CFGR_MCO2_RESET_MASK      ((uint32_t)0x07FFFFFF)
    122          #define CFGR_MCO1_RESET_MASK      ((uint32_t)0xF89FFFFF)
    123          
    124          /* RCC Flag Mask */
    125          #define FLAG_MASK                 ((uint8_t)0x1F)
    126          
    127          /* CR register byte 3 (Bits[23:16]) base address */
    128          #define CR_BYTE3_ADDRESS          ((uint32_t)0x40023802)
    129          
    130          /* CIR register byte 2 (Bits[15:8]) base address */
    131          #define CIR_BYTE2_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x01))
    132          
    133          /* CIR register byte 3 (Bits[23:16]) base address */
    134          #define CIR_BYTE3_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x02))
    135          
    136          /* BDCR register base address */
    137          #define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
    138          
    139          /* Private macro -------------------------------------------------------------*/
    140          /* Private variables ---------------------------------------------------------*/
    141          static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
    142          
    143          /* Private function prototypes -----------------------------------------------*/
    144          /* Private functions ---------------------------------------------------------*/
    145          
    146          /** @defgroup RCC_Private_Functions
    147            * @{
    148            */ 
    149          
    150          /** @defgroup RCC_Group1 Internal and external clocks, PLL, CSS and MCO configuration functions
    151           *  @brief   Internal and external clocks, PLL, CSS and MCO configuration functions 
    152           *
    153          @verbatim   
    154           ===================================================================================
    155           ##### Internal and  external clocks, PLL, CSS and MCO configuration functions #####
    156           ===================================================================================  
    157              [..]
    158                This section provide functions allowing to configure the internal/external clocks,
    159                PLLs, CSS and MCO pins.
    160            
    161                (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
    162                    the PLL as System clock source.
    163          
    164                (#) LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC
    165                    clock source.
    166          
    167                (#) HSE (high-speed external), 4 to 26 MHz crystal oscillator used directly or
    168                    through the PLL as System clock source. Can be used also as RTC clock source.
    169          
    170                (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.   
    171          
    172                (#) PLL (clocked by HSI or HSE), featuring two different output clocks:
    173                  (++) The first output is used to generate the high speed system clock (up to 168 MHz)
    174                  (++) The second output is used to generate the clock for the USB OTG FS (48 MHz),
    175                       the random analog generator (<=48 MHz) and the SDIO (<= 48 MHz).
    176          
    177                (#) PLLI2S (clocked by HSI or HSE), used to generate an accurate clock to achieve 
    178                    high-quality audio performance on the I2S interface or SAI interface in case 
    179                    of STM32F429x/439x devices.
    180               
    181                (#) PLLSAI clocked by (HSI or HSE), used to generate an accurate clock to SAI 
    182                    interface and LCD TFT controller available only for STM32F42xxx/43xxx devices.
    183            
    184                (#) CSS (Clock security system), once enable and if a HSE clock failure occurs 
    185                   (HSE used directly or through PLL as System clock source), the System clock
    186                   is automatically switched to HSI and an interrupt is generated if enabled. 
    187                   The interrupt is linked to the Cortex-M4 NMI (Non-Maskable Interrupt) 
    188                   exception vector.   
    189          
    190                (#) MCO1 (microcontroller clock output), used to output HSI, LSE, HSE or PLL
    191                    clock (through a configurable prescaler) on PA8 pin.
    192          
    193                (#) MCO2 (microcontroller clock output), used to output HSE, PLL, SYSCLK or PLLI2S
    194                    clock (through a configurable prescaler) on PC9 pin.
    195           @endverbatim
    196            * @{
    197            */
    198          
    199          /**
    200            * @brief  Resets the RCC clock configuration to the default reset state.
    201            * @note   The default reset state of the clock configuration is given below:
    202            *            - HSI ON and used as system clock source
    203            *            - HSE, PLL and PLLI2S OFF
    204            *            - AHB, APB1 and APB2 prescaler set to 1.
    205            *            - CSS, MCO1 and MCO2 OFF
    206            *            - All interrupts disabled
    207            * @note   This function doesn't modify the configuration of the
    208            *            - Peripheral clocks  
    209            *            - LSI, LSE and RTC clocks 
    210            * @param  None
    211            * @retval None
    212            */
    213          void RCC_DeInit(void)
    214          {
    215            /* Set HSION bit */
    216            RCC->CR |= (uint32_t)0x00000001;
    217          
    218            /* Reset CFGR register */
    219            RCC->CFGR = 0x00000000;
    220          
    221            /* Reset HSEON, CSSON, PLLON, PLLI2S and PLLSAI(STM32F42/43xxx devices) bits */
    222            RCC->CR &= (uint32_t)0xEAF6FFFF;
    223          
    224            /* Reset PLLCFGR register */
    225            RCC->PLLCFGR = 0x24003010;
    226          
    227            /* Reset PLLI2SCFGR register */
    228            RCC->PLLI2SCFGR = 0x20003000;
    229          
    230            /* Reset PLLSAICFGR register, only available for STM32F42/43xxx devices */
    231            RCC->PLLSAICFGR = 0x24003000;
    232           
    233            /* Reset HSEBYP bit */
    234            RCC->CR &= (uint32_t)0xFFFBFFFF;
    235          
    236            /* Disable all interrupts */
    237            RCC->CIR = 0x00000000;
    238          
    239            /* Disable Timers clock prescalers selection, only available for STM32F42/43xxx devices */
    240            RCC->DCKCFGR = 0x00000000; 
    241          
    242          }
    243          
    244          /**
    245            * @brief  Configures the External High Speed oscillator (HSE).
    246            * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
    247            *         software should wait on HSERDY flag to be set indicating that HSE clock
    248            *         is stable and can be used to clock the PLL and/or system clock.
    249            * @note   HSE state can not be changed if it is used directly or through the
    250            *         PLL as system clock. In this case, you have to select another source
    251            *         of the system clock then change the HSE state (ex. disable it).
    252            * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.  
    253            * @note   This function reset the CSSON bit, so if the Clock security system(CSS)
    254            *         was previously enabled you have to enable it again after calling this
    255            *         function.    
    256            * @param  RCC_HSE: specifies the new state of the HSE.
    257            *          This parameter can be one of the following values:
    258            *            @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
    259            *                              6 HSE oscillator clock cycles.
    260            *            @arg RCC_HSE_ON: turn ON the HSE oscillator
    261            *            @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
    262            * @retval None
    263            */
    264          void RCC_HSEConfig(uint8_t RCC_HSE)
    265          {
    266            /* Check the parameters */
    267            assert_param(IS_RCC_HSE(RCC_HSE));
    268          
    269            /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
    270            *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
    271          
    272            /* Set the new HSE configuration -------------------------------------------*/
    273            *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
    274          }
    275          
    276          /**
    277            * @brief  Waits for HSE start-up.
    278            * @note   This functions waits on HSERDY flag to be set and return SUCCESS if 
    279            *         this flag is set, otherwise returns ERROR if the timeout is reached 
    280            *         and this flag is not set. The timeout value is defined by the constant
    281            *         HSE_STARTUP_TIMEOUT in stm32f4xx.h file. You can tailor it depending
    282            *         on the HSE crystal used in your application. 
    283            * @param  None
    284            * @retval An ErrorStatus enumeration value:
    285            *          - SUCCESS: HSE oscillator is stable and ready to use
    286            *          - ERROR: HSE oscillator not yet ready
    287            */
    288          ErrorStatus RCC_WaitForHSEStartUp(void)
    289          {
    290            __IO uint32_t startupcounter = 0;
    291            ErrorStatus status = ERROR;
    292            FlagStatus hsestatus = RESET;
    293            /* Wait till HSE is ready and if Time out is reached exit */
    294            do
    295            {
    296              hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    297              startupcounter++;
    298            } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
    299          
    300            if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
    301            {
    302              status = SUCCESS;
    303            }
    304            else
    305            {
    306              status = ERROR;
    307            }
    308            return (status);
    309          }
    310          
    311          /**
    312            * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
    313            * @note   The calibration is used to compensate for the variations in voltage
    314            *         and temperature that influence the frequency of the internal HSI RC.
    315            * @param  HSICalibrationValue: specifies the calibration trimming value.
    316            *         This parameter must be a number between 0 and 0x1F.
    317            * @retval None
    318            */
    319          void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
    320          {
    321            uint32_t tmpreg = 0;
    322            /* Check the parameters */
    323            assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
    324          
    325            tmpreg = RCC->CR;
    326          
    327            /* Clear HSITRIM[4:0] bits */
    328            tmpreg &= ~RCC_CR_HSITRIM;
    329          
    330            /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
    331            tmpreg |= (uint32_t)HSICalibrationValue << 3;
    332          
    333            /* Store the new value */
    334            RCC->CR = tmpreg;
    335          }
    336          
    337          /**
    338            * @brief  Enables or disables the Internal High Speed oscillator (HSI).
    339            * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
    340            *         It is used (enabled by hardware) as system clock source after startup
    341            *         from Reset, wakeup from STOP and STANDBY mode, or in case of failure
    342            *         of the HSE used directly or indirectly as system clock (if the Clock
    343            *         Security System CSS is enabled).             
    344            * @note   HSI can not be stopped if it is used as system clock source. In this case,
    345            *         you have to select another source of the system clock then stop the HSI.  
    346            * @note   After enabling the HSI, the application software should wait on HSIRDY
    347            *         flag to be set indicating that HSI clock is stable and can be used as
    348            *         system clock source.  
    349            * @param  NewState: new state of the HSI.
    350            *          This parameter can be: ENABLE or DISABLE.
    351            * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
    352            *         clock cycles.  
    353            * @retval None
    354            */
    355          void RCC_HSICmd(FunctionalState NewState)
    356          {
    357            /* Check the parameters */
    358            assert_param(IS_FUNCTIONAL_STATE(NewState));
    359          
    360            *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
    361          }
    362          
    363          /**
    364            * @brief  Configures the External Low Speed oscillator (LSE).
    365            * @note   As the LSE is in the Backup domain and write access is denied to
    366            *         this domain after reset, you have to enable write access using 
    367            *         PWR_BackupAccessCmd(ENABLE) function before to configure the LSE
    368            *         (to be done once after reset).  
    369            * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_Bypass), the application
    370            *         software should wait on LSERDY flag to be set indicating that LSE clock
    371            *         is stable and can be used to clock the RTC.
    372            * @param  RCC_LSE: specifies the new state of the LSE.
    373            *          This parameter can be one of the following values:
    374            *            @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
    375            *                              6 LSE oscillator clock cycles.
    376            *            @arg RCC_LSE_ON: turn ON the LSE oscillator
    377            *            @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
    378            * @retval None
    379            */
    380          void RCC_LSEConfig(uint8_t RCC_LSE)
    381          {
    382            /* Check the parameters */
    383            assert_param(IS_RCC_LSE(RCC_LSE));
    384          
    385            /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
    386            /* Reset LSEON bit */
    387            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
    388          
    389            /* Reset LSEBYP bit */
    390            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
    391          
    392            /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
    393            switch (RCC_LSE)
    394            {
    395              case RCC_LSE_ON:
    396                /* Set LSEON bit */
    397                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
    398                break;
    399              case RCC_LSE_Bypass:
    400                /* Set LSEBYP and LSEON bits */
    401                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
    402                break;
    403              default:
    404                break;
    405            }
    406          }
    407          
    408          /**
    409            * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
    410            * @note   After enabling the LSI, the application software should wait on 
    411            *         LSIRDY flag to be set indicating that LSI clock is stable and can
    412            *         be used to clock the IWDG and/or the RTC.
    413            * @note   LSI can not be disabled if the IWDG is running.  
    414            * @param  NewState: new state of the LSI.
    415            *          This parameter can be: ENABLE or DISABLE.
    416            * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
    417            *         clock cycles. 
    418            * @retval None
    419            */
    420          void RCC_LSICmd(FunctionalState NewState)
    421          {
    422            /* Check the parameters */
    423            assert_param(IS_FUNCTIONAL_STATE(NewState));
    424          
    425            *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
    426          }
    427          
    428          /**
    429            * @brief  Configures the main PLL clock source, multiplication and division factors.
    430            * @note   This function must be used only when the main PLL is disabled.
    431            *  
    432            * @param  RCC_PLLSource: specifies the PLL entry clock source.
    433            *          This parameter can be one of the following values:
    434            *            @arg RCC_PLLSource_HSI: HSI oscillator clock selected as PLL clock entry
    435            *            @arg RCC_PLLSource_HSE: HSE oscillator clock selected as PLL clock entry
    436            * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.  
    437            *  
    438            * @param  PLLM: specifies the division factor for PLL VCO input clock
    439            *          This parameter must be a number between 0 and 63.
    440            * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
    441            *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
    442            *         of 2 MHz to limit PLL jitter.
    443            *  
    444            * @param  PLLN: specifies the multiplication factor for PLL VCO output clock
    445            *          This parameter must be a number between 192 and 432.
    446            * @note   You have to set the PLLN parameter correctly to ensure that the VCO
    447            *         output frequency is between 192 and 432 MHz.
    448            *   
    449            * @param  PLLP: specifies the division factor for main system clock (SYSCLK)
    450            *          This parameter must be a number in the range {2, 4, 6, or 8}.
    451            * @note   You have to set the PLLP parameter correctly to not exceed 168 MHz on
    452            *         the System clock frequency.
    453            *  
    454            * @param  PLLQ: specifies the division factor for OTG FS, SDIO and RNG clocks
    455            *          This parameter must be a number between 4 and 15.
    456            * @note   If the USB OTG FS is used in your application, you have to set the
    457            *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
    458            *         the SDIO and RNG need a frequency lower than or equal to 48 MHz to work
    459            *         correctly.
    460            *   
    461            * @retval None
    462            */
    463          void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
    464          {
    465            /* Check the parameters */
    466            assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
    467            assert_param(IS_RCC_PLLM_VALUE(PLLM));
    468            assert_param(IS_RCC_PLLN_VALUE(PLLN));
    469            assert_param(IS_RCC_PLLP_VALUE(PLLP));
    470            assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
    471          
    472            RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
    473                           (PLLQ << 24);
    474          }
    475          
    476          /**
    477            * @brief  Enables or disables the main PLL.
    478            * @note   After enabling the main PLL, the application software should wait on 
    479            *         PLLRDY flag to be set indicating that PLL clock is stable and can
    480            *         be used as system clock source.
    481            * @note   The main PLL can not be disabled if it is used as system clock source
    482            * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
    483            * @param  NewState: new state of the main PLL. This parameter can be: ENABLE or DISABLE.
    484            * @retval None
    485            */
    486          void RCC_PLLCmd(FunctionalState NewState)
    487          {
    488            /* Check the parameters */
    489            assert_param(IS_FUNCTIONAL_STATE(NewState));
    490            *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
    491          }
    492          
    493          #if defined (STM32F40_41xxx) || defined (STM32F401xx)
    494          /**
    495            * @brief  Configures the PLLI2S clock multiplication and division factors.
    496            *  
    497            * @note   This function can be used only for STM32F405xx/407xx, STM32F415xx/417xx 
    498            *         or STM32F401xx devices. 
    499            *    
    500            * @note   This function must be used only when the PLLI2S is disabled.
    501            * @note   PLLI2S clock source is common with the main PLL (configured in 
    502            *         RCC_PLLConfig function )  
    503            *             
    504            * @param  PLLI2SN: specifies the multiplication factor for PLLI2S VCO output clock
    505            *          This parameter must be a number between 192 and 432.
    506            * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
    507            *         output frequency is between 192 and 432 MHz.
    508            *    
    509            * @param  PLLI2SR: specifies the division factor for I2S clock
    510            *          This parameter must be a number between 2 and 7.
    511            * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
    512            *         on the I2S clock frequency.
    513            *   
    514            * @retval None
    515            */
    516          void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
    517          {
    518            /* Check the parameters */
    519            assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
    520            assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
    521          
    522            RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
    523          }
    524          #endif /* STM32F40_41xxx || STM32F401xx */
    525          
    526          #if defined (STM32F427_437xx) || defined (STM32F429_439xx)
    527          /**
    528            * @brief  Configures the PLLI2S clock multiplication and division factors.
    529            * 
    530            * @note   This function can be used only for STM32F42xxx/43xxx devices 
    531            *         
    532            * @note   This function must be used only when the PLLI2S is disabled.
    533            * @note   PLLI2S clock source is common with the main PLL (configured in 
    534            *         RCC_PLLConfig function )  
    535            *             
    536            * @param  PLLI2SN: specifies the multiplication factor for PLLI2S VCO output clock
    537            *          This parameter must be a number between 192 and 432.
    538            * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
    539            *         output frequency is between 192 and 432 MHz.
    540            * 
    541            * @param  PLLI2SQ: specifies the division factor for SAI1 clock
    542            *          This parameter must be a number between 2 and 15.
    543            *                 
    544            * @param  PLLI2SR: specifies the division factor for I2S clock
    545            *          This parameter must be a number between 2 and 7.
    546            * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
    547            *         on the I2S clock frequency.
    548            * @note   the PLLI2SR parameter is only available with STM32F42xxx/43xxx devices.  
    549            *   
    550            * @retval None
    551            */
    552          void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SQ, uint32_t PLLI2SR)
    553          {
    554            /* Check the parameters */
    555            assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
    556            assert_param(IS_RCC_PLLI2SQ_VALUE(PLLI2SQ));
    557            assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
    558          
    559            RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SQ << 24) | (PLLI2SR << 28);
    560          }
    561          #endif /* STM32F427_437xx ||  STM32F429_439xx */
    562          
    563          /**
    564            * @brief  Enables or disables the PLLI2S. 
    565            * @note   The PLLI2S is disabled by hardware when entering STOP and STANDBY modes.  
    566            * @param  NewState: new state of the PLLI2S. This parameter can be: ENABLE or DISABLE.
    567            * @retval None
    568            */
    569          void RCC_PLLI2SCmd(FunctionalState NewState)
    570          {
    571            /* Check the parameters */
    572            assert_param(IS_FUNCTIONAL_STATE(NewState));
    573            *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
    574          }
    575          
    576          /**
    577            * @brief  Configures the PLLSAI clock multiplication and division factors.
    578            *
    579            * @note   This function can be used only for STM32F42xxx/43xxx devices 
    580            *        
    581            * @note   This function must be used only when the PLLSAI is disabled.
    582            * @note   PLLSAI clock source is common with the main PLL (configured in 
    583            *         RCC_PLLConfig function )  
    584            *             
    585            * @param  PLLSAIN: specifies the multiplication factor for PLLSAI VCO output clock
    586            *          This parameter must be a number between 192 and 432.
    587            * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO 
    588            *         output frequency is between 192 and 432 MHz.
    589            *           
    590            * @param  PLLSAIQ: specifies the division factor for SAI1 clock
    591            *          This parameter must be a number between 2 and 15.
    592            *            
    593            * @param  PLLSAIR: specifies the division factor for LTDC clock
    594            *          This parameter must be a number between 2 and 7.
    595            *   
    596            * @retval None
    597            */
    598          void RCC_PLLSAIConfig(uint32_t PLLSAIN, uint32_t PLLSAIQ, uint32_t PLLSAIR)
    599          {
    600            /* Check the parameters */
    601            assert_param(IS_RCC_PLLSAIN_VALUE(PLLSAIN));
    602            assert_param(IS_RCC_PLLSAIR_VALUE(PLLSAIR));
    603          
    604            RCC->PLLSAICFGR = (PLLSAIN << 6) | (PLLSAIQ << 24) | (PLLSAIR << 28);
    605          }
    606          
    607          /**
    608            * @brief  Enables or disables the PLLSAI. 
    609            * 
    610            * @note   This function can be used only for STM32F42xxx/43xxx devices 
    611            *       
    612            * @note   The PLLSAI is disabled by hardware when entering STOP and STANDBY modes.  
    613            * @param  NewState: new state of the PLLSAI. This parameter can be: ENABLE or DISABLE.
    614            * @retval None
    615            */
    616          void RCC_PLLSAICmd(FunctionalState NewState)
    617          {
    618            /* Check the parameters */
    619            assert_param(IS_FUNCTIONAL_STATE(NewState));
    620            *(__IO uint32_t *) CR_PLLSAION_BB = (uint32_t)NewState;
    621          }
    622          
    623          /**
    624            * @brief  Enables or disables the Clock Security System.
    625            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
    626            *         is automatically disabled and an interrupt is generated to inform the
    627            *         software about the failure (Clock Security System Interrupt, CSSI),
    628            *         allowing the MCU to perform rescue operations. The CSSI is linked to 
    629            *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.  
    630            * @param  NewState: new state of the Clock Security System.
    631            *         This parameter can be: ENABLE or DISABLE.
    632            * @retval None
    633            */
    634          void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
    635          {
    636            /* Check the parameters */
    637            assert_param(IS_FUNCTIONAL_STATE(NewState));
    638            *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
    639          }
    640          
    641          /**
    642            * @brief  Selects the clock source to output on MCO1 pin(PA8).
    643            * @note   PA8 should be configured in alternate function mode.
    644            * @param  RCC_MCO1Source: specifies the clock source to output.
    645            *          This parameter can be one of the following values:
    646            *            @arg RCC_MCO1Source_HSI: HSI clock selected as MCO1 source
    647            *            @arg RCC_MCO1Source_LSE: LSE clock selected as MCO1 source
    648            *            @arg RCC_MCO1Source_HSE: HSE clock selected as MCO1 source
    649            *            @arg RCC_MCO1Source_PLLCLK: main PLL clock selected as MCO1 source
    650            * @param  RCC_MCO1Div: specifies the MCO1 prescaler.
    651            *          This parameter can be one of the following values:
    652            *            @arg RCC_MCO1Div_1: no division applied to MCO1 clock
    653            *            @arg RCC_MCO1Div_2: division by 2 applied to MCO1 clock
    654            *            @arg RCC_MCO1Div_3: division by 3 applied to MCO1 clock
    655            *            @arg RCC_MCO1Div_4: division by 4 applied to MCO1 clock
    656            *            @arg RCC_MCO1Div_5: division by 5 applied to MCO1 clock
    657            * @retval None
    658            */
    659          void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
    660          {
    661            uint32_t tmpreg = 0;
    662            
    663            /* Check the parameters */
    664            assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
    665            assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
    666          
    667            tmpreg = RCC->CFGR;
    668          
    669            /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
    670            tmpreg &= CFGR_MCO1_RESET_MASK;
    671          
    672            /* Select MCO1 clock source and prescaler */
    673            tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
    674          
    675            /* Store the new value */
    676            RCC->CFGR = tmpreg;  
    677          }
    678          
    679          /**
    680            * @brief  Selects the clock source to output on MCO2 pin(PC9).
    681            * @note   PC9 should be configured in alternate function mode.
    682            * @param  RCC_MCO2Source: specifies the clock source to output.
    683            *          This parameter can be one of the following values:
    684            *            @arg RCC_MCO2Source_SYSCLK: System clock (SYSCLK) selected as MCO2 source
    685            *            @arg RCC_MCO2Source_PLLI2SCLK: PLLI2S clock selected as MCO2 source
    686            *            @arg RCC_MCO2Source_HSE: HSE clock selected as MCO2 source
    687            *            @arg RCC_MCO2Source_PLLCLK: main PLL clock selected as MCO2 source
    688            * @param  RCC_MCO2Div: specifies the MCO2 prescaler.
    689            *          This parameter can be one of the following values:
    690            *            @arg RCC_MCO2Div_1: no division applied to MCO2 clock
    691            *            @arg RCC_MCO2Div_2: division by 2 applied to MCO2 clock
    692            *            @arg RCC_MCO2Div_3: division by 3 applied to MCO2 clock
    693            *            @arg RCC_MCO2Div_4: division by 4 applied to MCO2 clock
    694            *            @arg RCC_MCO2Div_5: division by 5 applied to MCO2 clock
    695            * @retval None
    696            */
    697          void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
    698          {
    699            uint32_t tmpreg = 0;
    700            
    701            /* Check the parameters */
    702            assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
    703            assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
    704            
    705            tmpreg = RCC->CFGR;
    706            
    707            /* Clear MCO2 and MCO2PRE[2:0] bits */
    708            tmpreg &= CFGR_MCO2_RESET_MASK;
    709          
    710            /* Select MCO2 clock source and prescaler */
    711            tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
    712          
    713            /* Store the new value */
    714            RCC->CFGR = tmpreg;  
    715          }
    716          
    717          /**
    718            * @}
    719            */
    720          
    721          /** @defgroup RCC_Group2 System AHB and APB busses clocks configuration functions
    722           *  @brief   System, AHB and APB busses clocks configuration functions
    723           *
    724          @verbatim   
    725           ===============================================================================
    726                ##### System, AHB and APB busses clocks configuration functions #####
    727           ===============================================================================  
    728              [..]
    729                This section provide functions allowing to configure the System, AHB, APB1 and 
    730                APB2 busses clocks.
    731            
    732                (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
    733                    HSE and PLL.
    734                    The AHB clock (HCLK) is derived from System clock through configurable 
    735                    prescaler and used to clock the CPU, memory and peripherals mapped 
    736                    on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived 
    737                    from AHB clock through configurable prescalers and used to clock 
    738                    the peripherals mapped on these busses. You can use 
    739                    "RCC_GetClocksFreq()" function to retrieve the frequencies of these clocks.  
    740          
    741                -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
    742                  (+@) I2S: the I2S clock can be derived either from a specific PLL (PLLI2S) or
    743                       from an external clock mapped on the I2S_CKIN pin. 
    744                       You have to use RCC_I2SCLKConfig() function to configure this clock. 
    745                  (+@) RTC: the RTC clock can be derived either from the LSI, LSE or HSE clock
    746                       divided by 2 to 31. You have to use RCC_RTCCLKConfig() and RCC_RTCCLKCmd()
    747                       functions to configure this clock. 
    748                  (+@) USB OTG FS, SDIO and RTC: USB OTG FS require a frequency equal to 48 MHz
    749                       to work correctly, while the SDIO require a frequency equal or lower than
    750                       to 48. This clock is derived of the main PLL through PLLQ divider.
    751                  (+@) IWDG clock which is always the LSI clock.
    752                 
    753                (#) For STM32F405xx/407xx and STM32F415xx/417xx devices, the maximum frequency 
    754                   of the SYSCLK and HCLK is 168 MHz, PCLK2 84 MHz and PCLK1 42 MHz. Depending 
    755                   on the device voltage range, the maximum frequency should be adapted accordingly:
    756           +-------------------------------------------------------------------------------------+     
    757           | Latency       |                HCLK clock frequency (MHz)                           |
    758           |               |---------------------------------------------------------------------|     
    759           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    760           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    761           |---------------|----------------|----------------|-----------------|-----------------|              
    762           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    763           |---------------|----------------|----------------|-----------------|-----------------|   
    764           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    765           |---------------|----------------|----------------|-----------------|-----------------|   
    766           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    767           |---------------|----------------|----------------|-----------------|-----------------| 
    768           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
    769           |---------------|----------------|----------------|-----------------|-----------------| 
    770           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
    771           |---------------|----------------|----------------|-----------------|-----------------| 
    772           |5WS(6CPU cycle)|150< HCLK <= 168|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120| 
    773           |---------------|----------------|----------------|-----------------|-----------------| 
    774           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140| 
    775           |---------------|----------------|----------------|-----------------|-----------------| 
    776           |7WS(8CPU cycle)|      NA        |      NA        |154 < HCLK <= 168|140 < HCLK <= 160|
    777           +---------------|----------------|----------------|-----------------|-----------------+ 
    778                (#) For STM32F42xxx/43xxx devices, the maximum frequency of the SYSCLK and HCLK is 180 MHz, 
    779                    PCLK2 90 MHz and PCLK1 45 MHz. Depending on the device voltage range, the maximum 
    780                    frequency should be adapted accordingly:
    781           +-------------------------------------------------------------------------------------+     
    782           | Latency       |                HCLK clock frequency (MHz)                           |
    783           |               |---------------------------------------------------------------------|     
    784           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    785           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    786           |---------------|----------------|----------------|-----------------|-----------------|              
    787           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    788           |---------------|----------------|----------------|-----------------|-----------------|   
    789           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    790           |---------------|----------------|----------------|-----------------|-----------------|   
    791           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    792           |---------------|----------------|----------------|-----------------|-----------------| 
    793           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
    794           |---------------|----------------|----------------|-----------------|-----------------| 
    795           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
    796           |---------------|----------------|----------------|-----------------|-----------------| 
    797           |5WS(6CPU cycle)|120< HCLK <= 180|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120| 
    798           |---------------|----------------|----------------|-----------------|-----------------| 
    799           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140| 
    800           |---------------|----------------|----------------|-----------------|-----------------| 
    801           |7WS(8CPU cycle)|      NA        |168< HCLK <= 180|154 < HCLK <= 176|140 < HCLK <= 160|
    802           |---------------|----------------|----------------|-----------------|-----------------| 
    803           |8WS(9CPU cycle)|      NA        |      NA        |176 < HCLK <= 180|160 < HCLK <= 168|
    804           +-------------------------------------------------------------------------------------+
    805             
    806                (#) For STM32F401xx devices, the maximum frequency of the SYSCLK and HCLK is 84 MHz, 
    807                    PCLK2 84 MHz and PCLK1 42 MHz. Depending on the device voltage range, the maximum 
    808                    frequency should be adapted accordingly:
    809           +-------------------------------------------------------------------------------------+     
    810           | Latency       |                HCLK clock frequency (MHz)                           |
    811           |               |---------------------------------------------------------------------|     
    812           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    813           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    814           |---------------|----------------|----------------|-----------------|-----------------|              
    815           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    816           |---------------|----------------|----------------|-----------------|-----------------|   
    817           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    818           |---------------|----------------|----------------|-----------------|-----------------|   
    819           |2WS(3CPU cycle)|60 < HCLK <= 84 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    820           |---------------|----------------|----------------|-----------------|-----------------| 
    821           |3WS(4CPU cycle)|      NA        |72 < HCLK <= 84 |66 < HCLK <= 84  |60 < HCLK <= 80  |
    822           |---------------|----------------|----------------|-----------------|-----------------| 
    823           |4WS(5CPU cycle)|      NA        |      NA        |      NA         |80 < HCLK <= 84  | 
    824           +-------------------------------------------------------------------------------------+ 
    825            
    826                -@- On STM32F405xx/407xx and STM32F415xx/417xx devices: 
    827                     (++) when VOS = '0', the maximum value of fHCLK = 144MHz. 
    828                     (++) when VOS = '1', the maximum value of fHCLK = 168MHz. 
    829                    [..] 
    830                    On STM32F42xxx/43xxx devices:
    831                     (++) when VOS[1:0] = '0x01', the maximum value of fHCLK is 120MHz.
    832                     (++) when VOS[1:0] = '0x10', the maximum value of fHCLK is 144MHz.
    833                     (++) when VOS[1:0] = '0x11', the maximum value of f  is 168MHz 
    834                    [..]  
    835                    On STM32F401x devices:
    836                     (++) when VOS[1:0] = '0x01', the maximum value of fHCLK is 64MHz.
    837                     (++) when VOS[1:0] = '0x10', the maximum value of fHCLK is 84MHz.
    838                     You can use PWR_MainRegulatorModeConfig() function to control VOS bits.
    839          
    840          @endverbatim
    841            * @{
    842            */
    843          
    844          /**
    845            * @brief  Configures the system clock (SYSCLK).
    846            * @note   The HSI is used (enabled by hardware) as system clock source after
    847            *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
    848            *         of failure of the HSE used directly or indirectly as system clock
    849            *         (if the Clock Security System CSS is enabled).
    850            * @note   A switch from one clock source to another occurs only if the target
    851            *         clock source is ready (clock stable after startup delay or PLL locked). 
    852            *         If a clock source which is not yet ready is selected, the switch will
    853            *         occur when the clock source will be ready. 
    854            *         You can use RCC_GetSYSCLKSource() function to know which clock is
    855            *         currently used as system clock source. 
    856            * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.
    857            *          This parameter can be one of the following values:
    858            *            @arg RCC_SYSCLKSource_HSI:    HSI selected as system clock source
    859            *            @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
    860            *            @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
    861            * @retval None
    862            */
    863          void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
    864          {
    865            uint32_t tmpreg = 0;
    866          
    867            /* Check the parameters */
    868            assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
    869          
    870            tmpreg = RCC->CFGR;
    871          
    872            /* Clear SW[1:0] bits */
    873            tmpreg &= ~RCC_CFGR_SW;
    874          
    875            /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
    876            tmpreg |= RCC_SYSCLKSource;
    877          
    878            /* Store the new value */
    879            RCC->CFGR = tmpreg;
    880          }
    881          
    882          /**
    883            * @brief  Returns the clock source used as system clock.
    884            * @param  None
    885            * @retval The clock source used as system clock. The returned value can be one
    886            *         of the following:
    887            *              - 0x00: HSI used as system clock
    888            *              - 0x04: HSE used as system clock
    889            *              - 0x08: PLL used as system clock
    890            */
    891          uint8_t RCC_GetSYSCLKSource(void)
    892          {
    893            return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
    894          }
    895          
    896          /**
    897            * @brief  Configures the AHB clock (HCLK).
    898            * @note   Depending on the device voltage range, the software has to set correctly
    899            *         these bits to ensure that HCLK not exceed the maximum allowed frequency
    900            *         (for more details refer to section above
    901            *           "CPU, AHB and APB busses clocks configuration functions")
    902            * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
    903            *         the system clock (SYSCLK).
    904            *          This parameter can be one of the following values:
    905            *            @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK
    906            *            @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
    907            *            @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
    908            *            @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
    909            *            @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
    910            *            @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
    911            *            @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
    912            *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
    913            *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
    914            * @retval None
    915            */
    916          void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
    917          {
    918            uint32_t tmpreg = 0;
    919            
    920            /* Check the parameters */
    921            assert_param(IS_RCC_HCLK(RCC_SYSCLK));
    922          
    923            tmpreg = RCC->CFGR;
    924          
    925            /* Clear HPRE[3:0] bits */
    926            tmpreg &= ~RCC_CFGR_HPRE;
    927          
    928            /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
    929            tmpreg |= RCC_SYSCLK;
    930          
    931            /* Store the new value */
    932            RCC->CFGR = tmpreg;
    933          }
    934          
    935          
    936          /**
    937            * @brief  Configures the Low Speed APB clock (PCLK1).
    938            * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
    939            *         the AHB clock (HCLK).
    940            *          This parameter can be one of the following values:
    941            *            @arg RCC_HCLK_Div1:  APB1 clock = HCLK
    942            *            @arg RCC_HCLK_Div2:  APB1 clock = HCLK/2
    943            *            @arg RCC_HCLK_Div4:  APB1 clock = HCLK/4
    944            *            @arg RCC_HCLK_Div8:  APB1 clock = HCLK/8
    945            *            @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
    946            * @retval None
    947            */
    948          void RCC_PCLK1Config(uint32_t RCC_HCLK)
    949          {
    950            uint32_t tmpreg = 0;
    951          
    952            /* Check the parameters */
    953            assert_param(IS_RCC_PCLK(RCC_HCLK));
    954          
    955            tmpreg = RCC->CFGR;
    956          
    957            /* Clear PPRE1[2:0] bits */
    958            tmpreg &= ~RCC_CFGR_PPRE1;
    959          
    960            /* Set PPRE1[2:0] bits according to RCC_HCLK value */
    961            tmpreg |= RCC_HCLK;
    962          
    963            /* Store the new value */
    964            RCC->CFGR = tmpreg;
    965          }
    966          
    967          /**
    968            * @brief  Configures the High Speed APB clock (PCLK2).
    969            * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
    970            *         the AHB clock (HCLK).
    971            *          This parameter can be one of the following values:
    972            *            @arg RCC_HCLK_Div1:  APB2 clock = HCLK
    973            *            @arg RCC_HCLK_Div2:  APB2 clock = HCLK/2
    974            *            @arg RCC_HCLK_Div4:  APB2 clock = HCLK/4
    975            *            @arg RCC_HCLK_Div8:  APB2 clock = HCLK/8
    976            *            @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
    977            * @retval None
    978            */
    979          void RCC_PCLK2Config(uint32_t RCC_HCLK)
    980          {
    981            uint32_t tmpreg = 0;
    982          
    983            /* Check the parameters */
    984            assert_param(IS_RCC_PCLK(RCC_HCLK));
    985          
    986            tmpreg = RCC->CFGR;
    987          
    988            /* Clear PPRE2[2:0] bits */
    989            tmpreg &= ~RCC_CFGR_PPRE2;
    990          
    991            /* Set PPRE2[2:0] bits according to RCC_HCLK value */
    992            tmpreg |= RCC_HCLK << 3;
    993          
    994            /* Store the new value */
    995            RCC->CFGR = tmpreg;
    996          }
    997          
    998          /**
    999            * @brief  Returns the frequencies of different on chip clocks; SYSCLK, HCLK, 
   1000            *         PCLK1 and PCLK2.       
   1001            * 
   1002            * @note   The system frequency computed by this function is not the real 
   1003            *         frequency in the chip. It is calculated based on the predefined 
   1004            *         constant and the selected clock source:
   1005            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
   1006            * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)
   1007            * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**) 
   1008            *           or HSI_VALUE(*) multiplied/divided by the PLL factors.         
   1009            * @note     (*) HSI_VALUE is a constant defined in stm32f4xx.h file (default value
   1010            *               16 MHz) but the real value may vary depending on the variations
   1011            *               in voltage and temperature.
   1012            * @note     (**) HSE_VALUE is a constant defined in stm32f4xx.h file (default value
   1013            *                25 MHz), user has to ensure that HSE_VALUE is same as the real
   1014            *                frequency of the crystal used. Otherwise, this function may
   1015            *                have wrong result.
   1016            *                
   1017            * @note   The result of this function could be not correct when using fractional
   1018            *         value for HSE crystal.
   1019            *   
   1020            * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
   1021            *          the clocks frequencies.
   1022            *     
   1023            * @note   This function can be used by the user application to compute the 
   1024            *         baudrate for the communication peripherals or configure other parameters.
   1025            * @note   Each time SYSCLK, HCLK, PCLK1 and/or PCLK2 clock changes, this function
   1026            *         must be called to update the structure's field. Otherwise, any
   1027            *         configuration based on this function will be incorrect.
   1028            *    
   1029            * @retval None
   1030            */
   1031          void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
   1032          {
   1033            uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
   1034          
   1035            /* Get SYSCLK source -------------------------------------------------------*/
   1036            tmp = RCC->CFGR & RCC_CFGR_SWS;
   1037          
   1038            switch (tmp)
   1039            {
   1040              case 0x00:  /* HSI used as system clock source */
   1041                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   1042                break;
   1043              case 0x04:  /* HSE used as system clock  source */
   1044                RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
   1045                break;
   1046              case 0x08:  /* PLL used as system clock  source */
   1047          
   1048                /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
   1049                   SYSCLK = PLL_VCO / PLLP
   1050                   */    
   1051                pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
   1052                pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
   1053                
   1054                if (pllsource != 0)
   1055                {
   1056                  /* HSE used as PLL clock source */
   1057                  pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
   1058                }
   1059                else
   1060                {
   1061                  /* HSI used as PLL clock source */
   1062                  pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
   1063                }
   1064          
   1065                pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
   1066                RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
   1067                break;
   1068              default:
   1069                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   1070                break;
   1071            }
   1072            /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
   1073          
   1074            /* Get HCLK prescaler */
   1075            tmp = RCC->CFGR & RCC_CFGR_HPRE;
   1076            tmp = tmp >> 4;
   1077            presc = APBAHBPrescTable[tmp];
   1078            /* HCLK clock frequency */
   1079            RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
   1080          
   1081            /* Get PCLK1 prescaler */
   1082            tmp = RCC->CFGR & RCC_CFGR_PPRE1;
   1083            tmp = tmp >> 10;
   1084            presc = APBAHBPrescTable[tmp];
   1085            /* PCLK1 clock frequency */
   1086            RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   1087          
   1088            /* Get PCLK2 prescaler */
   1089            tmp = RCC->CFGR & RCC_CFGR_PPRE2;
   1090            tmp = tmp >> 13;
   1091            presc = APBAHBPrescTable[tmp];
   1092            /* PCLK2 clock frequency */
   1093            RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   1094          }
   1095          
   1096          /**
   1097            * @}
   1098            */
   1099          
   1100          /** @defgroup RCC_Group3 Peripheral clocks configuration functions
   1101           *  @brief   Peripheral clocks configuration functions 
   1102           *
   1103          @verbatim   
   1104           ===============================================================================
   1105                        ##### Peripheral clocks configuration functions #####
   1106           ===============================================================================  
   1107              [..] This section provide functions allowing to configure the Peripheral clocks. 
   1108            
   1109                (#) The RTC clock which is derived from the LSI, LSE or HSE clock divided 
   1110                    by 2 to 31.
   1111               
   1112                (#) After restart from Reset or wakeup from STANDBY, all peripherals are off
   1113                    except internal SRAM, Flash and JTAG. Before to start using a peripheral 
   1114                    you have to enable its interface clock. You can do this using 
   1115                    RCC_AHBPeriphClockCmd(), RCC_APB2PeriphClockCmd() and RCC_APB1PeriphClockCmd() functions.
   1116          
   1117                (#) To reset the peripherals configuration (to the default state after device reset)
   1118                    you can use RCC_AHBPeriphResetCmd(), RCC_APB2PeriphResetCmd() and 
   1119                    RCC_APB1PeriphResetCmd() functions.
   1120               
   1121                (#) To further reduce power consumption in SLEEP mode the peripheral clocks 
   1122                    can be disabled prior to executing the WFI or WFE instructions. 
   1123                    You can do this using RCC_AHBPeriphClockLPModeCmd(), 
   1124                    RCC_APB2PeriphClockLPModeCmd() and RCC_APB1PeriphClockLPModeCmd() functions.  
   1125          
   1126          @endverbatim
   1127            * @{
   1128            */
   1129          
   1130          /**
   1131            * @brief  Configures the RTC clock (RTCCLK).
   1132            * @note   As the RTC clock configuration bits are in the Backup domain and write
   1133            *         access is denied to this domain after reset, you have to enable write
   1134            *         access using PWR_BackupAccessCmd(ENABLE) function before to configure
   1135            *         the RTC clock source (to be done once after reset).    
   1136            * @note   Once the RTC clock is configured it can't be changed unless the  
   1137            *         Backup domain is reset using RCC_BackupResetCmd() function, or by
   1138            *         a Power On Reset (POR).
   1139            *    
   1140            * @param  RCC_RTCCLKSource: specifies the RTC clock source.
   1141            *          This parameter can be one of the following values:
   1142            *            @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
   1143            *            @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
   1144            *            @arg RCC_RTCCLKSource_HSE_Divx: HSE clock divided by x selected
   1145            *                                            as RTC clock, where x:[2,31]
   1146            *  
   1147            * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
   1148            *         work in STOP and STANDBY modes, and can be used as wakeup source.
   1149            *         However, when the HSE clock is used as RTC clock source, the RTC
   1150            *         cannot be used in STOP and STANDBY modes.    
   1151            * @note   The maximum input clock frequency for RTC is 1MHz (when using HSE as
   1152            *         RTC clock source).
   1153            *  
   1154            * @retval None
   1155            */
   1156          void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
   1157          {
   1158            uint32_t tmpreg = 0;
   1159          
   1160            /* Check the parameters */
   1161            assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
   1162          
   1163            if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
   1164            { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
   1165              tmpreg = RCC->CFGR;
   1166          
   1167              /* Clear RTCPRE[4:0] bits */
   1168              tmpreg &= ~RCC_CFGR_RTCPRE;
   1169          
   1170              /* Configure HSE division factor for RTC clock */
   1171              tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
   1172          
   1173              /* Store the new value */
   1174              RCC->CFGR = tmpreg;
   1175            }
   1176              
   1177            /* Select the RTC clock source */
   1178            RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
   1179          }
   1180          
   1181          /**
   1182            * @brief  Enables or disables the RTC clock.
   1183            * @note   This function must be used only after the RTC clock source was selected
   1184            *         using the RCC_RTCCLKConfig function.
   1185            * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
   1186            * @retval None
   1187            */
   1188          void RCC_RTCCLKCmd(FunctionalState NewState)
   1189          {
   1190            /* Check the parameters */
   1191            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1192          
   1193            *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
   1194          }
   1195          
   1196          /**
   1197            * @brief  Forces or releases the Backup domain reset.
   1198            * @note   This function resets the RTC peripheral (including the backup registers)
   1199            *         and the RTC clock source selection in RCC_CSR register.
   1200            * @note   The BKPSRAM is not affected by this reset.    
   1201            * @param  NewState: new state of the Backup domain reset.
   1202            *          This parameter can be: ENABLE or DISABLE.
   1203            * @retval None
   1204            */
   1205          void RCC_BackupResetCmd(FunctionalState NewState)
   1206          {
   1207            /* Check the parameters */
   1208            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1209            *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
   1210          }
   1211          
   1212          /**
   1213            * @brief  Configures the I2S clock source (I2SCLK).
   1214            * @note   This function must be called before enabling the I2S APB clock.
   1215            * @param  RCC_I2SCLKSource: specifies the I2S clock source.
   1216            *          This parameter can be one of the following values:
   1217            *            @arg RCC_I2S2CLKSource_PLLI2S: PLLI2S clock used as I2S clock source
   1218            *            @arg RCC_I2S2CLKSource_Ext: External clock mapped on the I2S_CKIN pin
   1219            *                                        used as I2S clock source
   1220            * @retval None
   1221            */
   1222          void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
   1223          {
   1224            /* Check the parameters */
   1225            assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
   1226          
   1227            *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
   1228          }
   1229          
   1230          /**
   1231            * @brief  Configures the SAI clock Divider coming from PLLI2S.
   1232            * 
   1233            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1234            *   
   1235            * @note   This function must be called before enabling the PLLI2S.
   1236            *              
   1237            * @param  RCC_PLLI2SDivQ: specifies the PLLI2S division factor for SAI1 clock .
   1238            *          This parameter must be a number between 1 and 32.
   1239            *          SAI1 clock frequency = f(PLLI2S_Q) / RCC_PLLI2SDivQ 
   1240            *              
   1241            * @retval None
   1242            */
   1243          void RCC_SAIPLLI2SClkDivConfig(uint32_t RCC_PLLI2SDivQ)  
   1244          {
   1245            uint32_t tmpreg = 0;
   1246            
   1247            /* Check the parameters */
   1248            assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(RCC_PLLI2SDivQ));
   1249            
   1250            tmpreg = RCC->DCKCFGR;
   1251          
   1252            /* Clear PLLI2SDIVQ[4:0] bits */
   1253            tmpreg &= ~(RCC_DCKCFGR_PLLI2SDIVQ);
   1254          
   1255            /* Set PLLI2SDIVQ values */
   1256            tmpreg |= (RCC_PLLI2SDivQ - 1);
   1257          
   1258            /* Store the new value */
   1259            RCC->DCKCFGR = tmpreg;
   1260          }
   1261          
   1262          /**
   1263            * @brief  Configures the SAI clock Divider coming from PLLSAI.
   1264            * 
   1265            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1266            *        
   1267            * @note   This function must be called before enabling the PLLSAI.
   1268            *   
   1269            * @param  RCC_PLLSAIDivQ: specifies the PLLSAI division factor for SAI1 clock .
   1270            *          This parameter must be a number between 1 and 32.
   1271            *          SAI1 clock frequency = f(PLLSAI_Q) / RCC_PLLSAIDivQ  
   1272            *              
   1273            * @retval None
   1274            */
   1275          void RCC_SAIPLLSAIClkDivConfig(uint32_t RCC_PLLSAIDivQ)  
   1276          {
   1277            uint32_t tmpreg = 0;
   1278            
   1279            /* Check the parameters */
   1280            assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(RCC_PLLSAIDivQ));
   1281            
   1282            tmpreg = RCC->DCKCFGR;
   1283          
   1284            /* Clear PLLI2SDIVQ[4:0] and PLLSAIDIVQ[4:0] bits */
   1285            tmpreg &= ~(RCC_DCKCFGR_PLLSAIDIVQ);
   1286          
   1287            /* Set PLLSAIDIVQ values */
   1288            tmpreg |= ((RCC_PLLSAIDivQ - 1) << 8);
   1289          
   1290            /* Store the new value */
   1291            RCC->DCKCFGR = tmpreg;
   1292          }
   1293          
   1294          /**
   1295            * @brief  Configures SAI1BlockA clock source selection.
   1296            * 
   1297            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1298            *       
   1299            * @note   This function must be called before enabling PLLSAI, PLLI2S and  
   1300            *         the SAI clock.
   1301            * @param  RCC_SAIBlockACLKSource: specifies the SAI Block A clock source.
   1302            *          This parameter can be one of the following values:
   1303            *            @arg RCC_SAIACLKSource_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
   1304            *                                           as SAI1 Block A clock 
   1305            *            @arg RCC_SAIACLKSource_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
   1306            *                                           as SAI1 Block A clock 
   1307            *            @arg RCC_SAIACLKSource_Ext: External clock mapped on the I2S_CKIN pin
   1308            *                                        used as SAI1 Block A clock
   1309            * @retval None
   1310            */
   1311          void RCC_SAIBlockACLKConfig(uint32_t RCC_SAIBlockACLKSource)
   1312          {
   1313            uint32_t tmpreg = 0;
   1314            
   1315            /* Check the parameters */
   1316            assert_param(IS_RCC_SAIACLK_SOURCE(RCC_SAIBlockACLKSource));
   1317            
   1318            tmpreg = RCC->DCKCFGR;
   1319          
   1320            /* Clear RCC_DCKCFGR_SAI1ASRC[1:0] bits */
   1321            tmpreg &= ~RCC_DCKCFGR_SAI1ASRC;
   1322          
   1323            /* Set SAI Block A source selection value */
   1324            tmpreg |= RCC_SAIBlockACLKSource;
   1325          
   1326            /* Store the new value */
   1327            RCC->DCKCFGR = tmpreg;
   1328          }
   1329          
   1330          /**
   1331            * @brief  Configures SAI1BlockB clock source selection.
   1332            * 
   1333            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1334            *       
   1335            * @note   This function must be called before enabling PLLSAI, PLLI2S and  
   1336            *         the SAI clock.
   1337            * @param  RCC_SAIBlockBCLKSource: specifies the SAI Block B clock source.
   1338            *          This parameter can be one of the following values:
   1339            *            @arg RCC_SAIBCLKSource_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
   1340            *                                           as SAI1 Block B clock 
   1341            *            @arg RCC_SAIBCLKSource_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
   1342            *                                           as SAI1 Block B clock 
   1343            *            @arg RCC_SAIBCLKSource_Ext: External clock mapped on the I2S_CKIN pin
   1344            *                                        used as SAI1 Block B clock
   1345            * @retval None
   1346            */
   1347          void RCC_SAIBlockBCLKConfig(uint32_t RCC_SAIBlockBCLKSource)
   1348          {
   1349            uint32_t tmpreg = 0;
   1350            
   1351            /* Check the parameters */
   1352            assert_param(IS_RCC_SAIBCLK_SOURCE(RCC_SAIBlockBCLKSource));
   1353            
   1354            tmpreg = RCC->DCKCFGR;
   1355          
   1356            /* Clear RCC_DCKCFGR_SAI1BSRC[1:0] bits */
   1357            tmpreg &= ~RCC_DCKCFGR_SAI1BSRC;
   1358          
   1359            /* Set SAI Block B source selection value */
   1360            tmpreg |= RCC_SAIBlockBCLKSource;
   1361          
   1362            /* Store the new value */
   1363            RCC->DCKCFGR = tmpreg;
   1364          }
   1365          
   1366          
   1367          /**
   1368            * @brief  Configures the LTDC clock Divider coming from PLLSAI.
   1369            * 
   1370            * @note   The LTDC peripheral is only available with STM32F429xx/439xx Devices.
   1371            *      
   1372            * @note   This function must be called before enabling the PLLSAI.
   1373            *   
   1374            * @param  RCC_PLLSAIDivR: specifies the PLLSAI division factor for LTDC clock .
   1375            *          This parameter must be a number between 2 and 16.
   1376            *          LTDC clock frequency = f(PLLSAI_R) / RCC_PLLSAIDivR  
   1377            *            
   1378            * @retval None
   1379            */
   1380          void RCC_LTDCCLKDivConfig(uint32_t RCC_PLLSAIDivR)
   1381          {
   1382            uint32_t tmpreg = 0;
   1383            
   1384            /* Check the parameters */
   1385            assert_param(IS_RCC_PLLSAI_DIVR_VALUE(RCC_PLLSAIDivR));
   1386            
   1387            tmpreg = RCC->DCKCFGR;
   1388          
   1389            /* Clear PLLSAIDIVR[2:0] bits */
   1390            tmpreg &= ~RCC_DCKCFGR_PLLSAIDIVR;
   1391          
   1392            /* Set PLLSAIDIVR values */
   1393            tmpreg |= RCC_PLLSAIDivR;
   1394          
   1395            /* Store the new value */
   1396            RCC->DCKCFGR = tmpreg;
   1397          }
   1398          
   1399          /**
   1400            * @brief  Configures the Timers clocks prescalers selection.
   1401            * 
   1402            * @note   This function can be used only for STM32F42xxx/43xxx and STM32F401xx devices. 
   1403            *   
   1404            * @param  RCC_TIMCLKPrescaler : specifies the Timers clocks prescalers selection
   1405            *         This parameter can be one of the following values:
   1406            *            @arg RCC_TIMPrescDesactivated: The Timers kernels clocks prescaler is 
   1407            *                 equal to HPRE if PPREx is corresponding to division by 1 or 2, 
   1408            *                 else it is equal to [(HPRE * PPREx) / 2] if PPREx is corresponding to 
   1409            *                 division by 4 or more.
   1410            *                   
   1411            *            @arg RCC_TIMPrescActivated: The Timers kernels clocks prescaler is 
   1412            *                 equal to HPRE if PPREx is corresponding to division by 1, 2 or 4, 
   1413            *                 else it is equal to [(HPRE * PPREx) / 4] if PPREx is corresponding 
   1414            *                 to division by 8 or more.
   1415            * @retval None
   1416            */
   1417          void RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler)
   1418          {
   1419            /* Check the parameters */
   1420            assert_param(IS_RCC_TIMCLK_PRESCALER(RCC_TIMCLKPrescaler));
   1421          
   1422            *(__IO uint32_t *) DCKCFGR_TIMPRE_BB = RCC_TIMCLKPrescaler;
   1423            
   1424          }
   1425          
   1426          /**
   1427            * @brief  Enables or disables the AHB1 peripheral clock.
   1428            * @note   After reset, the peripheral clock (used for registers read/write access)
   1429            *         is disabled and the application software has to enable this clock before 
   1430            *         using it.   
   1431            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
   1432            *          This parameter can be any combination of the following values:
   1433            *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
   1434            *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
   1435            *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
   1436            *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
   1437            *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
   1438            *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
   1439            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1440            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1441            *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
   1442            *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
   1443            *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)  
   1444            *            @arg RCC_AHB1Periph_CRC:         CRC clock
   1445            *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
   1446            *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
   1447            *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
   1448            *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
   1449            *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices)  
   1450            *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
   1451            *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
   1452            *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
   1453            *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
   1454            *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
   1455            *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
   1456            * @param  NewState: new state of the specified peripheral clock.
   1457            *          This parameter can be: ENABLE or DISABLE.
   1458            * @retval None
   1459            */
   1460          void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1461          {
   1462            /* Check the parameters */
   1463            assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
   1464          
   1465            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1466            if (NewState != DISABLE)
   1467            {
   1468              RCC->AHB1ENR |= RCC_AHB1Periph;
   1469            }
   1470            else
   1471            {
   1472              RCC->AHB1ENR &= ~RCC_AHB1Periph;
   1473            }
   1474          }
   1475          
   1476          /**
   1477            * @brief  Enables or disables the AHB2 peripheral clock.
   1478            * @note   After reset, the peripheral clock (used for registers read/write access)
   1479            *         is disabled and the application software has to enable this clock before 
   1480            *         using it. 
   1481            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
   1482            *          This parameter can be any combination of the following values:
   1483            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
   1484            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
   1485            *            @arg RCC_AHB2Periph_HASH:   HASH clock
   1486            *            @arg RCC_AHB2Periph_RNG:    RNG clock
   1487            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
   1488            * @param  NewState: new state of the specified peripheral clock.
   1489            *          This parameter can be: ENABLE or DISABLE.
   1490            * @retval None
   1491            */
   1492          void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1493          {
   1494            /* Check the parameters */
   1495            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   1496            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1497          
   1498            if (NewState != DISABLE)
   1499            {
   1500              RCC->AHB2ENR |= RCC_AHB2Periph;
   1501            }
   1502            else
   1503            {
   1504              RCC->AHB2ENR &= ~RCC_AHB2Periph;
   1505            }
   1506          }
   1507          
   1508          /**
   1509            * @brief  Enables or disables the AHB3 peripheral clock.
   1510            * @note   After reset, the peripheral clock (used for registers read/write access)
   1511            *         is disabled and the application software has to enable this clock before 
   1512            *         using it. 
   1513            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
   1514            *          This parameter must be: RCC_AHB3Periph_FSMC
   1515            *                                  or RCC_AHB3Periph_FMC (STM32F42xxx/43xxx devices)  
   1516            * @param  NewState: new state of the specified peripheral clock.
   1517            *          This parameter can be: ENABLE or DISABLE.
   1518            * @retval None
   1519            */
   1520          void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1521          {
   1522            /* Check the parameters */
   1523            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
   1524            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1525          
   1526            if (NewState != DISABLE)
   1527            {
   1528              RCC->AHB3ENR |= RCC_AHB3Periph;
   1529            }
   1530            else
   1531            {
   1532              RCC->AHB3ENR &= ~RCC_AHB3Periph;
   1533            }
   1534          }
   1535          
   1536          /**
   1537            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
   1538            * @note   After reset, the peripheral clock (used for registers read/write access)
   1539            *         is disabled and the application software has to enable this clock before 
   1540            *         using it. 
   1541            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1542            *          This parameter can be any combination of the following values:
   1543            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
   1544            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
   1545            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
   1546            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
   1547            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
   1548            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
   1549            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
   1550            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
   1551            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
   1552            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
   1553            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
   1554            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
   1555            *            @arg RCC_APB1Periph_USART2: USART2 clock
   1556            *            @arg RCC_APB1Periph_USART3: USART3 clock
   1557            *            @arg RCC_APB1Periph_UART4:  UART4 clock
   1558            *            @arg RCC_APB1Periph_UART5:  UART5 clock
   1559            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
   1560            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
   1561            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
   1562            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
   1563            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
   1564            *            @arg RCC_APB1Periph_PWR:    PWR clock
   1565            *            @arg RCC_APB1Periph_DAC:    DAC clock
   1566            *            @arg RCC_APB1Periph_UART7:  UART7 clock
   1567            *            @arg RCC_APB1Periph_UART8:  UART8 clock
   1568            * @param  NewState: new state of the specified peripheral clock.
   1569            *          This parameter can be: ENABLE or DISABLE.
   1570            * @retval None
   1571            */
   1572          void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1573          {
   1574            /* Check the parameters */
   1575            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
   1576            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1577          
   1578            if (NewState != DISABLE)
   1579            {
   1580              RCC->APB1ENR |= RCC_APB1Periph;
   1581            }
   1582            else
   1583            {
   1584              RCC->APB1ENR &= ~RCC_APB1Periph;
   1585            }
   1586          }
   1587          
   1588          /**
   1589            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
   1590            * @note   After reset, the peripheral clock (used for registers read/write access)
   1591            *         is disabled and the application software has to enable this clock before 
   1592            *         using it.
   1593            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1594            *          This parameter can be any combination of the following values:
   1595            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
   1596            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
   1597            *            @arg RCC_APB2Periph_USART1: USART1 clock
   1598            *            @arg RCC_APB2Periph_USART6: USART6 clock
   1599            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
   1600            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
   1601            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
   1602            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
   1603            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
   1604            *            @arg RCC_APB2Periph_SPI4:   SPI4 clock
   1605            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
   1606            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
   1607            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
   1608            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
   1609            *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
   1610            *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
   1611            *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
   1612            *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices) 
   1613            * @param  NewState: new state of the specified peripheral clock.
   1614            *          This parameter can be: ENABLE or DISABLE.
   1615            * @retval None
   1616            */
   1617          void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1618          {
   1619            /* Check the parameters */
   1620            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   1621            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1622          
   1623            if (NewState != DISABLE)
   1624            {
   1625              RCC->APB2ENR |= RCC_APB2Periph;
   1626            }
   1627            else
   1628            {
   1629              RCC->APB2ENR &= ~RCC_APB2Periph;
   1630            }
   1631          }
   1632          
   1633          /**
   1634            * @brief  Forces or releases AHB1 peripheral reset.
   1635            * @param  RCC_AHB1Periph: specifies the AHB1 peripheral to reset.
   1636            *          This parameter can be any combination of the following values:
   1637            *            @arg RCC_AHB1Periph_GPIOA:   GPIOA clock
   1638            *            @arg RCC_AHB1Periph_GPIOB:   GPIOB clock 
   1639            *            @arg RCC_AHB1Periph_GPIOC:   GPIOC clock
   1640            *            @arg RCC_AHB1Periph_GPIOD:   GPIOD clock
   1641            *            @arg RCC_AHB1Periph_GPIOE:   GPIOE clock
   1642            *            @arg RCC_AHB1Periph_GPIOF:   GPIOF clock
   1643            *            @arg RCC_AHB1Periph_GPIOG:   GPIOG clock
   1644            *            @arg RCC_AHB1Periph_GPIOG:   GPIOG clock
   1645            *            @arg RCC_AHB1Periph_GPIOI:   GPIOI clock
   1646            *            @arg RCC_AHB1Periph_GPIOJ:   GPIOJ clock (STM32F42xxx/43xxx devices) 
   1647            *            @arg RCC_AHB1Periph_GPIOK:   GPIOK clock (STM32F42xxx/43xxxdevices)   
   1648            *            @arg RCC_AHB1Periph_CRC:     CRC clock
   1649            *            @arg RCC_AHB1Periph_DMA1:    DMA1 clock
   1650            *            @arg RCC_AHB1Periph_DMA2:    DMA2 clock
   1651            *            @arg RCC_AHB1Periph_DMA2D:   DMA2D clock (STM32F429xx/439xx devices)   
   1652            *            @arg RCC_AHB1Periph_ETH_MAC: Ethernet MAC clock
   1653            *            @arg RCC_AHB1Periph_OTG_HS:  USB OTG HS clock
   1654            *                  
   1655            * @param  NewState: new state of the specified peripheral reset.
   1656            *          This parameter can be: ENABLE or DISABLE.
   1657            * @retval None
   1658            */
   1659          void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1660          {
   1661            /* Check the parameters */
   1662            assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
   1663            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1664          
   1665            if (NewState != DISABLE)
   1666            {
   1667              RCC->AHB1RSTR |= RCC_AHB1Periph;
   1668            }
   1669            else
   1670            {
   1671              RCC->AHB1RSTR &= ~RCC_AHB1Periph;
   1672            }
   1673          }
   1674          
   1675          /**
   1676            * @brief  Forces or releases AHB2 peripheral reset.
   1677            * @param  RCC_AHB2Periph: specifies the AHB2 peripheral to reset.
   1678            *          This parameter can be any combination of the following values:
   1679            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
   1680            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
   1681            *            @arg RCC_AHB2Periph_HASH:   HASH clock
   1682            *            @arg RCC_AHB2Periph_RNG:    RNG clock
   1683            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
   1684            * @param  NewState: new state of the specified peripheral reset.
   1685            *          This parameter can be: ENABLE or DISABLE.
   1686            * @retval None
   1687            */
   1688          void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1689          {
   1690            /* Check the parameters */
   1691            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   1692            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1693          
   1694            if (NewState != DISABLE)
   1695            {
   1696              RCC->AHB2RSTR |= RCC_AHB2Periph;
   1697            }
   1698            else
   1699            {
   1700              RCC->AHB2RSTR &= ~RCC_AHB2Periph;
   1701            }
   1702          }
   1703          
   1704          /**
   1705            * @brief  Forces or releases AHB3 peripheral reset.
   1706            * @param  RCC_AHB3Periph: specifies the AHB3 peripheral to reset.
   1707            *          This parameter must be: RCC_AHB3Periph_FSMC
   1708            *                                  or RCC_AHB3Periph_FMC (STM32F42xxx/43xxx devices)  
   1709            * @param  NewState: new state of the specified peripheral reset.
   1710            *          This parameter can be: ENABLE or DISABLE.
   1711            * @retval None
   1712            */
   1713          void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1714          {
   1715            /* Check the parameters */
   1716            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
   1717            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1718          
   1719            if (NewState != DISABLE)
   1720            {
   1721              RCC->AHB3RSTR |= RCC_AHB3Periph;
   1722            }
   1723            else
   1724            {
   1725              RCC->AHB3RSTR &= ~RCC_AHB3Periph;
   1726            }
   1727          }
   1728          
   1729          /**
   1730            * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
   1731            * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
   1732            *          This parameter can be any combination of the following values:
   1733            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
   1734            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
   1735            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
   1736            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
   1737            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
   1738            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
   1739            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
   1740            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
   1741            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
   1742            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
   1743            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
   1744            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
   1745            *            @arg RCC_APB1Periph_USART2: USART2 clock
   1746            *            @arg RCC_APB1Periph_USART3: USART3 clock
   1747            *            @arg RCC_APB1Periph_UART4:  UART4 clock
   1748            *            @arg RCC_APB1Periph_UART5:  UART5 clock
   1749            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
   1750            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
   1751            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
   1752            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
   1753            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
   1754            *            @arg RCC_APB1Periph_PWR:    PWR clock
   1755            *            @arg RCC_APB1Periph_DAC:    DAC clock
   1756            *            @arg RCC_APB1Periph_UART7:  UART7 clock
   1757            *            @arg RCC_APB1Periph_UART8:  UART8 clock  
   1758            * @param  NewState: new state of the specified peripheral reset.
   1759            *          This parameter can be: ENABLE or DISABLE.
   1760            * @retval None
   1761            */
   1762          void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1763          {
   1764            /* Check the parameters */
   1765            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   1766            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1767            if (NewState != DISABLE)
   1768            {
   1769              RCC->APB1RSTR |= RCC_APB1Periph;
   1770            }
   1771            else
   1772            {
   1773              RCC->APB1RSTR &= ~RCC_APB1Periph;
   1774            }
   1775          }
   1776          
   1777          /**
   1778            * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
   1779            * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
   1780            *          This parameter can be any combination of the following values:
   1781            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
   1782            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
   1783            *            @arg RCC_APB2Periph_USART1: USART1 clock
   1784            *            @arg RCC_APB2Periph_USART6: USART6 clock
   1785            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
   1786            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
   1787            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
   1788            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
   1789            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
   1790            *            @arg RCC_APB2Periph_SPI4:   SPI4 clock  
   1791            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
   1792            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
   1793            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
   1794            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
   1795            *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
   1796            *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
   1797            *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
   1798            *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices)   
   1799            * @param  NewState: new state of the specified peripheral reset.
   1800            *          This parameter can be: ENABLE or DISABLE.
   1801            * @retval None
   1802            */
   1803          void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1804          {
   1805            /* Check the parameters */
   1806            assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
   1807            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1808            if (NewState != DISABLE)
   1809            {
   1810              RCC->APB2RSTR |= RCC_APB2Periph;
   1811            }
   1812            else
   1813            {
   1814              RCC->APB2RSTR &= ~RCC_APB2Periph;
   1815            }
   1816          }
   1817          
   1818          /**
   1819            * @brief  Enables or disables the AHB1 peripheral clock during Low Power (Sleep) mode.
   1820            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1821            *         power consumption.
   1822            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1823            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1824            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
   1825            *          This parameter can be any combination of the following values:
   1826            *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
   1827            *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
   1828            *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
   1829            *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
   1830            *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
   1831            *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
   1832            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1833            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1834            *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
   1835            *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
   1836            *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)   
   1837            *            @arg RCC_AHB1Periph_CRC:         CRC clock
   1838            *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
   1839            *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
   1840            *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
   1841            *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices) 
   1842            *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
   1843            *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
   1844            *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
   1845            *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
   1846            *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
   1847            *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
   1848            * @param  NewState: new state of the specified peripheral clock.
   1849            *          This parameter can be: ENABLE or DISABLE.
   1850            * @retval None
   1851            */
   1852          void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1853          {
   1854            /* Check the parameters */
   1855            assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
   1856            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1857            if (NewState != DISABLE)
   1858            {
   1859              RCC->AHB1LPENR |= RCC_AHB1Periph;
   1860            }
   1861            else
   1862            {
   1863              RCC->AHB1LPENR &= ~RCC_AHB1Periph;
   1864            }
   1865          }
   1866          
   1867          /**
   1868            * @brief  Enables or disables the AHB2 peripheral clock during Low Power (Sleep) mode.
   1869            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1870            *           power consumption.
   1871            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1872            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1873            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
   1874            *          This parameter can be any combination of the following values:
   1875            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
   1876            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
   1877            *            @arg RCC_AHB2Periph_HASH:   HASH clock
   1878            *            @arg RCC_AHB2Periph_RNG:    RNG clock
   1879            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock  
   1880            * @param  NewState: new state of the specified peripheral clock.
   1881            *          This parameter can be: ENABLE or DISABLE.
   1882            * @retval None
   1883            */
   1884          void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1885          {
   1886            /* Check the parameters */
   1887            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   1888            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1889            if (NewState != DISABLE)
   1890            {
   1891              RCC->AHB2LPENR |= RCC_AHB2Periph;
   1892            }
   1893            else
   1894            {
   1895              RCC->AHB2LPENR &= ~RCC_AHB2Periph;
   1896            }
   1897          }
   1898          
   1899          /**
   1900            * @brief  Enables or disables the AHB3 peripheral clock during Low Power (Sleep) mode.
   1901            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1902            *         power consumption.
   1903            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1904            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1905            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
   1906            *          This parameter must be: RCC_AHB3Periph_FSMC
   1907            *                                  or RCC_AHB3Periph_FMC (STM32F429x/439x devices) 
   1908            * @param  NewState: new state of the specified peripheral clock.
   1909            *          This parameter can be: ENABLE or DISABLE.
   1910            * @retval None
   1911            */
   1912          void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1913          {
   1914            /* Check the parameters */
   1915            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
   1916            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1917            if (NewState != DISABLE)
   1918            {
   1919              RCC->AHB3LPENR |= RCC_AHB3Periph;
   1920            }
   1921            else
   1922            {
   1923              RCC->AHB3LPENR &= ~RCC_AHB3Periph;
   1924            }
   1925          }
   1926          
   1927          /**
   1928            * @brief  Enables or disables the APB1 peripheral clock during Low Power (Sleep) mode.
   1929            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1930            *         power consumption.
   1931            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1932            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1933            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1934            *          This parameter can be any combination of the following values:
   1935            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
   1936            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
   1937            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
   1938            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
   1939            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
   1940            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
   1941            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
   1942            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
   1943            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
   1944            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
   1945            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
   1946            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
   1947            *            @arg RCC_APB1Periph_USART2: USART2 clock
   1948            *            @arg RCC_APB1Periph_USART3: USART3 clock
   1949            *            @arg RCC_APB1Periph_UART4:  UART4 clock
   1950            *            @arg RCC_APB1Periph_UART5:  UART5 clock
   1951            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
   1952            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
   1953            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
   1954            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
   1955            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
   1956            *            @arg RCC_APB1Periph_PWR:    PWR clock
   1957            *            @arg RCC_APB1Periph_DAC:    DAC clock
   1958            *            @arg RCC_APB1Periph_UART7:  UART7 clock
   1959            *            @arg RCC_APB1Periph_UART8:  UART8 clock
   1960            * @param  NewState: new state of the specified peripheral clock.
   1961            *          This parameter can be: ENABLE or DISABLE.
   1962            * @retval None
   1963            */
   1964          void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1965          {
   1966            /* Check the parameters */
   1967            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   1968            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1969            if (NewState != DISABLE)
   1970            {
   1971              RCC->APB1LPENR |= RCC_APB1Periph;
   1972            }
   1973            else
   1974            {
   1975              RCC->APB1LPENR &= ~RCC_APB1Periph;
   1976            }
   1977          }
   1978          
   1979          /**
   1980            * @brief  Enables or disables the APB2 peripheral clock during Low Power (Sleep) mode.
   1981            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1982            *         power consumption.
   1983            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1984            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1985            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1986            *          This parameter can be any combination of the following values:
   1987            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
   1988            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
   1989            *            @arg RCC_APB2Periph_USART1: USART1 clock
   1990            *            @arg RCC_APB2Periph_USART6: USART6 clock
   1991            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
   1992            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
   1993            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
   1994            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
   1995            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
   1996            *            @arg RCC_APB2Periph_SPI4:   SPI4 clock
   1997            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
   1998            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
   1999            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
   2000            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
   2001            *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
   2002            *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
   2003            *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
   2004            *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices)   
   2005            * @param  NewState: new state of the specified peripheral clock.
   2006            *          This parameter can be: ENABLE or DISABLE.
   2007            * @retval None
   2008            */
   2009          void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   2010          {
   2011            /* Check the parameters */
   2012            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   2013            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2014            if (NewState != DISABLE)
   2015            {
   2016              RCC->APB2LPENR |= RCC_APB2Periph;
   2017            }
   2018            else
   2019            {
   2020              RCC->APB2LPENR &= ~RCC_APB2Periph;
   2021            }
   2022          }
   2023          
   2024          /**
   2025            * @}
   2026            */
   2027          
   2028          /** @defgroup RCC_Group4 Interrupts and flags management functions
   2029           *  @brief   Interrupts and flags management functions 
   2030           *
   2031          @verbatim   
   2032           ===============================================================================
   2033                          ##### Interrupts and flags management functions #####
   2034           ===============================================================================  
   2035          
   2036          @endverbatim
   2037            * @{
   2038            */
   2039          
   2040          /**
   2041            * @brief  Enables or disables the specified RCC interrupts.
   2042            * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
   2043            *          This parameter can be any combination of the following values:
   2044            *            @arg RCC_IT_LSIRDY: LSI ready interrupt
   2045            *            @arg RCC_IT_LSERDY: LSE ready interrupt
   2046            *            @arg RCC_IT_HSIRDY: HSI ready interrupt
   2047            *            @arg RCC_IT_HSERDY: HSE ready interrupt
   2048            *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
   2049            *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt
   2050            *            @arg RCC_IT_PLLSAIRDY: PLLSAI ready interrupt (only for STM32F42xxx/43xxx devices)
   2051            * @param  NewState: new state of the specified RCC interrupts.
   2052            *          This parameter can be: ENABLE or DISABLE.
   2053            * @retval None
   2054            */
   2055          void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
   2056          {
   2057            /* Check the parameters */
   2058            assert_param(IS_RCC_IT(RCC_IT));
   2059            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2060            if (NewState != DISABLE)
   2061            {
   2062              /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
   2063              *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
   2064            }
   2065            else
   2066            {
   2067              /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
   2068              *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
   2069            }
   2070          }
   2071          
   2072          /**
   2073            * @brief  Checks whether the specified RCC flag is set or not.
   2074            * @param  RCC_FLAG: specifies the flag to check.
   2075            *          This parameter can be one of the following values:
   2076            *            @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
   2077            *            @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   2078            *            @arg RCC_FLAG_PLLRDY: main PLL clock ready
   2079            *            @arg RCC_FLAG_PLLI2SRDY: PLLI2S clock ready
   2080            *            @arg RCC_FLAG_PLLSAIRDY: PLLSAI clock ready (only for STM32F42xxx/43xxx devices)
   2081            *            @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   2082            *            @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   2083            *            @arg RCC_FLAG_BORRST: POR/PDR or BOR reset
   2084            *            @arg RCC_FLAG_PINRST: Pin reset
   2085            *            @arg RCC_FLAG_PORRST: POR/PDR reset
   2086            *            @arg RCC_FLAG_SFTRST: Software reset
   2087            *            @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   2088            *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   2089            *            @arg RCC_FLAG_LPWRRST: Low Power reset
   2090            * @retval The new state of RCC_FLAG (SET or RESET).
   2091            */
   2092          FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
   2093          {
   2094            uint32_t tmp = 0;
   2095            uint32_t statusreg = 0;
   2096            FlagStatus bitstatus = RESET;
   2097          
   2098            /* Check the parameters */
   2099            assert_param(IS_RCC_FLAG(RCC_FLAG));
   2100          
   2101            /* Get the RCC register index */
   2102            tmp = RCC_FLAG >> 5;
   2103            if (tmp == 1)               /* The flag to check is in CR register */
   2104            {
   2105              statusreg = RCC->CR;
   2106            }
   2107            else if (tmp == 2)          /* The flag to check is in BDCR register */
   2108            {
   2109              statusreg = RCC->BDCR;
   2110            }
   2111            else                       /* The flag to check is in CSR register */
   2112            {
   2113              statusreg = RCC->CSR;
   2114            }
   2115          
   2116            /* Get the flag position */
   2117            tmp = RCC_FLAG & FLAG_MASK;
   2118            if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
   2119            {
   2120              bitstatus = SET;
   2121            }
   2122            else
   2123            {
   2124              bitstatus = RESET;
   2125            }
   2126            /* Return the flag status */
   2127            return bitstatus;
   2128          }
   2129          
   2130          /**
   2131            * @brief  Clears the RCC reset flags.
   2132            *         The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST,  RCC_FLAG_SFTRST,
   2133            *         RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
   2134            * @param  None
   2135            * @retval None
   2136            */
   2137          void RCC_ClearFlag(void)
   2138          {
   2139            /* Set RMVF bit to clear the reset flags */
   2140            RCC->CSR |= RCC_CSR_RMVF;
   2141          }
   2142          
   2143          /**
   2144            * @brief  Checks whether the specified RCC interrupt has occurred or not.
   2145            * @param  RCC_IT: specifies the RCC interrupt source to check.
   2146            *          This parameter can be one of the following values:
   2147            *            @arg RCC_IT_LSIRDY: LSI ready interrupt
   2148            *            @arg RCC_IT_LSERDY: LSE ready interrupt
   2149            *            @arg RCC_IT_HSIRDY: HSI ready interrupt
   2150            *            @arg RCC_IT_HSERDY: HSE ready interrupt
   2151            *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
   2152            *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt           
   2153            *            @arg RCC_IT_PLLSAIRDY: PLLSAI clock ready interrupt (only for STM32F42xxx/43xxx devices)    
   2154            *            @arg RCC_IT_CSS: Clock Security System interrupt
   2155            * @retval The new state of RCC_IT (SET or RESET).
   2156            */
   2157          ITStatus RCC_GetITStatus(uint8_t RCC_IT)
   2158          {
   2159            ITStatus bitstatus = RESET;
   2160          
   2161            /* Check the parameters */
   2162            assert_param(IS_RCC_GET_IT(RCC_IT));
   2163          
   2164            /* Check the status of the specified RCC interrupt */
   2165            if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
   2166            {
   2167              bitstatus = SET;
   2168            }
   2169            else
   2170            {
   2171              bitstatus = RESET;
   2172            }
   2173            /* Return the RCC_IT status */
   2174            return  bitstatus;
   2175          }
   2176          
   2177          /**
   2178            * @brief  Clears the RCC's interrupt pending bits.
   2179            * @param  RCC_IT: specifies the interrupt pending bit to clear.
   2180            *          This parameter can be any combination of the following values:
   2181            *            @arg RCC_IT_LSIRDY: LSI ready interrupt
   2182            *            @arg RCC_IT_LSERDY: LSE ready interrupt
   2183            *            @arg RCC_IT_HSIRDY: HSI ready interrupt
   2184            *            @arg RCC_IT_HSERDY: HSE ready interrupt
   2185            *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
   2186            *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
   2187            *            @arg RCC_IT_PLLSAIRDY: PLLSAI ready interrupt (only for STM32F42xxx/43xxx devices)   
   2188            *            @arg RCC_IT_CSS: Clock Security System interrupt
   2189            * @retval None
   2190            */
   2191          void RCC_ClearITPendingBit(uint8_t RCC_IT)
   2192          {
   2193            /* Check the parameters */
   2194            assert_param(IS_RCC_CLEAR_IT(RCC_IT));
   2195          
   2196            /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
   2197               pending bits */
   2198            *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
   2199          }
   2200          
   2201          /**
   2202            * @}
   2203            */ 
   2204          
   2205          /**
   2206            * @}
   2207            */ 
   2208          
   2209          /**
   2210            * @}
   2211            */ 
   2212          
   2213          /**
   2214            * @}
   2215            */ 
   2216          
   2217          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  RCC_AHB1PeriphClockCmd
        0  RCC_AHB1PeriphClockLPModeCmd
        0  RCC_AHB1PeriphResetCmd
        0  RCC_AHB2PeriphClockCmd
        0  RCC_AHB2PeriphClockLPModeCmd
        0  RCC_AHB2PeriphResetCmd
        0  RCC_AHB3PeriphClockCmd
        0  RCC_AHB3PeriphClockLPModeCmd
        0  RCC_AHB3PeriphResetCmd
        0  RCC_APB1PeriphClockCmd
        0  RCC_APB1PeriphClockLPModeCmd
        0  RCC_APB1PeriphResetCmd
        0  RCC_APB2PeriphClockCmd
        0  RCC_APB2PeriphClockLPModeCmd
        0  RCC_APB2PeriphResetCmd
        0  RCC_AdjustHSICalibrationValue
        0  RCC_BackupResetCmd
        0  RCC_ClearFlag
        0  RCC_ClearITPendingBit
        0  RCC_ClockSecuritySystemCmd
        0  RCC_DeInit
       12  RCC_GetClocksFreq
        0  RCC_GetFlagStatus
        0  RCC_GetITStatus
        0  RCC_GetSYSCLKSource
        0  RCC_HCLKConfig
        0  RCC_HSEConfig
        0  RCC_HSICmd
        0  RCC_I2SCLKConfig
        0  RCC_ITConfig
        0  RCC_LSEConfig
        0  RCC_LSICmd
        0  RCC_LTDCCLKDivConfig
        0  RCC_MCO1Config
        0  RCC_MCO2Config
        0  RCC_PCLK1Config
        0  RCC_PCLK2Config
        0  RCC_PLLCmd
        8  RCC_PLLConfig
        0  RCC_PLLI2SCmd
        0  RCC_PLLI2SConfig
        0  RCC_PLLSAICmd
        0  RCC_PLLSAIConfig
        0  RCC_RTCCLKCmd
        0  RCC_RTCCLKConfig
        0  RCC_SAIBlockACLKConfig
        0  RCC_SAIBlockBCLKConfig
        0  RCC_SAIPLLI2SClkDivConfig
        0  RCC_SAIPLLSAIClkDivConfig
        0  RCC_SYSCLKConfig
        0  RCC_TIMCLKPresConfig
       16  RCC_WaitForHSEStartUp
             16 -> RCC_GetFlagStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable47
       4  ??DataTable47_1
       4  ??DataTable47_10
       4  ??DataTable47_11
       4  ??DataTable47_12
       4  ??DataTable47_13
       4  ??DataTable47_14
       4  ??DataTable47_15
       4  ??DataTable47_16
       4  ??DataTable47_17
       4  ??DataTable47_18
       4  ??DataTable47_19
       4  ??DataTable47_2
       4  ??DataTable47_20
       4  ??DataTable47_21
       4  ??DataTable47_22
       4  ??DataTable47_23
       4  ??DataTable47_24
       4  ??DataTable47_25
       4  ??DataTable47_26
       4  ??DataTable47_27
       4  ??DataTable47_28
       4  ??DataTable47_29
       4  ??DataTable47_3
       4  ??DataTable47_30
       4  ??DataTable47_31
       4  ??DataTable47_32
       4  ??DataTable47_33
       4  ??DataTable47_34
       4  ??DataTable47_35
       4  ??DataTable47_36
       4  ??DataTable47_37
       4  ??DataTable47_38
       4  ??DataTable47_39
       4  ??DataTable47_4
       4  ??DataTable47_40
       4  ??DataTable47_41
       4  ??DataTable47_42
       4  ??DataTable47_43
       4  ??DataTable47_44
       4  ??DataTable47_5
       4  ??DataTable47_6
       4  ??DataTable47_7
       4  ??DataTable47_8
       4  ??DataTable47_9
       8  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
      16  APBAHBPrescTable
      18  RCC_AHB1PeriphClockCmd
      18  RCC_AHB1PeriphClockLPModeCmd
      18  RCC_AHB1PeriphResetCmd
      18  RCC_AHB2PeriphClockCmd
      18  RCC_AHB2PeriphClockLPModeCmd
      18  RCC_AHB2PeriphResetCmd
      18  RCC_AHB3PeriphClockCmd
      18  RCC_AHB3PeriphClockLPModeCmd
      18  RCC_AHB3PeriphResetCmd
      18  RCC_APB1PeriphClockCmd
      18  RCC_APB1PeriphClockLPModeCmd
      18  RCC_APB1PeriphResetCmd
      18  RCC_APB2PeriphClockCmd
      18  RCC_APB2PeriphClockLPModeCmd
      18  RCC_APB2PeriphResetCmd
      12  RCC_AdjustHSICalibrationValue
       6  RCC_BackupResetCmd
      12  RCC_ClearFlag
       6  RCC_ClearITPendingBit
       6  RCC_ClockSecuritySystemCmd
      64  RCC_DeInit
     124  RCC_GetClocksFreq
      42  RCC_GetFlagStatus
      18  RCC_GetITStatus
      10  RCC_GetSYSCLKSource
      10  RCC_HCLKConfig
      12  RCC_HSEConfig
       8  RCC_HSICmd
       6  RCC_I2SCLKConfig
      18  RCC_ITConfig
      24  RCC_LSEConfig
       6  RCC_LSICmd
      10  RCC_LTDCCLKDivConfig
      12  RCC_MCO1Config
      10  RCC_MCO2Config
       8  RCC_PCLK1Config
       8  RCC_PCLK2Config
       6  RCC_PLLCmd
      30  RCC_PLLConfig
       6  RCC_PLLI2SCmd
      12  RCC_PLLI2SConfig
       6  RCC_PLLSAICmd
      16  RCC_PLLSAIConfig
       6  RCC_RTCCLKCmd
      42  RCC_RTCCLKConfig
      10  RCC_SAIBlockACLKConfig
      10  RCC_SAIBlockBCLKConfig
      16  RCC_SAIPLLI2SClkDivConfig
      18  RCC_SAIPLLSAIClkDivConfig
      14  RCC_SYSCLKConfig
       6  RCC_TIMCLKPresConfig
      48  RCC_WaitForHSEStartUp

 
    16 bytes in section .data
 1 148 bytes in section .text
 
 1 148 bytes of CODE memory
    16 bytes of DATA memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     10/Nov/2014  15:19:44 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\STM32_USB_HOST_Library\Class\MSC\src\usbh_m #
#                    sc_fatfs.c                                               #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\STM32_USB_HOST_Library\Class\MSC\src\usbh_m #
#                    sc_fatfs.c -D __ARM_CORTEX_MX__ -D DEBUG -D FREE_RTOS    #
#                    -D STM32F40_41xxx -D USE_STM324xG_EVAL -D                #
#                    USE_STDPERIPH_DRIVER -D HOST_MODE_ENABLED -D             #
#                    IAR_ARM_CM4F -D USE_USB_OTG_FS -D STM32_IAP -D S4051A    #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Bootloade #
#                    r\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Boo #
#                    tloader\Obj\ --debug --endian=little --cpu=Cortex-M4 -e  #
#                    --fpu=VFPv4_sp --dlib_config "C:\Program Files           #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Projects\STM32_IAP\inc #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\I #
#                    nclude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\C #
#                    MSIS\Device\ST\STM32F4xx\Include\ -I                     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_HO #
#                    ST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\HT68F30\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Utilities\Third_Party\efsl\inc\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    fat_fs\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Project #
#                    s\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utiliti #
#                    es\mainstream_v1\stm32f411\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\it\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\APP_SRC\I #
#                    nclude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\APP_SRC\ -Ohz -I  #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Bootloader\Lis #
#                    t\usbh_msc_fatfs.lst                                     #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Bootloader\Obj #
#                    \usbh_msc_fatfs.o                                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Libraries\STM32_USB_HOST_Library\Class\MSC\src\usbh_msc_fatfs.c
      1          
      2          #include "usb_conf.h"
      3          #include "diskio.h"
      4          #include "usbh_msc_core.h"
      5          /*--------------------------------------------------------------------------
      6          
      7          Module Private Functions and Variables
      8          
      9          ---------------------------------------------------------------------------*/
     10          
     11          static volatile DSTATUS Stat = STA_NOINIT;	/* Disk status */
     12          
     13          extern USB_OTG_CORE_HANDLE          USB_OTG_Core;
     14          extern USBH_HOST                     USB_Host;
     15          
     16          /*-----------------------------------------------------------------------*/
     17          /* Initialize Disk Drive                                                 */
     18          /*-----------------------------------------------------------------------*/
     19          
     20          DSTATUS disk_initialize (
     21                                   BYTE drv		/* Physical drive number (0) */
     22                                     )
     23          {
     24            
     25            if(HCD_IsDeviceConnected(&USB_OTG_Core))
     26            {  
     27              Stat &= ~STA_NOINIT;
     28            }
     29            
     30            return Stat;
     31            
     32            
     33          }
     34          
     35          
     36          
     37          /*-----------------------------------------------------------------------*/
     38          /* Get Disk Status                                                       */
     39          /*-----------------------------------------------------------------------*/
     40          
     41          DSTATUS disk_status (
     42                               BYTE drv		/* Physical drive number (0) */
     43                                 )
     44          {
     45            if (drv) return STA_NOINIT;		/* Supports only single drive */
     46            return Stat;
     47          }
     48          
     49          
     50          
     51          /*-----------------------------------------------------------------------*/
     52          /* Read Sector(s)                                                        */
     53          /*-----------------------------------------------------------------------*/
     54          
     55          DRESULT disk_read (
     56                             BYTE drv,			/* Physical drive number (0) */
     57                             BYTE *buff,			/* Pointer to the data buffer to store read data */
     58                             DWORD sector,		/* Start sector number (LBA) */
     59                             BYTE count			/* Sector count (1..255) */
     60                               )
     61          {
     62            BYTE status = USBH_MSC_OK;
     63            
     64            if (drv || !count) return RES_PARERR;
     65            if (Stat & STA_NOINIT) return RES_NOTRDY;
     66            
     67            
     68            if(HCD_IsDeviceConnected(&USB_OTG_Core))
     69            {  
     70              
     71              do
     72              {
     73                status = USBH_MSC_Read10(&USB_OTG_Core, buff,sector,512 * count);
     74                USBH_MSC_HandleBOTXfer(&USB_OTG_Core ,&USB_Host);
     75                
     76                if(!HCD_IsDeviceConnected(&USB_OTG_Core))
     77                { 
     78                  return RES_ERROR;
     79                }      
     80              }
     81              while(status == USBH_MSC_BUSY );
     82            }
     83            
     84            if(status == USBH_MSC_OK)
     85              return RES_OK;
     86            return RES_ERROR;
     87            
     88          }
     89          
     90          
     91          
     92          /*-----------------------------------------------------------------------*/
     93          /* Write Sector(s)                                                       */
     94          /*-----------------------------------------------------------------------*/
     95          
     96          #if _READONLY == 0
     97          DRESULT disk_write (
     98                              BYTE drv,			/* Physical drive number (0) */
     99                              const BYTE *buff,	/* Pointer to the data to be written */
    100                              DWORD sector,		/* Start sector number (LBA) */
    101                              BYTE count			/* Sector count (1..255) */
    102                                )
    103          {
    104            BYTE status = USBH_MSC_OK;
    105            if (drv || !count) return RES_PARERR;
    106            if (Stat & STA_NOINIT) return RES_NOTRDY;
    107            if (Stat & STA_PROTECT) return RES_WRPRT;
    108            
    109            
    110            if(HCD_IsDeviceConnected(&USB_OTG_Core))
    111            {  
    112              do
    113              {
    114                status = USBH_MSC_Write10(&USB_OTG_Core,(BYTE*)buff,sector,512 * count);
    115                USBH_MSC_HandleBOTXfer(&USB_OTG_Core, &USB_Host);
    116                
    117                if(!HCD_IsDeviceConnected(&USB_OTG_Core))
    118                { 
    119                  return RES_ERROR;
    120                }
    121              }
    122              
    123              while(status == USBH_MSC_BUSY );
    124              
    125            }
    126            
    127            if(status == USBH_MSC_OK)
    128              return RES_OK;
    129            return RES_ERROR;
    130          }
    131          #endif /* _READONLY == 0 */
    132          
    133          
    134          
    135          /*-----------------------------------------------------------------------*/
    136          /* Miscellaneous Functions                                               */
    137          /*-----------------------------------------------------------------------*/
    138          
    139          #if _USE_IOCTL != 0
    140          DRESULT disk_ioctl (
    141                              BYTE drv,		/* Physical drive number (0) */
    142                              BYTE ctrl,		/* Control code */
    143                              void *buff		/* Buffer to send/receive control data */
    144                                )
    145          {
    146            DRESULT res = RES_OK;
    147            
    148            if (drv) return RES_PARERR;
    149            
    150            res = RES_ERROR;
    151            
    152            if (Stat & STA_NOINIT) return RES_NOTRDY;
    153            
    154            switch (ctrl) {
    155            case CTRL_SYNC :		/* Make sure that no pending write process */
    156              
    157              res = RES_OK;
    158              break;
    159              
    160            case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
    161              
    162              *(DWORD*)buff = (DWORD) USBH_MSC_Param.MSCapacity;
    163              res = RES_OK;
    164              break;
    165              
    166            case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
    167              *(WORD*)buff = 512;
    168              res = RES_OK;
    169              break;
    170              
    171            case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
    172              
    173              *(DWORD*)buff = 512;
    174              
    175              break;
    176              
    177              
    178            default:
    179              res = RES_PARERR;
    180            }
    181            
    182            
    183            
    184            return res;
    185          }
    186          #endif /* _USE_IOCTL != 0 */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  disk_initialize
              8 -> HCD_IsDeviceConnected
        0  disk_ioctl
       24  disk_read
             24 -> HCD_IsDeviceConnected
             24 -> USBH_MSC_HandleBOTXfer
             24 -> USBH_MSC_Read10
        0  disk_status
       24  disk_write
             24 -> HCD_IsDeviceConnected
             24 -> USBH_MSC_HandleBOTXfer
             24 -> USBH_MSC_Write10


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
      10  ?Subroutine0
      10  ?Subroutine1
       1  Stat
      24  disk_initialize
      56  disk_ioctl
      76  disk_read
      12  disk_status
      86  disk_write

 
   1 byte  in section .data
 290 bytes in section .text
 
 290 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     10/Nov/2014  15:19:33 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Utilities\Third_Party\efsl\src\partition.c            #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Utilities\Third_Party\efsl\src\partition.c -D         #
#                    __ARM_CORTEX_MX__ -D DEBUG -D FREE_RTOS -D               #
#                    STM32F40_41xxx -D USE_STM324xG_EVAL -D                   #
#                    USE_STDPERIPH_DRIVER -D HOST_MODE_ENABLED -D             #
#                    IAR_ARM_CM4F -D USE_USB_OTG_FS -D STM32_IAP -D S4051A    #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Bootloade #
#                    r\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Boo #
#                    tloader\Obj\ --debug --endian=little --cpu=Cortex-M4 -e  #
#                    --fpu=VFPv4_sp --dlib_config "C:\Program Files           #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Projects\STM32_IAP\inc #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\I #
#                    nclude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\C #
#                    MSIS\Device\ST\STM32F4xx\Include\ -I                     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_HO #
#                    ST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\HT68F30\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Utilities\Third_Party\efsl\inc\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    fat_fs\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Project #
#                    s\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utiliti #
#                    es\mainstream_v1\stm32f411\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\it\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\APP_SRC\I #
#                    nclude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\APP_SRC\ -Ohz -I  #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Bootloader\Lis #
#                    t\partition.lst                                          #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Bootloader\Obj #
#                    \partition.o                                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Utilities\Third_Party\efsl\src\partition.c
      1          
      2          /*****************************************************************************\
      3          *              efs - General purpose Embedded Filesystem library              *
      4          *          --------------------- -----------------------------------          *
      5          *                                                                             *
      6          * Filename : partition.c                                                      *
      7          * Description : These functions are partition specific. Searching FAT type    *
      8          *               partitions and read/write functions to partitions.            *
      9          *                                                                             *
     10          * This program is free software; you can redistribute it and/or               *
     11          * modify it under the terms of the GNU General Public License                 *
     12          * as published by the Free Software Foundation; version 2                     *
     13          * of the License.                                                             *
     14                                                                                        *
     15          * This program is distributed in the hope that it will be useful,             *
     16          * but WITHOUT ANY WARRANTY; without even the implied warranty of              *
     17          * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               *
     18          * GNU General Public License for more details.                                *
     19          *                                                                             *
     20          * As a special exception, if other files instantiate templates or             *
     21          * use macros or inline functions from this file, or you compile this          *
     22          * file and link it with other works to produce a work based on this file,     *
     23          * this file does not by itself cause the resulting work to be covered         *
     24          * by the GNU General Public License. However the source code for this         *
     25          * file must still be made available in accordance with section (3) of         *
     26          * the GNU General Public License.                                             *
     27          *                                                                             *
     28          * This exception does not invalidate any other reasons why a work based       *
     29          * on this file might be covered by the GNU General Public License.            *
     30          *                                                                             *
     31          *                                                    (c)2006 Lennart Yseboodt *
     32          *                                                    (c)2006 Michael De Nil   *
     33          \*****************************************************************************/
     34          
     35          /*****************************************************************************/
     36          
     37          #include "partition.h"
     38          /*****************************************************************************/
     39          
     40          /* ****************************************************************************  
     41           * void part_initPartition(Partition *part,Disc* refDisc)
     42           * Description: This function searches the 4 partitions for a FAT class partition
     43           * and marks the first one found as the active to be used partition.
     44          */
     45          void part_initPartition(Partition *part,Disc* refDisc)
     46          {
     47          	eint16 c;
     48          	
     49          	part->disc=refDisc;
     50          	part->activePartition=-1; /* No partition selected */
     51          	part_setError(part,PART_NOERROR);
     52          	for(c=3;c>=0;c--){
     53          		if(part_isFatPart(part->disc->partitions[c].type))
     54          			part->activePartition=c;
     55          	} 
     56          }
     57          /*****************************************************************************/ 
     58          
     59          
     60          /* ****************************************************************************  
     61           * eint16 part_isFatPart(euint8 type)
     62           * Description: This functions checks if a partitiontype (eint8) is of the FAT
     63           * type in the broadest sense. I
     64           * Return value: If it is FAT, returns 1, otherwise 0.
     65          */
     66          eint16 part_isFatPart(euint8 type)
     67          {
     68          	if(type == PT_FAT12  ||
     69          	   type == PT_FAT16A ||
     70          	   type == PT_FAT16  ||
     71          	   type == PT_FAT32  ||
     72          	   type == PT_FAT32A ||
     73          	   type == PT_FAT16B   )
     74          	{
     75          		return(1);
     76          	}
     77          	return(0);
     78          }
     79          /*****************************************************************************/ 
     80          
     81          esint8 part_readBuf(Partition *part, euint32 address, euint8* buf)
     82          {
     83          	return(if_readBuf(part->disc->ioman->iface,part_getRealLBA(part,address), buf));
     84          }
     85          
     86          /* ****************************************************************************  
     87           * eint16 part_writeBuf(Partition *part,euint32 address,euint8* buf)
     88           * Description: This function writes 512 bytes, from buf. It's offset is address
     89           * sectors from the beginning of the partition.
     90           * Return value: It returns whatever the hardware function returns. (-1=error)
     91          */
     92          eint16 part_writeBuf(Partition *part,euint32 address,euint8* buf)
     93          {
     94          	/*DBG((TXT("part_writeBuf :: %li\n"),address));*/
     95          	return(if_writeBuf(part->disc->ioman->iface,part_getRealLBA(part,address),buf));
     96          }
     97          /*****************************************************************************/ 
     98          
     99          
    100          /* ****************************************************************************  
    101           * euint32 part_getRealLBA(Partition *part,euint32 address)
    102           * Description: This function calculates what the partition offset for
    103           * a partition is + the address.
    104           * Return value: Sector address.
    105          */
    106          euint32 part_getRealLBA(Partition *part,euint32 address)
    107          {
    108          	return(part->disc->partitions[part->activePartition].LBA_begin+address);
    109          }
    110          /*****************************************************************************/ 
    111          
    112          /* ****************************************************************************  
    113           * euint8* part_getSect(Partition *part, euint32 address, euint8 mode)
    114           * Description: This function calls ioman_getSector, but recalculates the sector
    115           * address to be partition relative.
    116           * Return value: Whatever getSector returns. (pointer or 0)
    117          */
    118          euint8* part_getSect(Partition *part, euint32 address, euint8 mode)
    119          {
    120          	return(ioman_getSector(part->disc->ioman,part_getRealLBA(part,address),mode));
    121          }
    122          
    123          /* ****************************************************************************  
    124           * esint8 part_relSect(Partition *part, euint8* buf)
    125           * Description: This function calls ioman_releaseSector.
    126           * Return value: Whatever releaseSector returns.
    127          */
    128          esint8 part_relSect(Partition *part, euint8* buf)
    129          {
    130          	return(ioman_releaseSector(part->disc->ioman,buf));
    131          }
    132          
    133          esint8 part_flushPart(Partition *part,euint32 addr_l, euint32 addr_h)
    134          {
    135          	return( 
    136          		ioman_flushRange(part->disc->ioman,part_getRealLBA(part,addr_l),part_getRealLBA(part,addr_h)) 
    137          	);	
    138          }
    139          
    140          esint8 part_directSectorRead(Partition *part,euint32 address, euint8* buf)
    141          {
    142          	return(
    143          		ioman_directSectorRead(part->disc->ioman,part_getRealLBA(part,address),buf)
    144          	);
    145          }
    146          
    147          esint8 part_directSectorWrite(Partition *part,euint32 address, euint8* buf)
    148          {
    149          	return(
    150          		ioman_directSectorWrite(part->disc->ioman,part_getRealLBA(part,address),buf)
    151          	);
    152          }
    153          
    154          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  part_directSectorRead
              0 -> ioman_directSectorRead
             16 -> part_getRealLBA
       16  part_directSectorWrite
              0 -> ioman_directSectorWrite
             16 -> part_getRealLBA
       16  part_flushPart
              0 -> ioman_flushRange
             16 -> part_getRealLBA
        0  part_getRealLBA
       16  part_getSect
              0 -> ioman_getSector
             16 -> part_getRealLBA
       16  part_initPartition
             16 -> part_isFatPart
        0  part_isFatPart
       16  part_readBuf
              0 -> if_readBuf
             16 -> part_getRealLBA
        0  part_relSect
              0 -> ioman_releaseSector
       16  part_writeBuf
              0 -> if_writeBuf
             16 -> part_getRealLBA


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       6  ?Subroutine0
       8  ?Subroutine1
      20  part_directSectorRead
      20  part_directSectorWrite
      38  part_flushPart
      16  part_getRealLBA
      20  part_getSect
      36  part_initPartition
      32  part_isFatPart
      26  part_readBuf
       8  part_relSect
      26  part_writeBuf

 
 256 bytes in section .text
 
 256 bytes of CODE memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     10/Nov/2014  15:19:23 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Utilities\mainstream_v1\stm32f411\UART_LowLevel.c     #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Utilities\mainstream_v1\stm32f411\UART_LowLevel.c -D  #
#                    __ARM_CORTEX_MX__ -D DEBUG -D FREE_RTOS -D               #
#                    STM32F40_41xxx -D USE_STM324xG_EVAL -D                   #
#                    USE_STDPERIPH_DRIVER -D HOST_MODE_ENABLED -D             #
#                    IAR_ARM_CM4F -D USE_USB_OTG_FS -D STM32_IAP -D S4051A    #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Bootloade #
#                    r\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Boo #
#                    tloader\Obj\ --debug --endian=little --cpu=Cortex-M4 -e  #
#                    --fpu=VFPv4_sp --dlib_config "C:\Program Files           #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Projects\STM32_IAP\inc #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\I #
#                    nclude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\C #
#                    MSIS\Device\ST\STM32F4xx\Include\ -I                     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_HO #
#                    ST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\HT68F30\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Utilities\Third_Party\efsl\inc\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    fat_fs\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Project #
#                    s\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utiliti #
#                    es\mainstream_v1\stm32f411\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\it\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\APP_SRC\I #
#                    nclude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\APP_SRC\ -Ohz -I  #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Bootloader\Lis #
#                    t\UART_LowLevel.lst                                      #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Bootloader\Obj #
#                    \UART_LowLevel.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Utilities\mainstream_v1\stm32f411\UART_LowLevel.c
      1          #include "UART_Lowlevel.h"
      2          
      3          #define RECEIVE_BUFFER_SIZE 136
      4          
      5          typedef struct
      6          {
      7              /** Buffer storing all characters received and pending to be read */
      8              char m_rxBuffer[RECEIVE_BUFFER_SIZE];
      9          
     10              /** Number of bytes in the received buffer */
     11              byte m_rxBufferLength;
     12              
     13              /** Index to the oldest data in the buffer */
     14              byte m_rxBufferStart;
     15          
     16              /** */
     17              int m_rxOverruns;
     18              
     19              /** Tx Buffer Ready Flag */
     20              bool m_txBufferEmpty;
     21              
     22          } UART_port;
     23          
     24          /*Smith modify: remove unnecessary memory*/
     25          static UART_port m_port;	
     26          
     27          
     28          /*---------------------- AMTRAN IMPLEMENT ----------------------*/
     29          byte UARTLowLevel_getDataLength( void )
     30          {
     31              UART_port* p = &m_port;
     32          
     33              return ( p->m_rxBufferLength );
     34          }
     35          
     36          bool UARTLowLevel_isTxBufferReady(uint8 port)
     37          {
     38          	/*Smith modify: remove unnecessary memory*/
     39          	//UART_port* p = &m_port[port];
     40              UART_port* p = &m_port;	
     41          	
     42              return p->m_txBufferEmpty;
     43          }
     44          
     45          int UARTLowLevel_readData(uint8 port, void *buffer, int maxLength)
     46          {
     47          	/*Smith modify: remove unnecessary memory*/
     48          	//UART_port* p = &m_port[port];
     49              UART_port* p = &m_port;	
     50          
     51              /* Calculate the actual length of data to read */
     52              int lengthToTake = MINIMUM( maxLength, p->m_rxBufferLength );
     53          
     54              if (lengthToTake == 0)
     55              {
     56                  return 0;
     57              }
     58              
     59              /* If copying the buffer will pass the end of the buffer and wrap around */
     60              if ( (p->m_rxBufferStart + lengthToTake) > RECEIVE_BUFFER_SIZE )
     61              {
     62                  /* Then copy in two phases */
     63                  byte firstPhase = RECEIVE_BUFFER_SIZE - p->m_rxBufferStart;
     64                  byte secondPhase = lengthToTake - firstPhase;
     65                  void* secondPhaseStart = (byte*)(buffer) + firstPhase;
     66          		
     67                  MEMCPY(
     68                      buffer,
     69                      (void*)(p->m_rxBuffer + p->m_rxBufferStart), 
     70                      firstPhase
     71                      );
     72                      
     73                  MEMCPY(
     74                      secondPhaseStart,
     75                      (void*)(p->m_rxBuffer),
     76                      secondPhase
     77                      );
     78              }
     79              else
     80              {
     81              
     82                  MEMCPY(
     83                      buffer,
     84                      p->m_rxBuffer + p->m_rxBufferStart,
     85                      lengthToTake
     86                      );
     87              }
     88          
     89          
     90              /* Position the start pointer onwards... */
     91              p->m_rxBufferStart += lengthToTake;
     92              if ( p->m_rxBufferStart >= RECEIVE_BUFFER_SIZE )
     93              {
     94                  p->m_rxBufferStart -= RECEIVE_BUFFER_SIZE;
     95              }
     96              
     97              /* And update the length */
     98              p->m_rxBufferLength -= lengthToTake;
     99          
    100              return lengthToTake;
    101          }
    102          
    103          static void UARTLowLevel_interruptHandlerCommon(uint8 port, uint8 c) 
    104          {
    105          	/*Smith modify: remove unnecessary memory*/
    106          	//UART_port* p = &m_port[port];
    107          	UART_port* p = &m_port;
    108          	
    109          	uint8 U0RBR = 0;
    110          
    111          	U0RBR= c;
    112          
    113          	/* If the buffer is full, step on the oldest data */
    114          	if (p->m_rxBufferLength == RECEIVE_BUFFER_SIZE)
    115          	{
    116          		p->m_rxBuffer[p->m_rxBufferStart]=U0RBR;
    117          		ADD_MODULO(p->m_rxBufferStart, 1, RECEIVE_BUFFER_SIZE);
    118          		p->m_rxOverruns++;
    119          	}
    120          	else
    121          	{
    122          		/* Calculate the position to add the value to */
    123          		int pos = p->m_rxBufferStart;
    124          		ADD_MODULO(pos, p->m_rxBufferLength, RECEIVE_BUFFER_SIZE);
    125          
    126          		/* Read and save the data */
    127          		p->m_rxBuffer[pos]=U0RBR;
    128          
    129          		/* Increase the m_rxBufferLength */
    130          		p->m_rxBufferLength++;
    131          	}
    132          }      
    133          
    134          
    135          void usart_lowlevel_handler(uint8_t port, uint8_t c)
    136          {
    137          	UARTLowLevel_interruptHandlerCommon( port, c );
    138          }
    139          	
    140          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  UARTLowLevel_getDataLength
        0  UARTLowLevel_isTxBufferReady
       20  UARTLowLevel_readData
        8  usart_lowlevel_handler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       8  UARTLowLevel_getDataLength
       8  UARTLowLevel_isTxBufferReady
     130  UARTLowLevel_readData
     148  m_port
      70  usart_lowlevel_handler

 
 148 bytes in section .bss
 220 bytes in section .text
 
 220 bytes of CODE memory
 148 bytes of DATA memory

Errors: none
Warnings: none

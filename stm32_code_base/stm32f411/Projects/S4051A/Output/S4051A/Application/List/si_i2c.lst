###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:25:59 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\sii953x\platform\hal\i2c\si_i2c #
#                    .c                                                       #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\sii953x\platform\hal\i2c\si_i2c #
#                    .c -D S4051A -D DEBUG -D FREE_RTOS -D STM32F40_41xxx -D  #
#                    USE_STM324xG_EVAL -D USE_STDPERIPH_DRIVER -D             #
#                    __ARM_CORTEX_MX__ -D IAR_ARM_CM4F -D USE_USB_OTG_FS      #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applicati #
#                    on\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Ap #
#                    plication\Obj\ --debug --endian=little --cpu=Cortex-M4   #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\si_i2c.lst                                            #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\si_i2c.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Libraries\AMT_Drivers\sii953x\platform\hal\i2c\si_i2c.c
      1          //***************************************************************************
      2          //!file     si_i2c.c
      3          //!brief    Board Component i2c driver, ARM (Stellaris) version.
      4          //
      5          // No part of this work may be reproduced, modified, distributed,
      6          // transmitted, transcribed, or translated into any language or computer
      7          // format, in any form or by any means without written permission of
      8          // Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
      9          //
     10          // Copyright 2010-2012, Silicon Image, Inc.  All rights reserved.
     11          //***************************************************************************/
     12          
     13          #include "si_common.h"
     14          #include "si_platform.h"
     15          #include "si_timer.h"
     16          #include "si_i2c.h"
     17          #include "si_gpio.h"
     18          
     19          #if defined ( SII_DEV_953x_PORTING_PLATFORM_LM3S5956 ) 
     20          #include "si_arm.h"
     21          
     22          #endif 
     23          
     24          //*****************************************************************************
     25          //
     26          // The I2C read transaction structure definition.
     27          // ENABLE:  <S> [DEVID][W] [OFFSET] <P> <S> [DEVID][R] {[DATAn]} <P>
     28          // DISABLE: <S> [DEVID][W] [OFFSET] <S> [DEVID][R] {[DATAn]} <P>
     29          //
     30          //*****************************************************************************
     31          
     32          #define SI_I2C_WRITE_TO_READ_STOP DISABLE
     33          
     34          //*****************************************************************************
     35          //
     36          // The I2C pins that are used by this application.
     37          //
     38          //*****************************************************************************
     39          
     40          #if defined ( SII_DEV_953x_PORTING_PLATFORM_LM3S5956 )
     41          static unsigned long l_i2cPeripheralGpio[]  = { SYSCTL_PERIPH_GPIOB, SYSCTL_PERIPH_GPIOA };
     42          static unsigned long l_i2cPeripheralI2c[]   = { SYSCTL_PERIPH_I2C0, SYSCTL_PERIPH_I2C1 };
     43          static unsigned long l_i2cPortBase[]        = { GPIO_PORTB_BASE, GPIO_PORTA_BASE };
     44          static unsigned long l_i2cPins[]            = { GPIO_PIN_2 | GPIO_PIN_3, GPIO_PIN_6 | GPIO_PIN_7 };
     45          static unsigned long l_i2cBase[]            = { I2C0_MASTER_BASE, I2C1_MASTER_BASE };
     46          static unsigned long l_i2cInt[]             = { INT_I2C0, INT_I2C1 };
     47          #define I2C_SLAVE_BASE_OFFSET    0x00000800
     48          #endif 
     49          
     50          
     51          
     52          //------------------------------------------------------------------------------
     53          // Function:    SiiPlatformI2cPollForAck
     54          // Description:	Write the device address and check for ACK.  Repeat until an
     55          //				ACK is received.  Useful for waiting an EEPROM write to complete
     56          // Parameters:
     57          // Returns:
     58          //------------------------------------------------------------------------------
     59          
     60          bool_t SiiPlatformI2cPollForAck ( int busIndex, uint8_t devId )
     61          {
     62              bool_t success = true;
     63          
     64          #if defined ( SII_DEV_953x_PORTING_PLATFORM_LM3S5956_TIMER )    
     65              clock_time_t start = SiiPlatformTimerSysTicksGet();
     66          
     67              // Temporary wait until I can figure out how to actually
     68              // check whether or not the target is ACKing the device ID byte
     69          
     70              while (( SiiPlatformTimerSysTicksGet() - start ) < 10 )
     71              {
     72          
     73              }
     74          //    for ( ;; )
     75          //    {
     76          //        /* Write the register address byte.	*/
     77          //
     78          //        ROM_I2CMasterSlaveAddrSet( I2C0_MASTER_BASE, devId >> 1, false);
     79          //        ROM_I2CMasterDataPut( I2C0_MASTER_BASE, 0 );
     80          //        ROM_I2CMasterControl( I2C0_MASTER_BASE, I2C_MASTER_CMD_SINGLE_SEND );
     81          //        while ( !ROM_I2CMasterBusy( I2C0_MASTER_BASE ))
     82          //        {
     83          //        }
     84          //        if ( ROM_I2CMasterErr(I2C0_MASTER_BASE) != I2C_MASTER_ERR_NONE)
     85          //        {
     86          //            ROM_I2CMasterIntClear(I2C0_MASTER_BASE);
     87          //            break;
     88          //        }
     89          //
     90          //        success = true;
     91          //        break;
     92          //    }
     93          //
     94          //    if ( !success )
     95          //    {
     96          //        ROM_I2CMasterControl( I2C0_MASTER_BASE, I2C_MASTER_CMD_BURST_RECEIVE_ERROR_STOP );
     97          //    }
     98          #endif 
     99              return( success );
    100          }
    101          
    102          //------------------------------------------------------------------------------
    103          // Function:    ExecuteI2cTransaction
    104          // Description: Send a transaction command (SEND/RECEIVE/CONT/FINISH/STOP) to
    105          //              the I2C hardware and wait for the transaction to complete.
    106          // Parameters:  command - transaction command
    107          // Returns:     true - success, false - failure.
    108          //------------------------------------------------------------------------------
    109          
    110          static bool_t ExecuteI2cTransaction (int busIndex, uint_t command )
    111          {
    112          #if defined ( SII_DEV_953x_PORTING_PLATFORM_LM3S5956_I2C )
    113              uint_t      i2cError;
    114              SiiTimer_t  timeouter;
    115          
    116              // Start the transaction and wait for controller to go
    117              // busy.  Mask interrupts so that we don't get interrupted between
    118              // sending the command and testing the controller for 'not-busy'
    119          
    120              ROM_IntMasterDisable();
    121              ROM_I2CMasterControl( l_i2cBase[busIndex], command  );
    122              while ( !ROM_I2CMasterBusy( l_i2cBase[busIndex] ))
    123              {
    124              }
    125              ROM_IntMasterEnable();
    126          
    127              // Total transaction needs to be shorter than 10ms.
    128              SiiOsTimerSet(&timeouter, 10);
    129          
    130              // Now wait for the controller to finish
    131              while ( ROM_I2CMasterBusy( l_i2cBase[busIndex] ) && !SiiOsTimerExpired(timeouter))
    132              {
    133              }
    134          
    135              // Return result of error check.
    136          
    137              i2cError = ROM_I2CMasterErr( l_i2cBase[busIndex] );
    138              return( i2cError == I2C_MASTER_ERR_NONE );
    139          #else
    140          	return true;
    141          #endif 
    142          }
    143          
    144          //------------------------------------------------------------------------------
    145          // Function:    I2cWriteBlock
    146          // Description: Local 8/16 bit address function provides base function for all I2C writes
    147          // Parameters:
    148          // Returns:
    149          //------------------------------------------------------------------------------
    150          
    151          static bool_t I2cWriteBlock ( int busIndex, uint8_t devId, uint16_t regAddr, const uint8_t *pWrData, uint16_t nBytes )
    152          {
    153          
    154          #if defined ( SII_DEV_953x_PORTING_PLATFORM_LM3S5956_I2C )
    155              uint16_t writeCount;
    156              SiiPlatformStatus_t status = PLATFORM_I2C_WRITE_FAIL;
    157          
    158              platform.i2CError = false;
    159              for ( ;; )
    160              {
    161                  ROM_I2CMasterSlaveAddrSet( l_i2cBase[busIndex], devId >> 1, false);
    162          
    163                  // Write the register address byte(s).
    164          
    165                  if ( platform.i2c16bitAddr )
    166                  {
    167                      ROM_I2CMasterDataPut( l_i2cBase[busIndex], (regAddr >> 8) );
    168                      if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_BURST_SEND_START))
    169                      {
    170                          break;
    171                      }
    172                  }
    173                  ROM_I2CMasterDataPut( l_i2cBase[busIndex], (uint8_t)regAddr );
    174                  if ( !ExecuteI2cTransaction( busIndex, ( platform.i2c16bitAddr ) ? I2C_MASTER_CMD_BURST_SEND_CONT : I2C_MASTER_CMD_BURST_SEND_START ))
    175                  {
    176                      break;
    177                  }
    178          
    179          
    180                  if (nBytes == 0)
    181                  {
    182                      // Skip data and stop condition sending, if requested
    183                      if (!platform.i2cNoInterimStops)
    184                      {
    185                          ROM_I2CMasterControl( l_i2cBase[busIndex], I2C_MASTER_CMD_BURST_SEND_FINISH );
    186                      }
    187          
    188                      status = PLATFORM_SUCCESS;
    189                      break;
    190                  }
    191          
    192          
    193                  /* Write the data bytes. */
    194          
    195                  for ( writeCount = 0; writeCount < (nBytes - 1); writeCount++ )
    196                  {
    197          
    198                       ROM_I2CMasterDataPut( l_i2cBase[busIndex], *pWrData ); // Write the data byte to the controller.
    199                      pWrData++;
    200                      if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_BURST_SEND_CONT ))
    201                      {
    202                          break;
    203                      }
    204                  }
    205          
    206                  /* One byte left in transfer, send it with a FINISH.    */
    207          
    208                  ROM_I2CMasterDataPut( l_i2cBase[busIndex], *pWrData ); // Write the data byte to the controller.
    209                  if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_BURST_SEND_FINISH ))
    210                  {
    211                      break;
    212                  }
    213          
    214                  status = PLATFORM_SUCCESS;
    215                  break;
    216              }
    217          
    218              if ( status != PLATFORM_SUCCESS )
    219              {
    220                  ROM_I2CMasterControl( l_i2cBase[busIndex], I2C_MASTER_CMD_BURST_SEND_ERROR_STOP );
    221                  platform.i2CError = true;
    222                  platform.i2cErrorCode   = ROM_I2CMasterErr(l_i2cBase[busIndex]);
    223                  ROM_I2CMasterIntClear(l_i2cBase[busIndex]);
    224              }
    225          
    226              platform.lastResultCode  = status;
    227              return( !platform.i2CError );
    228          #else
    229          	return false;
    230          #endif 
    231          }
    232          
    233          //------------------------------------------------------------------------------
    234          // Function:    SiiPlatformI2cWriteBlock
    235          // Description:
    236          // Parameters:
    237          // Returns:
    238          //------------------------------------------------------------------------------
    239          
    240          bool_t SiiPlatformI2cWriteBlock16 ( int busIndex, uint8_t devId, uint16_t regAddr, const uint8_t *pWrData, uint16_t nBytes )
    241          {
    242              platform.i2c16bitAddr = true;
    243              return( I2cWriteBlock( busIndex, devId, regAddr, pWrData, nBytes ));
    244          }
    245          
    246          //------------------------------------------------------------------------------
    247          // Function:    SiiPlatformI2cWriteByte
    248          // Description: Write a single byte to the I2C controller.
    249          // Parameters:
    250          // Returns:		None
    251          // Note:		The SiiPlatformI2cWriteBlock() function updates lastResultCode and i2CError
    252          //------------------------------------------------------------------------------
    253          
    254          void SiiPlatformI2cWriteByte16 ( int busIndex, uint8_t devId, uint16_t regAddr, uint8_t wrData )
    255          {
    256              platform.i2c16bitAddr = true;
    257              I2cWriteBlock( busIndex, devId, regAddr, &wrData, 1 );
    258          }
    259          
    260          //------------------------------------------------------------------------------
    261          // Function:    SiiPlatformI2cWriteBlock
    262          // Description:
    263          // Parameters:
    264          // Returns:
    265          //------------------------------------------------------------------------------
    266          
    267          bool_t SiiPlatformI2cWriteBlock ( int busIndex, uint8_t devId, uint8_t regAddr, const uint8_t *pWrData, uint16_t nBytes )
    268          {
    269              platform.i2c16bitAddr = false;
    270              return( I2cWriteBlock( busIndex, devId, regAddr, pWrData, nBytes ));
    271          }
    272          
    273          //------------------------------------------------------------------------------
    274          // Function:    SiiPlatformI2cWriteByte
    275          // Description: Write a single byte to the I2C controller.
    276          // Parameters:
    277          // Returns:     None
    278          // Note:        The SiiPlatformI2cWriteBlock() function updates lastResultCode and i2CError
    279          //------------------------------------------------------------------------------
    280          
    281          void SiiPlatformI2cWriteByte ( int busIndex, uint8_t devId, uint8_t regAddr, uint8_t wrData )
    282          {
    283              platform.i2c16bitAddr = false;
    284              I2cWriteBlock( busIndex, devId, regAddr, &wrData, 1 );
    285          }
    286          
    287          //------------------------------------------------------------------------------
    288          // Function:    I2cReadBlock
    289          // Description: Local 8/16 bit address function provides base function for all I2C reads
    290          // Parameters:
    291          // Returns:
    292          //------------------------------------------------------------------------------
    293          
    294          static bool_t I2cReadBlock ( int busIndex, uint8_t devId, uint16_t regAddr, uint8_t *pRdData, uint16_t nBytes )
    295          {
    296          
    297          #if defined ( SII_DEV_953x_PORTING_PLATFORM_LM3S5956_I2C )
    298              uint16_t            command, exitCommand;
    299          	uint16_t            readCount;
    300              SiiPlatformStatus_t status = PLATFORM_I2C_READ_FAIL;
    301          
    302              platform.i2CError = false;
    303              for ( ;; )
    304              {
    305                  exitCommand = I2C_MASTER_CMD_BURST_SEND_ERROR_STOP;
    306          
    307                  ROM_I2CMasterSlaveAddrSet( l_i2cBase[busIndex], devId >> 1, false);
    308          
    309                  /* Write the register address byte(s).	*/
    310          
    311                  if ( platform.i2c16bitAddr )
    312                  {
    313                      ROM_I2CMasterDataPut( l_i2cBase[busIndex], (regAddr >> 8) );
    314                      if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_BURST_SEND_START))
    315                      {
    316                          break;
    317                      }
    318                  }
    319                  ROM_I2CMasterDataPut( l_i2cBase[busIndex], (uint8_t)regAddr );
    320          
    321          #if (SI_I2C_WRITE_TO_READ_STOP == ENABLE)
    322                  if ( !ExecuteI2cTransaction( busIndex, ( platform.i2c16bitAddr ) ? I2C_MASTER_CMD_BURST_SEND_FINISH : I2C_MASTER_CMD_SINGLE_SEND) )
    323          #else
    324                  if ( !ExecuteI2cTransaction( busIndex, ( platform.i2c16bitAddr ) ? I2C_MASTER_CMD_BURST_SEND_FINISH : I2C_MASTER_CMD_BURST_SEND_START) )
    325          #endif
    326                  {
    327                      break;
    328                  }
    329          
    330                  /* Start the transfer.	*/
    331          
    332                  ROM_I2CMasterSlaveAddrSet( l_i2cBase[busIndex], devId >> 1, true);
    333          
    334                  /* If only one byte to read, handle it specially.	*/
    335          
    336                  exitCommand = I2C_MASTER_CMD_BURST_RECEIVE_ERROR_STOP;
    337                  if ( nBytes == 1 )
    338                  {
    339                      if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_SINGLE_RECEIVE ))
    340                      {
    341                          break;
    342                      }
    343          			*pRdData = ROM_I2CMasterDataGet( l_i2cBase[busIndex] );	// Read the data byte from the controller.
    344          			status = PLATFORM_SUCCESS;
    345          			break;
    346                  }
    347          
    348                  /* More than one byte to read, start with START and loop here with CONT.	*/
    349          
    350                  command = I2C_MASTER_CMD_BURST_RECEIVE_START;
    351                  for ( readCount = 0; readCount < ( nBytes - 1 ); readCount++ )
    352                  {
    353                      if ( !ExecuteI2cTransaction( busIndex, command ))
    354                      {
    355                          break;
    356                      }
    357                      command = I2C_MASTER_CMD_BURST_RECEIVE_CONT;    // Use CONT for remaining bytes - 1
    358          
    359          			// Read the data byte from the controller.
    360          
    361          			*pRdData = ROM_I2CMasterDataGet( l_i2cBase[busIndex] );
    362          			pRdData++;
    363                  }
    364          
    365                  /* One byte left in transfer, get it with a FINISH. */
    366          
    367                  if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_BURST_RECEIVE_FINISH ))
    368                  {
    369                      break;
    370                  }
    371          		*pRdData = ROM_I2CMasterDataGet( l_i2cBase[busIndex] );
    372          
    373                  status = PLATFORM_SUCCESS;
    374                  break;
    375              }
    376          
    377              if ( status != PLATFORM_SUCCESS )
    378              {
    379                  platform.i2CError       = true;
    380                  platform.i2cErrorCode   = ROM_I2CMasterErr(l_i2cBase[busIndex]);
    381                  ROM_IntMasterEnable();
    382              }
    383          
    384              platform.lastResultCode  = status;
    385              return( !platform.i2CError );
    386          #else
    387          	return ( false );
    388          #endif 
    389          }
    390          
    391          //------------------------------------------------------------------------------
    392          // Function:    SiiPlatformI2cReadBlock
    393          // Description:
    394          // Parameters:
    395          // Returns:
    396          //------------------------------------------------------------------------------
    397          
    398          bool_t SiiPlatformI2cReadBlock16 ( int busIndex, uint8_t devId, uint16_t regAddr, uint8_t *pRdData, uint16_t nBytes )
    399          {
    400          
    401              platform.i2c16bitAddr = true;
    402              return( I2cReadBlock( busIndex, devId, regAddr, pRdData, nBytes ));
    403          }
    404          
    405          //------------------------------------------------------------------------------
    406          // Function:    SkI2cRead
    407          // Description: Read a single byte from the I2C controller
    408          // Parameters:
    409          // Returns:
    410          // Note:		The SkI2cWriteRead() function updates lastResultCode and i2CError
    411          //------------------------------------------------------------------------------
    412          
    413          uint8_t SiiPlatformI2cReadByte16 ( int busIndex, uint8_t devId, uint16_t regAddr )
    414          {
    415          	uint8_t returnData = 0;
    416          
    417              platform.i2c16bitAddr = true;
    418              I2cReadBlock( busIndex, devId, regAddr, &returnData, 1 );
    419              return( returnData );
    420          }
    421          
    422          //------------------------------------------------------------------------------
    423          // Function:    SiiPlatformI2cReadBlock
    424          // Description:
    425          // Parameters:
    426          // Returns:
    427          //------------------------------------------------------------------------------
    428          
    429          bool_t SiiPlatformI2cReadBlock ( int busIndex, uint8_t devId, uint8_t regAddr, uint8_t *pRdData, uint16_t nBytes )
    430          {
    431          
    432              platform.i2c16bitAddr = false;
    433              return( I2cReadBlock( busIndex, devId, regAddr, pRdData, nBytes ));
    434          }
    435          
    436          //------------------------------------------------------------------------------
    437          // Function:    SiiPlatformI2cReadEdidBlock
    438          // Description: Read an EDID block over DDC link
    439          // Parameters:
    440          // Returns:
    441          //------------------------------------------------------------------------------
    442          
    443          bool_t SiiPlatformI2cReadEdidBlock(int busIndex, uint8_t segmentDevId, uint8_t offsetDevId, uint8_t segment, uint8_t offset, uint8_t *pRdData, uint16_t nBytes)
    444          {
    445              bool_t isSuccess = false;
    446          
    447              platform.i2c16bitAddr = false;
    448              platform.i2cNoInterimStops = true;
    449          
    450              // write EDID segment index
    451              isSuccess = I2cWriteBlock(busIndex, segmentDevId, segment, 0, 0);
    452              // write EDID offset and read nBytes of data
    453              isSuccess = isSuccess && I2cReadBlock(busIndex, offsetDevId, offset, pRdData, nBytes);
    454          
    455              platform.i2cNoInterimStops = false;
    456          
    457              return( isSuccess );
    458          }
    459          
    460          
    461          //------------------------------------------------------------------------------
    462          // Function:    SkI2cRead
    463          // Description: Read a single byte from the I2C controller
    464          // Parameters:
    465          // Returns:
    466          // Note:        The SkI2cWriteRead() function updates lastResultCode and i2CError
    467          //------------------------------------------------------------------------------
    468          
    469          uint8_t SiiPlatformI2cReadByte ( int busIndex, uint8_t devId, uint8_t regAddr )
    470          {
    471              uint8_t returnData = 0;
    472          
    473              platform.i2c16bitAddr = false;
    474              I2cReadBlock( busIndex, devId, regAddr, &returnData, 1 );
    475              return( returnData );
    476          }
    477          
    478          //------------------------------------------------------------------------------
    479          //
    480          //------------------------------------------------------------------------------
    481          SiiPlatformStatus_t SiiPlatformI2cSendStart ( int busIndex, uint8_t deviceId, const uint8_t *pBuffer, uint16_t nBytes, bool_t sendStop)
    482          {
    483          
    484          #if defined ( SII_DEV_953x_PORTING_PLATFORM_LM3S5956_I2C )
    485              uint16_t            i, command, writeCount;
    486              SiiPlatformStatus_t status = PLATFORM_I2C_WRITE_FAIL;
    487          
    488              platform.i2CError = false;
    489              for ( ;; )
    490              {
    491                  if (nBytes == 0)
    492                  {
    493                      status = PLATFORM_INVALID_PARAMETER;
    494                      break;
    495                  }
    496                  ROM_I2CMasterSlaveAddrSet( l_i2cBase[busIndex], deviceId >> 1, false);
    497          
    498                  // Send the first byte.  If more than one byte, start a burst.
    499                  // If only one byte, use send single mode unless no stop is requested
    500                  command = I2C_MASTER_CMD_BURST_SEND_START;
    501                  if ( sendStop && ( nBytes == 1 ))
    502                  {
    503                      command = I2C_MASTER_CMD_SINGLE_SEND;
    504                  }
    505                  ROM_I2CMasterDataPut( l_i2cBase[busIndex], *pBuffer++ );
    506                  if ( !ExecuteI2cTransaction( busIndex, command ))
    507                  {
    508                      break;
    509                  }
    510                  // Sending one byte == we're done
    511                  if ( nBytes == 1 )
    512                  {
    513                      status = PLATFORM_SUCCESS;
    514                      break;
    515                  }
    516          
    517                  // More than one byte to write, continue the write using CONT.
    518                  // If sending STOP, count is nBytes - 1, otherwise send all bytes here
    519                  writeCount = (sendStop) ? (nBytes - 2) : (nBytes - 1);
    520                  for ( i = 0; i < writeCount; i++ )
    521                  {
    522                      ROM_I2CMasterDataPut( l_i2cBase[busIndex], *pBuffer ); // Write the data byte to the controller.
    523                      pBuffer++;
    524                      if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_BURST_SEND_CONT ))
    525                      {
    526                          break;
    527                      }
    528                  }
    529          
    530                  // If sending stop, there is one byte left in transfer, send it with a FINISH
    531                  if ( sendStop )
    532                  {
    533                      ROM_I2CMasterDataPut( l_i2cBase[busIndex], *pBuffer ); // Write the data byte to the controller.
    534                      if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_BURST_SEND_FINISH ))
    535                      {
    536                          break;
    537                      }
    538                  }
    539          
    540                  status = PLATFORM_SUCCESS;
    541                  break;
    542              }
    543          
    544              if ( status != PLATFORM_SUCCESS )
    545              {
    546                  ROM_I2CMasterControl( l_i2cBase[busIndex], I2C_MASTER_CMD_BURST_SEND_ERROR_STOP );
    547                  platform.i2CError       = true;
    548                  platform.i2cErrorCode   = ROM_I2CMasterErr(l_i2cBase[busIndex]);
    549                  ROM_I2CMasterIntClear(l_i2cBase[busIndex]);
    550              }
    551          
    552              platform.lastResultCode = status;
    553              return( status );
    554          #else
    555          	return (PLATFORM_FAIL);
    556          #endif
    557          }
    558          
    559          //------------------------------------------------------------------------------
    560          //
    561          //------------------------------------------------------------------------------
    562          
    563          SiiPlatformStatus_t SiiPlatformI2cSendContinue ( int busIndex, const uint8_t *pBuffer, uint16_t nBytes, bool_t sendStop )
    564          {
    565          #if defined ( SII_DEV_953x_PORTING_PLATFORM_LM3S5956_I2C )
    566              uint16_t            i, writeCount;
    567              SiiPlatformStatus_t status = PLATFORM_I2C_WRITE_FAIL;
    568          
    569              platform.i2CError = false;
    570              for ( ;; )
    571              {
    572                  if (nBytes == 0)
    573                  {
    574                      status = PLATFORM_INVALID_PARAMETER;
    575                      break;
    576                  }
    577          
    578                  // Send the first byte. Since this is a continue function, we assume
    579                  // that the last call already wrote the device address but did NOT send the
    580                  // stop bit, so we are still good for that.  Then, if more than one data byte
    581                  // to write OR they did NOT ask for stop, send data without a stop at
    582                  // the end.
    583                  if ( !sendStop || (nBytes > 1))
    584                  {
    585                      // More than one byte to write, continue the write using CONT.
    586                      // If sending STOP, count is nBytes - 1, otherwise send all bytes here
    587                      writeCount = (sendStop) ? (nBytes - 1) : nBytes;
    588                      for ( i = 0; i < writeCount; i++ )
    589                      {
    590                          ROM_I2CMasterDataPut( l_i2cBase[busIndex], *pBuffer ); // Write the data byte to the controller.
    591                          pBuffer++;
    592                          if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_BURST_SEND_CONT ))
    593                          {
    594                              break;
    595                          }
    596                      }
    597                  }
    598          
    599                  // If sending stop, there is one byte left in transfer, send it with a FINISH
    600                  if ( sendStop )
    601                  {
    602                      ROM_I2CMasterDataPut( l_i2cBase[busIndex], *pBuffer ); // Write the data byte to the controller.
    603                      if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_BURST_SEND_FINISH ))
    604                      {
    605                          break;
    606                      }
    607                  }
    608          
    609                  status = PLATFORM_SUCCESS;
    610                  break;
    611              }
    612          
    613              if ( status != PLATFORM_SUCCESS )
    614              {
    615                  ROM_I2CMasterControl( l_i2cBase[busIndex], I2C_MASTER_CMD_BURST_SEND_ERROR_STOP );
    616                  platform.i2CError       = true;
    617                  platform.i2cErrorCode   = ROM_I2CMasterErr(l_i2cBase[busIndex]);
    618                  ROM_I2CMasterIntClear(l_i2cBase[busIndex]);
    619              }
    620          
    621              platform.lastResultCode = status;
    622              return( status );
    623          #else
    624          	return ( PLATFORM_SUCCESS );
    625          #endif 
    626          }
    627          
    628          
    629          //------------------------------------------------------------------------------
    630          //
    631          //------------------------------------------------------------------------------
    632          
    633          SiiPlatformStatus_t SiiPlatformI2cReceiveStart ( int busIndex, uint8_t deviceId, uint8_t *pBuffer, uint16_t nBytes, bool_t sendStop )
    634          {
    635          
    636          #if defined ( SII_DEV_953x_PORTING_PLATFORM_LM3S5956_I2C )
    637              uint16_t            command, exitCommand;
    638              uint16_t            i, readCount;
    639              SiiPlatformStatus_t status = PLATFORM_I2C_READ_FAIL;
    640          
    641              platform.i2CError = false;
    642              for ( ;; )
    643              {
    644                  exitCommand = I2C_MASTER_CMD_BURST_RECEIVE_ERROR_STOP;
    645          
    646                  // Set up the device ID.
    647                  ROM_I2CMasterSlaveAddrSet( l_i2cBase[busIndex], deviceId >> 1, true);
    648          
    649                  // If only one byte to read, and we're asked to send STOP when finished, handle it specially.
    650                  if ( sendStop && ( nBytes == 1 ))
    651                  {
    652                      if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_SINGLE_RECEIVE ))
    653                      {
    654                          break;
    655                      }
    656                      *pBuffer = ROM_I2CMasterDataGet( l_i2cBase[busIndex] );    // Read the data byte from the controller.
    657                      status = PLATFORM_SUCCESS;
    658                      break;
    659                  }
    660          
    661                  // One byte with nostop or more than one byte to read, start with START
    662                  // and loop here with CONT.
    663                  // If sending STOP, count is nBytes - 1, otherwise send all bytes here
    664                  readCount = (sendStop) ? (nBytes - 1) : nBytes;
    665                  command = I2C_MASTER_CMD_BURST_RECEIVE_START;
    666                  for ( i = 0; i < readCount; i++ )
    667                  {
    668                      if ( !ExecuteI2cTransaction( busIndex, command ))
    669                      {
    670                          break;
    671                      }
    672                      command = I2C_MASTER_CMD_BURST_RECEIVE_CONT;    // Use CONT for remaining bytes - 1
    673          
    674                      // Read the data byte from the controller.
    675          
    676                      *pBuffer = ROM_I2CMasterDataGet( l_i2cBase[busIndex] );
    677                      pBuffer++;
    678                  }
    679          
    680                  // If sending stop, there is one byte left in transfer, get it with a FINISH
    681                  if ( sendStop )
    682                  {
    683                      if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_BURST_RECEIVE_FINISH ))
    684                      {
    685                          break;
    686                      }
    687                      *pBuffer = ROM_I2CMasterDataGet( l_i2cBase[busIndex] );
    688                  }
    689          
    690                  status = PLATFORM_SUCCESS;
    691                  break;
    692              }
    693          
    694              if ( status != PLATFORM_SUCCESS )
    695              {
    696                  platform.i2CError       = true;
    697                  platform.i2cErrorCode   = ROM_I2CMasterErr(l_i2cBase[busIndex]);
    698                  ROM_I2CMasterIntClear(l_i2cBase[busIndex]);
    699              }
    700          
    701              platform.lastResultCode = status;
    702              return( status );
    703          #else
    704          	return PLATFORM_SUCCESS;
    705          #endif 
    706          }
    707          
    708          //------------------------------------------------------------------------------
    709          //
    710          //------------------------------------------------------------------------------
    711          
    712          SiiPlatformStatus_t SiiPlatformI2cReceiveContinue ( int busIndex, uint8_t *pBuffer, uint16_t nBytes, bool_t sendStop )
    713          {
    714          
    715          #if defined ( SII_DEV_953x_PORTING_PLATFORM_LM3S5956_I2C )
    716              uint16_t            exitCommand;
    717              uint16_t            i, readCount;
    718              SiiPlatformStatus_t status = PLATFORM_I2C_READ_FAIL;
    719          
    720              platform.i2CError = false;
    721              for ( ;; )
    722              {
    723                  exitCommand = I2C_MASTER_CMD_BURST_RECEIVE_ERROR_STOP;
    724          
    725                  // We were already started (or should have been) by a previous call to
    726                  // SiiPlatformI2cReceiveStart, so we just continue on here.  If the caller asked for a
    727                  // stop at the end, this loop should handle all but the last byte
    728                  readCount = (sendStop) ? (nBytes - 1) : nBytes;
    729                  for ( i = 0; i < readCount; i++ )
    730                  {
    731                      if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_BURST_RECEIVE_CONT ))
    732                      {
    733                          break;
    734                      }
    735          
    736                      // Read the data byte from the controller.
    737                      *pBuffer = ROM_I2CMasterDataGet( l_i2cBase[busIndex] );
    738                      pBuffer++;
    739                  }
    740          
    741                  // If sending stop, there is one byte left in transfer, get it with a FINISH
    742                  if ( sendStop )
    743                  {
    744                      if ( !ExecuteI2cTransaction( busIndex, I2C_MASTER_CMD_BURST_RECEIVE_FINISH ))
    745                      {
    746                          break;
    747                      }
    748                      *pBuffer = ROM_I2CMasterDataGet( l_i2cBase[busIndex] );
    749                  }
    750          
    751                  status = PLATFORM_SUCCESS;
    752                  break;
    753              }
    754          
    755              if ( status != PLATFORM_SUCCESS )
    756              {
    757                  platform.i2CError       = true;
    758                  platform.i2cErrorCode   = ROM_I2CMasterErr(l_i2cBase[busIndex]);
    759                  ROM_I2CMasterIntClear(l_i2cBase[busIndex]);
    760              }
    761          
    762              platform.lastResultCode  = status;
    763              return( status );
    764          #else
    765          	return ( PLATFORM_SUCCESS );
    766          #endif 
    767          }
    768          
    769          
    770          //-------------------------------------------------------------------------------------------------
    771          //! @brief      Sends one or more msgNum messages (I2C sub-transactions).
    772          //! @return
    773          //-------------------------------------------------------------------------------------------------
    774          SiiPlatformStatus_t SiiPlatformI2cTransfer ( int busIndex, SiiI2cMsg_t *pMsgs, uint8_t msgNum)
    775          {
    776              SiiPlatformStatus_t status;
    777              int                 msgIndex;
    778          
    779              for ( msgIndex = 0; msgIndex < msgNum; msgIndex++ )
    780                      {
    781                  SiiI2cMsg_t *pMsg = &pMsgs[msgIndex];
    782          
    783                  if ( pMsgs[msgIndex].cmdFlags & SII_MI2C_RD )
    784                  {
    785                      // Every message gets a start bit.
    786                      status = SiiPlatformI2cReceiveStart( busIndex, pMsg->addr, pMsg->pBuf, pMsg->len, (msgIndex == (msgNum - 1)) ? true : false );
    787                  }
    788                  else
    789                  {
    790                      // Every message gets a start bit.
    791                      status = SiiPlatformI2cSendStart( busIndex, pMsg->addr, pMsg->pBuf, pMsg->len, (msgIndex == (msgNum - 1)) ? true : false );
    792                  }
    793                  if ( status != PLATFORM_SUCCESS )
    794                      {
    795                          break;
    796                      }
    797                  }
    798          
    799              return( status );
    800              }
    801          
    802          
    803          //------------------------------------------------------------------------------
    804          // Function:    SiiPlatformI2cInit
    805          // Description: Initialization of I2C hardware
    806          // Parameters:  index        - 0 for I2C0, 1 for I2C1
    807          //              isMasterMode - true for I2C master mode, false for I2C slave mode
    808          //              slaveAddress - I2C slave address (applicable to slave mode only)
    809          //              clockSpeedKHz - I2C clock speed (applicable to master mode only)
    810          //------------------------------------------------------------------------------
    811          void SiiPlatformI2cInit (uint8_t index, bool_t isMasterMode, uint8_t slaveAddress, uint_t clockSpeedKhz )
    812          {
    813          
    814          #if defined ( SII_DEV_953x_PORTING_PLATFORM_LM3S5956_I2C )
    815              uint_t ulSCLFreq, ulTPR;
    816          
    817              // Enable the ARM peripherals needed.
    818              ROM_SysCtlPeripheralEnable( l_i2cPeripheralGpio[ index] );
    819              ROM_SysCtlPeripheralEnable( l_i2cPeripheralI2c[ index] );
    820              ROM_SysCtlPeripheralReset( l_i2cPeripheralI2c[ index] );
    821          
    822              // Put the pins into HW control mode for the I2C module.
    823              ROM_GPIODirModeSet( l_i2cPortBase[ index], l_i2cPins[index], GPIO_DIR_MODE_HW);
    824              ROM_GPIOPinTypeI2C( l_i2cPortBase[ index], l_i2cPins[index] );
    825          
    826              if (isMasterMode)
    827              {
    828                  ROM_I2CMasterEnable( l_i2cBase[ index] );
    829          
    830                  // Clock speed needs to be set only on the master
    831                  ulSCLFreq = clockSpeedKhz * 1000;
    832                  ulTPR = (ROM_SysCtlClockGet() / (2 * 10 * ulSCLFreq)) - 1;
    833                  HWREG( l_i2cBase[ index] + I2C_O_MTPR) = ulTPR;
    834          
    835              }
    836              else // Slave mode
    837              {
    838                  unsigned long slaveBase = l_i2cBase[ index] + I2C_SLAVE_BASE_OFFSET;
    839          
    840                  ROM_I2CSlaveEnable( slaveBase );
    841                  ROM_I2CSlaveInit( slaveBase, slaveAddress );
    842          
    843                  // Using interrupts only on the slave
    844                  ROM_IntEnable( l_i2cInt[ index] );
    845                  ROM_I2CSlaveIntClear( slaveBase );
    846                  ROM_I2CSlaveIntEnable( slaveBase );
    847              }
    848          
    849              //I2C1 workaround, API could not set this register; so we set directly
    850              if ( index == 0 )
    851              {
    852                  //GPIO_PORTB_PCTL_R = 0x11111111;
    853              }
    854              else
    855              {
    856                  GPIO_PORTA_PCTL_R = 0x11111111;
    857              }
    858          
    859          #endif 
    860          
    861          }
    862          
    863          
    864          //------------------------------------------------------------------------------
    865          // Function:    SiiPlatformI2C0IntHandler
    866          // Description: I2C interrupt handler
    867          //------------------------------------------------------------------------------
    868          void SiiPlatformI2C0IntHandler(void)
    869          {
    870          }
    871          
    872          //------------------------------------------------------------------------------
    873          // Function:    SiiPlatformI2C0IntHandler
    874          // Description: I2C interrupt handler
    875          //------------------------------------------------------------------------------
    876          void SiiPlatformI2C1IntHandler(void)
    877          {
    878          
    879          #if defined ( SII_DEV_953x_PORTING_PLATFORM_LM3S5956_I2C )
    880              uint_t  ulInt;
    881              int_t status;
    882          #if INC_RTPI
    883              int_t data = 0;
    884          #endif
    885              static uint8_t addr = 0;
    886          
    887              ulInt = ROM_IntMasterDisable(); // Temporarily turn off interrupts.
    888          
    889              ROM_I2CSlaveIntClear(I2C1_SLAVE_BASE);
    890          
    891              //DEBUG_PRINT(MSG_ALWAYS, "I2C1 IRQ hit \n");
    892          
    893              // Test
    894              //SiiPlatformGpioLedPorts ( 0xFF );
    895          
    896          
    897              status = ROM_I2CSlaveStatus(I2C1_SLAVE_BASE);
    898              if (status != I2C_SLAVE_ACT_NONE)
    899              {
    900                  //DEBUG_PRINT(MSG_ALWAYS,"I2C1 STATUS: %d\n", status);
    901                  switch (status)
    902                        {
    903                            case I2C_SLAVE_ACT_RREQ:
    904          #if INC_RTPI
    905                                // Read request
    906                                data = ROM_I2CSlaveDataGet(I2C1_SLAVE_BASE);
    907                                SiiPlatformI2cCbSlaveWriteByte(1, addr, data );
    908                                addr++;
    909          #endif
    910                                //DEBUG_PRINT(MSG_ALWAYS,"RRQ: %x\n", data);
    911                                break;
    912                            case I2C_SLAVE_ACT_TREQ:
    913          #if INC_RTPI
    914                                // Write Request
    915                                data = (uint_t)SiiPlatformI2cCbSlaveReadByte(1, addr);
    916                                addr++;
    917                                ROM_I2CSlaveDataPut(I2C1_SLAVE_BASE, data );
    918                                //DEBUG_PRINT(MSG_ALWAYS,"TRQ\n");
    919          #endif
    920                                break;
    921                            case I2C_SLAVE_ACT_RREQ_FBR:
    922                                // Read request
    923                                addr = ROM_I2CSlaveDataGet(I2C1_SLAVE_BASE);
    924          
    925                                //DEBUG_PRINT(MSG_ALWAYS,"FBR: %x\n", data);
    926                                break;
    927                        }
    928          }
    929          
    930              if ( !ulInt )   // Re-enable interrupts if needed
    931              {
    932                  ROM_IntMasterEnable();
    933              }
    934          
    935          #endif     
    936          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  SiiPlatformI2C0IntHandler
        0  SiiPlatformI2C1IntHandler
        0  SiiPlatformI2cInit
        0  SiiPlatformI2cPollForAck
        0  SiiPlatformI2cReadBlock
        0  SiiPlatformI2cReadBlock16
        0  SiiPlatformI2cReadByte
        0  SiiPlatformI2cReadByte16
        0  SiiPlatformI2cReadEdidBlock
        0  SiiPlatformI2cReceiveContinue
        0  SiiPlatformI2cReceiveStart
        0  SiiPlatformI2cSendContinue
        0  SiiPlatformI2cSendStart
        0  SiiPlatformI2cTransfer
        0  SiiPlatformI2cWriteBlock
        0  SiiPlatformI2cWriteBlock16
        0  SiiPlatformI2cWriteByte
        0  SiiPlatformI2cWriteByte16


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
      10  ?Subroutine0
       2  SiiPlatformI2C0IntHandler
       2  SiiPlatformI2C1IntHandler
       2  SiiPlatformI2cInit
       4  SiiPlatformI2cPollForAck
       6  SiiPlatformI2cReadBlock
       2  SiiPlatformI2cReadBlock16
       6  SiiPlatformI2cReadByte
       2  SiiPlatformI2cReadByte16
      18  SiiPlatformI2cReadEdidBlock
       4  SiiPlatformI2cReceiveContinue
       4  SiiPlatformI2cReceiveStart
       4  SiiPlatformI2cSendContinue
       4  SiiPlatformI2cSendStart
      32  SiiPlatformI2cTransfer
       6  SiiPlatformI2cWriteBlock
       2  SiiPlatformI2cWriteBlock16
       8  SiiPlatformI2cWriteByte
       8  SiiPlatformI2cWriteByte16

 
 130 bytes in section .text
 
 130 bytes of CODE memory

Errors: none
Warnings: 2

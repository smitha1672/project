###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:25:34 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\APP_SRC\SERVICES\HMI_Service.c        #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\APP_SRC\SERVICES\HMI_Service.c -D     #
#                    S4051A -D DEBUG -D FREE_RTOS -D STM32F40_41xxx -D        #
#                    USE_STM324xG_EVAL -D USE_STDPERIPH_DRIVER -D             #
#                    __ARM_CORTEX_MX__ -D IAR_ARM_CM4F -D USE_USB_OTG_FS      #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applicati #
#                    on\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Ap #
#                    plication\Obj\ --debug --endian=little --cpu=Cortex-M4   #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\HMI_Service.lst                                       #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\HMI_Service.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Projects\S4051A\APP_SRC\SERVICES\HMI_Service.c
      1          #include "Defs.h"
      2          #include "Debug.h"
      3          #include "freertos_conf.h"
      4          #include "freertos_task.h"
      5          #include "freertos_typedef.h"
      6          #include "command.h"
      7          #include "device_config.h"
      8          
      9          #include "usb_host_device.h"
     10          #include "AudioSystemHandler.h"
     11          #include "PowerHandler.h"
     12          #include "BTHandler.h"
     13          #include "RFHandler.h"
     14          #include "IRCmdHandler.h"
     15          
     16          #include "ButtonCmdDispatcher.h"
     17          
     18          #if ( configSTM32F411_PORTING == 1 )
     19          #include "ChannelCheckManager.h"
     20          #endif
     21          #include "StorageDeviceManager.h"
     22          #include "FactoryCommandHandler.h"
     23          #include "UIDeviceManager.h"
     24          #include "USBMusicManager.h"
     25          
     26          #include "HMI_Service.h"
     27          
     28          //_________________________________________________________________________________________
     29          #define HMI_QUEUE_LENGTH 20
     30          #define HMI_TIME_TICK TASK_MSEC2TICKS(1)
     31          #define HMI_APC_TIME_TICK TASK_MSEC2TICKS(1000)
     32          #define HMI_CMD_TIME_UP_MSEC TASK_MSEC2TICKS(15000) 
     33          #define HMI_APD_TIMEOUT (60*15)
     34          #define EVENT_FIRST_PRESSED_OR_TIMEOUT TRUE
     35          
     36          #define CheckSignalAvaiableTime   1
     37          #define CheckSignalUnAvaiableTime 1
     38          #define HMI_AID_TIME_TICK TASK_MSEC2TICKS(500)
     39          #define AID_TIMEOUT (60*15)*2
     40          #define AnalogThrehold  6 /* check signal after 3 sec */ 
     41          #define DigitalThrehold 4 /* after 2 sec */
     42          #define AutoDetectionLastSource AUDIO_SOURCE_OPTICAL
     43          
     44          //_________________________________________________________________________________________
     45          typedef struct HMI_SERVICE_PARAMETERS
     46          {
     47              xTaskHandle userTaskHandle;
     48              xTaskHandle apcTaskHandle;
     49              xTaskHandle aidTaskHandle;
     50              TaskHandleState userState;
     51              xQueueParameters serviceQueue;
     52              xOS_TaskErrIndicator xOS_ErrId;
     53          } xHMISrvClusion;
     54          
     55          typedef struct _MASTER_GAIN_LIMIT
     56          {
     57              uint8 min_gain;
     58              uint8 max_gain;
     59          }xHMISrvMasterGainLimit;
     60          
     61          typedef enum {
     62              EVENT_ASSORT_NO_NEED_FIRST_CONFIRM,
     63              EVENT_ASSORT_SAME,
     64              EVENT_ASSORT_DIFFERENT,
     65          } xEventTypeAssort;
     66          
     67          //_________________________________________________________________________________________
     68          extern const uint8 EEpromDefaultParams[];
     69          
     70          static xHMISystemParams mSystemParams = { 
     71              SYS_EVENT_NULL,
     72              MODE_USER,    
     73              DEFAULT_APD,
     74              DEFAULT_INPUT_SRC,
     75              DEFAULT_MUTE_STATE, /*mute*/
     76              DEFAULT_MASTER_GAIN, /*master gain*/
     77              DEFAULT_BASS_GAIN,
     78              DEFAULT_TREBLE_GAIN,
     79              DEFAULT_SUB_GAIN,
     80              DEFAULT_CENTER_GAIN,
     81              DEFAULT_REAR_GAIN,
     82              DEFAULT_BALANCE,
     83              DEFAULT_SRS_TRUVOL,
     84              DEFAULT_SRS_TSHD,
     85              DEFAULT_NIGHT_MODE,
     86              DEFAULT_AV_DELAY,
     87              DEFAULT_VIZIO_RMT,
     88              DEFAULT_AID,
     89              DEFAULT_CEC_SAC,
     90              DEFAULT_CEC_ARC
     91          };
     92          
     93          static const xHMISystemParams *pSystemParams = &mSystemParams;
     94          static xHMISrvMasterGainLimit master_gain_limit = { MASTER_GAIN_MIN, MASTER_GAIN_MAX };
     95          static xHMISrvClusion mHMISrvClusion;
     96          static const xHMISrvClusion *pHMISrvClusion =&mHMISrvClusion;
     97          static xBTHandleCommand mBTHandleCommand;
     98          
     99          static xHMISrvEventParams aid_parms = {xHMI_EVENT_AID, USER_EVENT_UNDEFINED };
    100          static uint32 mProcessCnt;
    101          static uint8 mSignalAvaiableCnt;
    102          static uint8 mSignalUnavaiableCnt;
    103          static bool LastUserParmsAutoPowerDown = TRUE;
    104          static bool UserParmsAutoPowerDown = TRUE;
    105          static uint16 AID_timeout = AID_TIMEOUT;
    106          
    107          #define configMonitorHeapSize 1
    108          #if ( configMonitorHeapSize == 1 )        
    109          size_t free_heap_size = 0;
    110          #endif 
    111          
    112          //_________________________________________________________________________________________
    113          static bool HMI_Service_EventSender( void *params );
    114          
    115          static void HMI_Service_setSystemParams( const xHMISystemParams *params );
    116          
    117          static void HMI_Service_rstSystemParams( void );
    118          
    119          static void HMI_FMD_CommandHandle( const xHMISystemParams *params );
    120          
    121          static xEventTypeAssort HMI_Service_Event_Assort( xHMIUserEvents cur_events, xHMIUserEvents last_events );
    122          
    123          static void HMI_AutoInputDetect_CreateTask(void);
    124          
    125          static void HMI_AutoInputDetect_TaskCtl(bool val);
    126          
    127          static void HMI_AutoInputDetect_task( void *pvParameters );
    128          
    129          static xHMISystemParams HMI_Service_getSystemParams( void );
    130          //_________________________________________________________________________________________
    131          
    132          extern POWER_HANDLE_OBJECT *pPowerHandle_ObjCtrl;
    133          #if ( configSTM32F411_PORTING == 1 )
    134          extern USB_MUSIC_MANAGE_OBJECT *pUSB_MMP_ObjCtrl;
    135          #endif
    136          extern BT_HANDLE_OBJECT *pBTHandle_ObjCtrl;
    137          extern RF_HANDLE_OBJECT *pRFHandle_ObjCtrl;
    138          
    139          extern BTN_CONF_OBJECT *pBTN_ObjCtrl;
    140          
    141          #if ( configSTM32F411_PORTING == 1 )
    142          extern CCK_MANAGE_OBJECT *pCCKManage_ObjCtrl;
    143          #endif
    144          extern AUDIO_SYSTEM_HANDLER_OBJECT *pASH_ObjCtrl;
    145          extern FACTORY_CMD_HANDLE_OBJECT *pFMD_ObjCtrl;
    146          extern UI_DEV_MANAGER_OBJECT *pUDM_ObjCtrl;
    147          extern IR_CMD_PROGRAM_OBJECT *pIR_PrgRemote_ObjCtrl;
    148          extern STORAGE_DEVICE_MANAGER_OBJECT *pSDM_ObjCtrl;
    149          
    150          const HMI_SERVICE_OBJECT HMI_SRV_OBJ = 
    151          {
    152              HMI_Service_EventSender,
    153              HMI_Service_setSystemParams,
    154              HMI_Service_rstSystemParams,
    155              HMI_Service_getSystemParams
    156          };
    157          const HMI_SERVICE_OBJECT *pHS_ObjCtrl = &HMI_SRV_OBJ;
    158          
    159          const HMI_FACTORY_OBJECT HMI_FACTORY_OBJ = 
    160          {
    161              HMI_Service_setSystemParams,
    162              HMI_Service_rstSystemParams,
    163              HMI_FMD_CommandHandle
    164          };
    165          const HMI_FACTORY_OBJECT *pHFS_ObjCtrl = &HMI_FACTORY_OBJ;
    166          
    167          //_________________________________________________________________________________________
    168          
    169          static void _PWR_ENABLE_CTRL(bool b_pwr_on)
    170          {
    171          #if ( configSTM32F411_PORTING == 1 )
    172              if (pPowerHandle_ObjCtrl == NULL 
    173                  || pBTHandle_ObjCtrl == NULL
    174                  || pASH_ObjCtrl == NULL
    175                  || pUDM_ObjCtrl == NULL
    176                  || pUSB_MMP_ObjCtrl == NULL
    177                  )
    178              {
    179                  return;
    180              }
    181          #endif    
    182              pPowerHandle_ObjCtrl->power_toggle();
    183              //pBTHandle_ObjCtrl->power_ctl();    // No need to do this here. It is included in BT_HANDLE_RESET_BT event when execute _RST_DEF_SETTING
    184          
    185              if (!b_pwr_on)
    186              {
    187                  if ( pPowerHandle_ObjCtrl->get_power_state() == POWER_ON )
    188                  {
    189                      mSystemParams.sys_event = SYS_EVENT_SYSTEM_DOWN;           
    190                      pASH_ObjCtrl->SendEvent( &mSystemParams );
    191          #if ( configSTM32F411_PORTING == 1 )         
    192                      pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);          
    193          #endif
    194                  }
    195              }
    196              else
    197              {
    198                  if ( pPowerHandle_ObjCtrl->get_power_state() == POWER_OFF )
    199                  {
    200                      mSystemParams.sys_event = SYS_EVENT_SYSTEM_UP;                 
    201                      pASH_ObjCtrl->SendEvent( &mSystemParams );
    202          #if ( configSTM32F411_PORTING == 1 )            
    203                      pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);     
    204          #endif
    205                  }
    206              }
    207          }
    208          
    209          static void _RST_DEF_SETTING()
    210          {     
    211          #if ( configSTM32F411_PORTING == 1 )  
    212              if (pBTN_ObjCtrl == NULL 
    213                 || pASH_ObjCtrl == NULL
    214                 )
    215              {
    216                  return;
    217              }
    218          #endif
    219              mBTHandleCommand = BT_HANDLE_RESET_BT;
    220              pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);
    221              mSystemParams.op_mode = MODE_USER;
    222              HMI_Service_rstSystemParams();
    223              
    224              /* Store parameters to EEPROM*/
    225              mSystemParams.sys_event = SYS_EVENT_SAVE_USER_SETTING;     
    226              pSDM_ObjCtrl->SendEvent( &mSystemParams); 
    227          
    228              pBTN_ObjCtrl->register_user_cmd();  
    229          
    230          }
    231          //_________________________________________________________________________________________
    232          static void HMI_Service_setSystemParams( const xHMISystemParams *params ) 
    233          {
    234              if ( params != NULL )
    235              {
    236                  mSystemParams = *params;
    237              }
    238          }
    239          
    240          static void HMI_Service_rstSystemParams( void )
    241          {
    242              master_gain_limit.max_gain = MASTER_GAIN_MAX;
    243              master_gain_limit.min_gain = MASTER_GAIN_MIN;
    244              
    245              mSystemParams.apd = DEFAULT_APD;
    246              mSystemParams.input_src = DEFAULT_INPUT_SRC;
    247              mSystemParams.master_gain = DEFAULT_MASTER_GAIN;
    248              mSystemParams.mute = DEFAULT_MUTE_STATE;
    249              mSystemParams.op_mode = DEFAULT_OP_MODE;
    250              mSystemParams.bass_gain =  DEFAULT_BASS_GAIN;
    251              mSystemParams.treble_gain = DEFAULT_TREBLE_GAIN;
    252              mSystemParams.sub_gain = DEFAULT_SUB_GAIN;
    253              mSystemParams.center_gain = DEFAULT_CENTER_GAIN;
    254              mSystemParams.LsRs_gain = DEFAULT_REAR_GAIN;
    255              mSystemParams.balance = DEFAULT_BALANCE;
    256              mSystemParams.srs_truvol = DEFAULT_SRS_TRUVOL;
    257              mSystemParams.srs_tshd = DEFAULT_SRS_TSHD;
    258              mSystemParams.night_mode = DEFAULT_NIGHT_MODE;
    259              mSystemParams.av_delay = DEFAULT_AV_DELAY;
    260              mSystemParams.vizio_rmt = DEFAULT_VIZIO_RMT;
    261              mSystemParams.auto_input_detect = DEFAULT_AID;
    262              mSystemParams.cec_sac= DEFAULT_CEC_SAC;
    263              mSystemParams.cec_arc= DEFAULT_CEC_ARC;
    264          }
    265          
    266          static void HMI_Service_setDemo1n3_SysParams( xHMIOperationMode op_mode )
    267          {
    268              master_gain_limit.max_gain = DEMO_1_MASTER_GAIN_MAX;
    269              master_gain_limit.min_gain = DEMO_1_MASTER_GAIN_MIN;
    270              
    271              mSystemParams.apd = DEMO_1_APD;
    272              mSystemParams.master_gain = DEMO_1_MASTER_GAIN;
    273              mSystemParams.mute = DEMO_1_MUTE_STATE;
    274              mSystemParams.bass_gain =  DEMO_1_BASS_GAIN;
    275              mSystemParams.treble_gain = DEMO_1_TREBLE_GAIN;
    276              mSystemParams.sub_gain = DEMO_1_SUB_GAIN;
    277              mSystemParams.center_gain = DEMO_1_CENTER_GAIN;
    278              mSystemParams.LsRs_gain = DEMO_1_REAR_GAIN;
    279              mSystemParams.balance = DEMO_1_BALANCE;
    280              mSystemParams.srs_truvol = DEMO_1_SRS_TRUVOL;
    281              mSystemParams.srs_tshd = DEMO_1_SRS_TSHD;
    282              mSystemParams.night_mode = DEMO_1_NIGHT_MODE;
    283              mSystemParams.av_delay = DEMO_1_AV_DELAY;
    284              mSystemParams.vizio_rmt = DEMO_1_VIZIO_RMT;
    285              mSystemParams.auto_input_detect = DEMO_1_AID;
    286              mSystemParams.cec_sac= DEFAULT_CEC_SAC;
    287              mSystemParams.cec_arc= DEFAULT_CEC_ARC;
    288              
    289              if ( op_mode == MODE_DEMO_1 )
    290              {
    291                  mSystemParams.input_src = DEMO_1_INPUT_SRC;
    292              }
    293                 else if ( op_mode == MODE_DEMO_2 )
    294              {
    295                  mSystemParams.input_src = DEMO_2_INPUT_SRC;
    296              }
    297              else if ( op_mode == MODE_DEMO_3 )
    298              {
    299                  mSystemParams.input_src = DEMO_3_INPUT_SRC;
    300              }
    301          }
    302          
    303          static void HMI_Service_setDemo2_Timeout(void)
    304          {
    305              /*TODO: Why set here for demo mode 2*/
    306              HMI_Service_setDemo1n3_SysParams(MODE_DEMO_2); 
    307              mSystemParams.master_gain = 10; /* usb timeout volume as 10 */
    308              mSystemParams.sys_event = SYS_EVENT_DEV_CONFIG; /*set audio system event */
    309          #if ( configSTM32F411_PORTING == 1)      
    310              pASH_ObjCtrl->SendEvent( &mSystemParams );
    311          #endif    
    312          }
    313          
    314          static bool HMI_Service_EventSender( void *params ) 
    315          {
    316              xHMISrvEventParams* pParams = ( xHMISrvEventParams *)params;
    317          
    318              if ( pParams == NULL )
    319              {
    320                  return FALSE;
    321              }
    322              
    323              if (mHMISrvClusion.serviceQueue.xQueue == NULL )
    324              {
    325                  TRACE_ERROR((0, "HMI Service sender error !! "));
    326                  mHMISrvClusion.xOS_ErrId = xOS_TASK_QUEUE_IS_NULL;
    327                  return FALSE;
    328              }
    329          
    330              if ( xQueueSend( mHMISrvClusion.serviceQueue.xQueue, pParams, mHMISrvClusion.serviceQueue.xBlockTime) != pdPASS )
    331              {
    332                  TRACE_ERROR((0, " HMI_InstrSender send queue is failure "));
    333                  mHMISrvClusion.xOS_ErrId = xOS_TASK_QUEUE_SET_FAIL;
    334                  return FALSE;
    335              }
    336              return TRUE;
    337          
    338          }
    339          
    340          static bool HMI_Service_EventReceiver( xHMISrvEventParams *pEventParams ) 
    341          {
    342              if ( pEventParams == NULL )
    343              {
    344                  TRACE_ERROR((0, " HMI service instruction recevier error !! "));
    345                  return FALSE;
    346              }
    347              
    348              if ( mHMISrvClusion.serviceQueue.xQueue == NULL )
    349              {
    350                  mHMISrvClusion.xOS_ErrId = xOS_TASK_QUEUE_IS_NULL;
    351                  return FALSE;
    352              }
    353          
    354              if ( xQueueReceive( mHMISrvClusion.serviceQueue.xQueue, pEventParams, mHMISrvClusion.serviceQueue.xBlockTime ) != pdPASS )
    355              {
    356                  TRACE_ERROR((0, " HMI_InstrSender receiver queue is failure "));
    357                  mHMISrvClusion.xOS_ErrId = xOS_TASK_QUEUE_GET_FAIL;
    358                  return FALSE;
    359              }
    360          
    361              return TRUE;
    362          }
    363          
    364          static void HMI_Service_DisplayCurrentParams( xHMIUserEvents event )
    365          {
    366              if( ( pPowerHandle_ObjCtrl->get_power_state()!= POWER_ON ) && ( event != USER_EVENT_POWER ) )
    367                  return;
    368          
    369              switch( event )
    370              {
    371                  case USER_EVENT_VOL_UP:
    372                  case USER_EVENT_VOL_DN:
    373                  {
    374                      /*TODO: Send to UI */
    375                      TRACE_DEBUG((0, "Current master gain = %d", mSystemParams.master_gain ));
    376                  }
    377                      break;
    378          
    379                  case USER_EVENT_MUTE:
    380                  {
    381                      TRACE_DEBUG((0, "Current mute state = %d", mSystemParams.mute));
    382                  }
    383                      break;
    384          
    385                  default:
    386                  {
    387                      TRACE_DEBUG((0, "HMI_Service_reportCommand "));
    388                  }
    389                      break;
    390              }
    391          }
    392          
    393          static void HMI_Service_sendCommand( xHMIUserEvents event )
    394          {
    395              switch( event )
    396              {
    397                  case USER_EVENT_CEC_POWER_ON:
    398                  {
    399                      if ( pPowerHandle_ObjCtrl->get_power_state() == POWER_ON || pPowerHandle_ObjCtrl->get_power_state() == POWER_UP )
    400                          break;
    401                  }
    402          
    403                  case USER_EVENT_POWER:
    404                  {
    405                      pPowerHandle_ObjCtrl->power_toggle();  
    406                      
    407          #if ( configSTM32F411_PORTING == 1 )  
    408                      pBTHandle_ObjCtrl->power_ctl();
    409          #endif       
    410                      if ( pPowerHandle_ObjCtrl->get_power_state() == POWER_ON )
    411                      {
    412                          mSystemParams.sys_event = SYS_EVENT_SYSTEM_DOWN; 
    413                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    414                          pASH_ObjCtrl->SendEvent( &mSystemParams );
    415          #if ( configSTM32F411_PORTING == 1 )   
    416                          pSDM_ObjCtrl->SendEvent( &mSystemParams ); 
    417                          pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
    418          
    419                          if (pSystemParams->auto_input_detect == TRUE)
    420                          {    
    421                              HMI_AutoInputDetect_TaskCtl(BTASK_SUSPENDED);
    422                          }  
    423          #endif                
    424                      }
    425                      else if ( pPowerHandle_ObjCtrl->get_power_state() == POWER_OFF )
    426                      {
    427                          mSystemParams.sys_event = SYS_EVENT_SYSTEM_UP;
    428                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    429                          pASH_ObjCtrl->SendEvent( &mSystemParams );                   
    430          #if ( configSTM32F411_PORTING == 1 ) 
    431                          if ( event == USER_EVENT_CEC_POWER_ON )
    432                          mSystemParams.sys_event = SYS_EVENT_CEC_SYSTEM_UP;   
    433                          pSDM_ObjCtrl->SendEvent( &mSystemParams); 
    434             
    435          
    436                          pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
    437          
    438                          if (pSystemParams->auto_input_detect == TRUE)
    439                          {    
    440                              HMI_AutoInputDetect_TaskCtl(BTASK_RESUME);
    441                          }
    442           #endif                        
    443                      }
    444                  }
    445                      break;
    446          
    447                  case USER_EVENT_APD_TOOGLE:
    448                  {
    449                      mSystemParams.sys_event = SYS_EVENT_SAVE_USER_SETTING;
    450          
    451                      if ( pSystemParams->apd == FALSE )
    452                      {
    453                          mSystemParams.apd = TRUE;
    454                      }
    455                      else
    456                      {
    457                          mSystemParams.apd = FALSE;
    458                      }
    459                      pSDM_ObjCtrl->SendEvent( &mSystemParams);          
    460                  }
    461                      break;
    462          
    463                  case USER_EVENT_APD_ON:
    464                  {
    465                      if ( pSystemParams->apd == FALSE )
    466                      {
    467                          mSystemParams.sys_event = SYS_EVENT_SAVE_USER_SETTING;
    468                          mSystemParams.apd = TRUE;               
    469                          pSDM_ObjCtrl->SendEvent( &mSystemParams);          
    470                      }
    471                  }
    472                      break;
    473          
    474                  case USER_EVENT_APD_OFF:
    475                  {
    476                      if ( pSystemParams->apd == TRUE )
    477                      {
    478                          mSystemParams.sys_event = SYS_EVENT_SAVE_USER_SETTING;
    479                          mSystemParams.apd = FALSE;                
    480                          pSDM_ObjCtrl->SendEvent( &mSystemParams); 
    481                      }
    482                  }
    483                      break;
    484          
    485                  case USER_EVENT_SEL_SRC:
    486                  case USER_EVENT_AUTO_SEL_SRC: /*For auto detection*/
    487                  {
    488                      if (event==USER_EVENT_SEL_SRC)
    489                      {
    490                          if (pSystemParams->auto_input_detect == TRUE)/*Vizio Spec 3.3 3.a.ii.2 exit auto input detect*/
    491                          {
    492                              mSystemParams.auto_input_detect = FALSE;                    
    493                              pSDM_ObjCtrl->SendEvent( &mSystemParams);                 
    494                          }  
    495                          
    496                          if ( mSystemParams.input_src < AUDIO_SOURCE_MAX )
    497                          {
    498                              mSystemParams.input_src ++;
    499                          }
    500          
    501                          if ( mSystemParams.input_src >= AUDIO_SOURCE_MAX )
    502                          {
    503                              mSystemParams.input_src = AUDIO_SOURCE_AUX1;
    504                          }
    505                          mSystemParams.sys_event = SYS_EVENT_SEL_SRC;             
    506                          pUDM_ObjCtrl->SendEvent( &mSystemParams );    
    507                      }
    508                      else
    509                      {
    510                          if ( mSystemParams.input_src < AUTO_AUDIO_SOURCE_MAX )
    511                          {
    512                              mSystemParams.input_src ++;
    513                          }
    514          
    515                          if ( mSystemParams.input_src >= AUTO_AUDIO_SOURCE_MAX )
    516                          {
    517                              mSystemParams.input_src = AUDIO_SOURCE_AUX1;
    518                          }
    519                          mSystemParams.sys_event = SYS_EVENT_AUTO_SEL_SRC;               
    520                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    521                      }
    522                      
    523                       /*set audio system event*/
    524                      mSystemParams.sys_event = SYS_EVENT_SEL_SRC;             
    525                      pSDM_ObjCtrl->SendEvent( &mSystemParams ); 
    526                      pASH_ObjCtrl->SendEvent( &mSystemParams );
    527          #if ( configSTM32F411_PORTING == 1 )            
    528                      pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
    529          #endif
    530                      if ( mSystemParams.input_src == AUDIO_SOURCE_BLUETOOTH )
    531                      {
    532                          mBTHandleCommand = BT_HANDLE_ON;
    533                          pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);
    534                      }
    535                      else
    536                      {
    537                          mBTHandleCommand = BT_HANDLE_OFF;
    538                          pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);
    539                      }          
    540                  }
    541                      break;
    542          
    543                  case USER_EVENT_SEL_AUX1:
    544                  {         
    545                      if (pSystemParams->auto_input_detect == TRUE)/*Vizio Spec 3.3 3.a.ii.2 exit auto input detect*/
    546                      {
    547                          mSystemParams.auto_input_detect = FALSE;
    548                          pSDM_ObjCtrl->SendEvent( &mSystemParams); 
    549                      }
    550                  
    551                      mSystemParams.input_src = AUDIO_SOURCE_AUX1;
    552                      mSystemParams.sys_event = SYS_EVENT_SEL_SRC; /*set audio system event*/
    553                      pSDM_ObjCtrl->SendEvent( &mSystemParams ); 
    554                      pASH_ObjCtrl->SendEvent( &mSystemParams );
    555                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
    556          #if ( configSTM32F411_PORTING == 1 )            
    557                      pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
    558          #endif
    559                      mBTHandleCommand = BT_HANDLE_OFF;
    560                      pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);       
    561                  }
    562                      break;
    563          
    564                  case USER_EVENT_SEL_AUX2:
    565                  {        
    566                      if (pSystemParams->auto_input_detect == TRUE)/*Vizio Spec 3.3 3.a.ii.2 exit auto input detect*/
    567                      {
    568                          mSystemParams.auto_input_detect = FALSE;
    569                          pSDM_ObjCtrl->SendEvent( &mSystemParams); 
    570                      }        
    571                      
    572                      mSystemParams.input_src = AUDIO_SOURCE_AUX2;
    573                      mSystemParams.sys_event = SYS_EVENT_SEL_SRC; /*set audio system event*/
    574                      pSDM_ObjCtrl->SendEvent( &mSystemParams ); 
    575                      pASH_ObjCtrl->SendEvent( &mSystemParams );
    576                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
    577          #if ( configSTM32F411_PORTING == 1 )            
    578                      pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
    579          #endif
    580                      mBTHandleCommand = BT_HANDLE_OFF;
    581                      pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);       
    582                  }
    583                      break;
    584          
    585                  case USER_EVENT_SEL_COAXIAL:
    586                  {      
    587                      if (pSystemParams->auto_input_detect == TRUE)/*Vizio Spec 3.3 3.a.ii.2 exit auto input detect*/
    588                      {
    589                          mSystemParams.auto_input_detect = FALSE;
    590                          pSDM_ObjCtrl->SendEvent( &mSystemParams); 
    591                      }
    592                      
    593                      mSystemParams.input_src = AUDIO_SOURCE_COAXIAL;
    594                      mSystemParams.sys_event = SYS_EVENT_SEL_SRC; /*set audio system event*/
    595                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
    596                      pASH_ObjCtrl->SendEvent( &mSystemParams );
    597                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
    598          #if ( configSTM32F411_PORTING == 1 )            
    599                      pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
    600          #endif
    601                      mBTHandleCommand = BT_HANDLE_OFF;
    602                      pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);        
    603                  }
    604                      break;    
    605                      
    606                  case USER_EVENT_SEL_OPTICAL:
    607                  {        
    608                      if (pSystemParams->auto_input_detect == TRUE)/*Vizio Spec 3.3 3.a.ii.2 exit auto input detect*/
    609                      {
    610                          mSystemParams.auto_input_detect = FALSE;
    611                          pSDM_ObjCtrl->SendEvent( &mSystemParams); 
    612                      }
    613                  
    614                      mSystemParams.input_src = AUDIO_SOURCE_OPTICAL;
    615                      
    616                      mSystemParams.sys_event = SYS_EVENT_SEL_SRC; /*set audio system event*/
    617                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
    618                      pASH_ObjCtrl->SendEvent( &mSystemParams );
    619                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
    620          #if ( configSTM32F411_PORTING == 1 )            
    621                      pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
    622          #endif
    623                      mBTHandleCommand = BT_HANDLE_OFF;
    624                      pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);       
    625                  }
    626                      break;
    627          
    628                  case USER_EVENT_SEL_USB_PLAYBACK:
    629                  {     
    630                      if (pSystemParams->auto_input_detect == TRUE)/*Vizio Spec 3.3 3.a.ii.2 exit auto input detect*/
    631                      {
    632                          mSystemParams.auto_input_detect = FALSE;
    633                          pSDM_ObjCtrl->SendEvent( &mSystemParams); 
    634                      }
    635                  
    636                      mSystemParams.input_src = AUDIO_SOURCE_USB_PLAYBACK;
    637                      mSystemParams.sys_event = SYS_EVENT_SEL_SRC; /*set audio system event*/
    638                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
    639                      pASH_ObjCtrl->SendEvent( &mSystemParams );
    640                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
    641          #if ( configSTM32F411_PORTING == 1 )            
    642                      pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
    643          #endif            
    644                      mBTHandleCommand = BT_HANDLE_OFF;
    645                      pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);          
    646                  }
    647                      break;
    648          
    649                  case USER_EVENT_SEL_BT:
    650                  {
    651                      if (pSystemParams->apd == TRUE)/*Vizio Spec 3.3 3.a.ii.2 exit auto input detect*/
    652                      {
    653                          mSystemParams.apd = FALSE;
    654                          pSDM_ObjCtrl->SendEvent( &mSystemParams); 
    655                      }
    656                  
    657                      mSystemParams.input_src = AUDIO_SOURCE_BLUETOOTH;
    658                      mSystemParams.sys_event = SYS_EVENT_SEL_SRC; /*set audio system event*/
    659                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
    660                      pASH_ObjCtrl->SendEvent( &mSystemParams );
    661                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
    662          #if ( configSTM32F411_PORTING == 1 )            
    663                      pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
    664          #endif
    665                      mBTHandleCommand = BT_HANDLE_ON;
    666                      pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);
    667                  }
    668                      break;
    669          
    670                  case USER_EVENT_SEL_HDMI_IN: /*for hdmi debug*/
    671                  {
    672                      mSystemParams.input_src = AUDIO_SOURCE_HDMI_IN;
    673                      mSystemParams.sys_event = SYS_EVENT_SEL_SRC; /*set audio system event*/
    674                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
    675                      pASH_ObjCtrl->SendEvent( &mSystemParams );
    676                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
    677          #if ( configSTM32F411_PORTING == 1 )            
    678                      pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams); /*TODO: Don't merge for debug*/
    679          #endif
    680                      mBTHandleCommand = BT_HANDLE_OFF;
    681                      pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);
    682                  }
    683                      break;
    684          
    685                  case USER_EVENT_SEL_HDMI_ARC: /*Smith Implemented: Only for test ARC*/
    686                  {
    687                      mSystemParams.input_src = AUDIO_SOURCE_HDMI_ARC;
    688                      //mSystemParams.cec_arc = TRUE;
    689                      mSystemParams.sys_event = SYS_EVENT_SEL_SRC; /*set audio system event*/
    690                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
    691                      pASH_ObjCtrl->SendEvent( &mSystemParams );
    692                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
    693          #if ( configSTM32F411_PORTING == 1 )            
    694                      pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams); /*TODO: Don't merge for debug*/
    695          #endif
    696                      mBTHandleCommand = BT_HANDLE_OFF;
    697                      pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);
    698                  }
    699                      break;
    700          
    701                  case USER_EVENT_CCK:
    702                  {   
    703          #if ( configSTM32F411_PORTING == 1 )          
    704                      pCCKManage_ObjCtrl->start(&mSystemParams);
    705          #endif
    706                  }
    707                  break;
    708                  
    709                  case USER_EVENT_VOL_UP:
    710                  {             
    711                      if ( pSystemParams->master_gain < master_gain_limit.max_gain )
    712                      {
    713                          mSystemParams.master_gain ++;
    714                      }
    715          
    716                      if( pSystemParams->mute == SOUND_MUTE )
    717                      {
    718                          mSystemParams.mute = SOUND_DEMUTE;
    719                          mSystemParams.sys_event = SYS_EVENT_VOLUME_MUTE_SET; /*set audio system event*/
    720                          pASH_ObjCtrl->SendEvent( &mSystemParams );
    721          
    722                          mSystemParams.sys_event = SYS_EVENT_VOLUME_SET; /*set audio system event*/
    723                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    724                          pASH_ObjCtrl->SendEvent( &mSystemParams );   
    725                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    726                      }
    727                      else
    728                      {
    729                          mSystemParams.sys_event = SYS_EVENT_VOLUME_SET; /*set audio system event*/
    730                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    731                          pASH_ObjCtrl->SendEvent( &mSystemParams );    
    732                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    733                      }
    734                  }
    735                      break;
    736          
    737                  case USER_EVENT_VOL_DN:
    738                  {         
    739                      if ( pSystemParams->master_gain > master_gain_limit.min_gain )
    740                      {
    741                          mSystemParams.master_gain --;
    742                          mSystemParams.sys_event = SYS_EVENT_VOLUME_SET;
    743                          
    744                          pSDM_ObjCtrl->SendEvent( &mSystemParams ); 
    745                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
    746                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    747                      }
    748                  }
    749                  break;
    750          
    751                  case USER_EVENT_BASS_UP:
    752                  {
    753                      if ( pSystemParams->bass_gain <  BASS_MAX)
    754                      {
    755                          mSystemParams.bass_gain++;
    756          
    757                          mSystemParams.sys_event = SYS_EVENT_BASS_SET;
    758                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    759                          pASH_ObjCtrl->SendEvent( &mSystemParams );
    760                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    761                      }
    762                  }
    763                  break;
    764                      
    765                  case USER_EVENT_BASS_DN:
    766                  {
    767                      if ( pSystemParams->bass_gain > BASS_MIN )
    768                      {
    769                          mSystemParams.bass_gain--;
    770          
    771                          mSystemParams.sys_event = SYS_EVENT_BASS_SET;
    772                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    773                          pASH_ObjCtrl->SendEvent( &mSystemParams );
    774                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    775                      }
    776                  }
    777                  break;    
    778          
    779                  case USER_EVENT_TREBLE_UP:
    780                  {
    781                      if ( pSystemParams->treble_gain <  TREBLE_MAX)
    782                      {
    783                          mSystemParams.treble_gain++;
    784          
    785                          mSystemParams.sys_event = SYS_EVENT_TREBLE_SET;
    786                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    787                          pASH_ObjCtrl->SendEvent( &mSystemParams );
    788                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    789                      }
    790                  }
    791                  break;
    792                      
    793                  case USER_EVENT_TREBLE_DN:
    794                  {
    795                      if ( pSystemParams->treble_gain > TREBLE_MIN )
    796                      {
    797                          mSystemParams.treble_gain--;
    798          
    799                          mSystemParams.sys_event = SYS_EVENT_TREBLE_SET;
    800                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    801                          pASH_ObjCtrl->SendEvent( &mSystemParams );
    802                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    803                      }
    804                  }
    805                  break;    
    806          
    807                  case USER_EVENT_SUB_UP:
    808                  {
    809                      if ( pSystemParams->sub_gain < SUB_MAX )
    810                      {
    811                          mSystemParams.sub_gain++;
    812          
    813                          mSystemParams.sys_event = SYS_EVENT_SUB_SET;
    814                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    815                          pASH_ObjCtrl->SendEvent( &mSystemParams );
    816                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    817                      }
    818                  }
    819                  break;
    820          
    821                  case USER_EVENT_SUB_DN:
    822                  {
    823                      if ( pSystemParams->sub_gain > SUB_MIN )
    824                      {
    825                          mSystemParams.sub_gain--;
    826          
    827                          mSystemParams.sys_event = SYS_EVENT_SUB_SET;
    828                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    829                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
    830                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    831                      }
    832                  }
    833                  break;
    834          
    835                  case USER_EVENT_CENTER_UP:
    836                  {
    837                      if ( pSystemParams->center_gain < CENTER_MAX )
    838                      {
    839                          mSystemParams.center_gain++;
    840          
    841                          mSystemParams.sys_event = SYS_EVENT_CENTER_SET;
    842                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    843                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
    844                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    845                      }
    846                  }
    847                  break;
    848          
    849                  case USER_EVENT_CENTER_DN:
    850                  {
    851                      if ( pSystemParams->center_gain > CENTER_MIN )
    852                      {
    853                          mSystemParams.center_gain--;
    854          
    855                          mSystemParams.sys_event = SYS_EVENT_CENTER_SET;
    856                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    857                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
    858                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    859                      }
    860                  }
    861                  break;
    862          
    863                  case USER_EVENT_REAR_UP:
    864                  {
    865                      if ( pSystemParams->LsRs_gain < REAR_MAX )
    866                      {
    867                          mSystemParams.LsRs_gain++;
    868                          mSystemParams.sys_event = SYS_EVENT_LSRS_SET;
    869                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    870                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
    871                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    872                      }
    873                  }
    874                  break;
    875          
    876                  case USER_EVENT_REAR_DN:
    877                  {
    878                      if ( pSystemParams->LsRs_gain > REAR_MIN )
    879                      {
    880                          mSystemParams.LsRs_gain--;
    881                          mSystemParams.sys_event = SYS_EVENT_LSRS_SET;
    882                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    883                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
    884                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    885                      }
    886                  }
    887                  break;
    888          
    889                  case USER_EVENT_BALANCE_UP:
    890                  {
    891                      if ( pSystemParams->balance < BALANCE_MAX )
    892                      {
    893                          mSystemParams.balance++;
    894                          mSystemParams.sys_event = SYS_EVENT_BALANCE_SET;
    895                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    896                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
    897                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    898                      }
    899                  }
    900                  break;
    901          
    902                  case USER_EVENT_BALANCE_DN:
    903                  {
    904                      if ( pSystemParams->balance > BALANCE_MIN )
    905                      {
    906                          mSystemParams.balance--;
    907                          mSystemParams.sys_event = SYS_EVENT_BALANCE_SET;
    908                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
    909                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
    910                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
    911                      }
    912                  }
    913                          break;
    914          
    915                  case USER_EVENT_SRS_TRUVOL_ON:
    916                  {
    917                      if ( pSystemParams->srs_truvol== TRUE )
    918                      {
    919                          return;
    920                      }
    921                      else
    922                      {
    923                          mSystemParams.srs_truvol = TRUE;
    924                      }
    925          
    926                      mSystemParams.sys_event = SYS_EVENT_SRS_TRUVOL_TSHD_SET;
    927                      pASH_ObjCtrl->SendEvent( &mSystemParams ); 
    928                      mSystemParams.sys_event = SYS_EVENT_SRS_TRUVOL_SET;
    929                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
    930                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
    931                  }
    932                  break;
    933          
    934                  case USER_EVENT_SRS_TRUVOL_OFF:
    935                  {
    936                      if ( pSystemParams->srs_truvol== FALSE )
    937                      {
    938                          return;
    939                      }
    940                      else
    941                      {
    942                          mSystemParams.srs_truvol = FALSE;
    943                      }
    944          
    945                      mSystemParams.sys_event = SYS_EVENT_SRS_TRUVOL_TSHD_SET;
    946                      pASH_ObjCtrl->SendEvent( &mSystemParams ); 
    947                      mSystemParams.sys_event = SYS_EVENT_SRS_TRUVOL_SET;
    948                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
    949                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
    950                  }
    951                  break;
    952          
    953                  case USER_EVENT_SRS_TSHD_ON:
    954                  {
    955                      if ( pSystemParams->srs_tshd == TRUE )
    956                      {
    957                      return;
    958                      }
    959                      else
    960                      {
    961                          mSystemParams.srs_tshd = TRUE;
    962                      }
    963                      mSystemParams.sys_event = SYS_EVENT_SRS_TRUVOL_TSHD_SET;
    964                      pASH_ObjCtrl->SendEvent( &mSystemParams ); 
    965                      mSystemParams.sys_event = SYS_EVENT_SRS_TSHD_SET;
    966                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
    967                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
    968                  }
    969                  break;
    970          
    971                  case USER_EVENT_SRS_TSHD_OFF:
    972                  {
    973                      if ( pSystemParams->srs_tshd == FALSE )
    974                      {
    975                          return;
    976                      }
    977                      else
    978                      {
    979                          mSystemParams.srs_tshd = FALSE;
    980                      }
    981                      mSystemParams.sys_event = SYS_EVENT_SRS_TRUVOL_TSHD_SET;
    982                      pASH_ObjCtrl->SendEvent( &mSystemParams ); 
    983                      mSystemParams.sys_event = SYS_EVENT_SRS_TSHD_SET;
    984                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
    985                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
    986                  }
    987                  break;
    988          
    989                  case USER_EVENT_NIGHT_MODE_ON:
    990                  {
    991                      if ( pSystemParams->night_mode == TRUE )
    992                      {
    993                      return;
    994                      }
    995                      else
    996                      {
    997                          mSystemParams.night_mode = TRUE;
    998                      }
    999                      mSystemParams.sys_event = SYS_EVENT_NIGHT_MODE_SET;
   1000                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
   1001                      pASH_ObjCtrl->SendEvent( &mSystemParams ); 
   1002                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
   1003                  }
   1004                  break;
   1005          
   1006                  case USER_EVENT_NIGHT_MODE_OFF:
   1007                  {
   1008                      if ( pSystemParams->night_mode == FALSE )
   1009                      {
   1010                          return;
   1011                      }
   1012                      else
   1013                      {
   1014                          mSystemParams.night_mode = FALSE;
   1015                      }
   1016                      mSystemParams.sys_event = SYS_EVENT_NIGHT_MODE_SET;
   1017                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
   1018                      pASH_ObjCtrl->SendEvent( &mSystemParams ); 
   1019                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
   1020                  }
   1021                  break;
   1022          
   1023                  case USER_EVENT_AV_DELAY_UP:
   1024                  {
   1025                      if ( pSystemParams->av_delay < AV_DELAY_MAX )
   1026                      {
   1027                          mSystemParams.av_delay++;
   1028                          mSystemParams.sys_event = SYS_EVENT_AV_DELAY_SET;
   1029                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
   1030                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
   1031                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
   1032                      }
   1033                  }
   1034                  break;
   1035          
   1036                  case USER_EVENT_AV_DELAY_DN:
   1037                  {
   1038                      if ( pSystemParams->av_delay > AV_DELAY_MIN )
   1039                      {
   1040                          mSystemParams.av_delay--;
   1041          
   1042                          mSystemParams.sys_event = SYS_EVENT_AV_DELAY_SET;
   1043                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
   1044                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
   1045                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
   1046                      }
   1047                  }
   1048                  break;
   1049          
   1050                  case  USER_EVENT_RF_PAIR:   /*Elvis*/
   1051                  {
   1052                      xRFHandleCommand mRFHandleCommand;
   1053          
   1054                      mRFHandleCommand = RF_HANDLE_PAIRING_PHASE1;
   1055                      pRFHandle_ObjCtrl->rf_instr_sender(&mRFHandleCommand);
   1056                      pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_RF_PAIRING);
   1057                  }
   1058                      break;
   1059                      
   1060                  case USER_EVENT_VIZ_RMT_TOOGLE:
   1061                  {
   1062                      mSystemParams.sys_event = SYS_EVENT_SAVE_USER_SETTING;
   1063          
   1064                      if(pSystemParams->vizio_rmt == FALSE)
   1065                      {
   1066                          mSystemParams.vizio_rmt = TRUE;
   1067                      }
   1068                      else
   1069                      {
   1070                          mSystemParams.vizio_rmt = FALSE;
   1071                      }
   1072          
   1073                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
   1074                  }
   1075                  break;
   1076          
   1077                  case USER_EVENT_VIZ_RMT_ON:
   1078                  {
   1079                      if(pSystemParams->vizio_rmt == FALSE)
   1080                      {
   1081                          mSystemParams.sys_event = SYS_EVENT_SAVE_USER_SETTING;
   1082                          mSystemParams.vizio_rmt = TRUE;
   1083                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
   1084                      }
   1085                  }
   1086                  break;
   1087                  
   1088                  case USER_EVENT_VIZ_RMT_OFF:
   1089                  {
   1090                      if(pSystemParams->vizio_rmt == TRUE)
   1091                      {
   1092                          mSystemParams.sys_event = SYS_EVENT_SAVE_USER_SETTING;
   1093                          mSystemParams.vizio_rmt = FALSE;
   1094                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
   1095                      }
   1096                  }
   1097                  break;
   1098                  
   1099                  case USER_EVENT_MUTE:
   1100                  {
   1101                      mSystemParams.mute = !(mSystemParams.mute);
   1102          
   1103                      if ( pSystemParams->mute == SOUND_DEMUTE )
   1104                      {
   1105                          mSystemParams.sys_event = SYS_EVENT_VOLUME_SET;
   1106                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
   1107                      }
   1108                      
   1109                      mSystemParams.sys_event = SYS_EVENT_VOLUME_MUTE_SET;
   1110                      pASH_ObjCtrl->SendEvent( &mSystemParams ); 
   1111                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
   1112                  }
   1113                      break;
   1114                  
   1115                  case USER_EVENT_PREVIOUS:
   1116                  {
   1117                      if(pSystemParams->input_src == AUDIO_SOURCE_USB_PLAYBACK)
   1118                      {
   1119                          mSystemParams.sys_event = SYS_EVENT_USB_MMS_PREVIOUS;
   1120          #if ( configSTM32F411_PORTING == 1 ) 
   1121                          pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
   1122          #endif
   1123                      }
   1124                      else if(pSystemParams->input_src == AUDIO_SOURCE_BLUETOOTH)
   1125                      {
   1126                          mBTHandleCommand = BT_HANDLE_PREVIOUS;
   1127                          pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);
   1128                      }
   1129                  }
   1130                  break;
   1131                      
   1132                  case USER_EVENT_NEXT:
   1133                  {
   1134                      if(pSystemParams->input_src == AUDIO_SOURCE_USB_PLAYBACK)
   1135                      {
   1136                          mSystemParams.sys_event = SYS_EVENT_USB_MMS_NEXT;
   1137           #if ( configSTM32F411_PORTING == 1 )               
   1138                          pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);       
   1139          #endif
   1140                      }
   1141                      else if(pSystemParams->input_src == AUDIO_SOURCE_BLUETOOTH)
   1142                      {
   1143                          mBTHandleCommand = BT_HANDLE_NEXT;
   1144                          pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);
   1145                      }
   1146                  }
   1147                  break;
   1148                  
   1149                  case USER_EVENT_PLAY_PAUSE:
   1150                  {
   1151                      if(pSystemParams->input_src == AUDIO_SOURCE_USB_PLAYBACK)
   1152                      {
   1153                          mSystemParams.sys_event = SYS_EVENT_USB_MMS_PLAY_PAUSE;
   1154          #if ( configSTM32F411_PORTING == 1 )                
   1155                          pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
   1156          #endif
   1157                      }
   1158                      else if(pSystemParams->input_src == AUDIO_SOURCE_BLUETOOTH)
   1159                      {
   1160                          mBTHandleCommand = BT_HANDLE_PLAY_PAUSE;
   1161                          pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);
   1162                      }
   1163                  }
   1164                  break;
   1165          
   1166                  case USER_EVENT_BT_PAIR:
   1167                  {
   1168                      if (pSystemParams->auto_input_detect == TRUE)/*Vizio Spec 3.3 3.a.ii.2 exit auto input detect*/
   1169                      {
   1170                          mSystemParams.auto_input_detect = FALSE;
   1171                          pSDM_ObjCtrl->SendEvent( &mSystemParams); 
   1172                      }
   1173          
   1174                      pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_BT_PAIRING);
   1175          
   1176                      if(pSystemParams->input_src != AUDIO_SOURCE_BLUETOOTH)
   1177                      {
   1178                          mSystemParams.input_src = AUDIO_SOURCE_BLUETOOTH;
   1179                          mSystemParams.sys_event = SYS_EVENT_SEL_SRC; 
   1180                          pASH_ObjCtrl->SendEvent( &mSystemParams );
   1181          #if ( configSTM32F411_PORTING == 1 )                
   1182                          pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
   1183          #endif
   1184                          mBTHandleCommand = BT_HANDLE_ON;
   1185                          pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);
   1186                      }
   1187                      
   1188                      mBTHandleCommand = BT_HANDLE_PAIRING;
   1189                      pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);
   1190                  }
   1191                  break;
   1192          
   1193                  case USER_EVENT_BT_CLEAN:
   1194                  {
   1195                  if ( pPowerHandle_ObjCtrl->get_power_state() != POWER_ON )
   1196                  {
   1197                      TRACE_ERROR((0, "System power has not been powered up !! "));
   1198                      return;
   1199                  }
   1200                      
   1201                      if (pSystemParams->auto_input_detect == TRUE)/*Vizio Spec 3.3 3.a.ii.2 exit auto input detect*/
   1202                      {
   1203                          mSystemParams.auto_input_detect = FALSE;
   1204                          pSDM_ObjCtrl->SendEvent( &mSystemParams); 
   1205                      }
   1206                      
   1207                      mBTHandleCommand = BT_HANDLE_CLEAN_DEVICE;
   1208                      pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleCommand);
   1209                  }
   1210                  break;
   1211          
   1212                  case USER_EVENT_DEVICE_RESET:
   1213                  {
   1214                      //set default value
   1215                      _RST_DEF_SETTING();
   1216          
   1217                      //led control
   1218                      mSystemParams.sys_event = SYS_EVENT_SYSTEM_RESET; 
   1219                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
   1220                      
   1221                      //power down
   1222                      _PWR_ENABLE_CTRL(FALSE);
   1223                  }
   1224                  break;
   1225          
   1226                  case USER_EVENT_MODE_DEMO1:
   1227                  {
   1228                      if ( pSystemParams->op_mode == MODE_DEMO_1 )
   1229                      {
   1230                          mSystemParams.op_mode = MODE_USER;
   1231                          HMI_Service_rstSystemParams();
   1232          
   1233                          pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_EXIT_DEMO);              
   1234                          pBTN_ObjCtrl->register_user_cmd();              
   1235                          TRACE_DEBUG((0, "MODE - USER "));
   1236                          
   1237                          pPowerHandle_ObjCtrl->power_toggle();
   1238                          pBTHandle_ObjCtrl->power_ctl();
   1239                          mSystemParams.sys_event = SYS_EVENT_SYSTEM_DOWN;
   1240                          pSDM_ObjCtrl->SendEvent( &mSystemParams ); 
   1241                          pASH_ObjCtrl->SendEvent( &mSystemParams );
   1242          #if ( configSTM32F411_PORTING == 1 )                
   1243                          pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
   1244          #endif
   1245                      }
   1246                      else
   1247                      {
   1248                          mSystemParams.op_mode = MODE_DEMO_1;
   1249                          HMI_Service_setDemo1n3_SysParams( mSystemParams.op_mode );
   1250                          mSystemParams.sys_event = SYS_EVENT_DEV_CONFIG; /*set audio system event*/
   1251                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
   1252                          pASH_ObjCtrl->SendEvent( &mSystemParams );
   1253                          pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_ENTER_DEMO1);
   1254                         
   1255                          pBTN_ObjCtrl->register_demo_1n3_cmd();             
   1256                          TRACE_DEBUG((0, "MODE - DEMO 1 "));
   1257                      }
   1258                  }
   1259                      break;
   1260          
   1261                  case USER_EVENT_MODE_DEMO2:
   1262                  {
   1263                      /*TODO: Angus*/
   1264                      if ( pSystemParams->op_mode == MODE_DEMO_2 )
   1265                      {
   1266                          mSystemParams.op_mode = MODE_USER;
   1267                          HMI_Service_rstSystemParams();
   1268          
   1269                          pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_EXIT_DEMO);                
   1270                          pBTN_ObjCtrl->register_user_cmd();
   1271                          TRACE_DEBUG((0, "MODE - USER "));
   1272                          
   1273                          pPowerHandle_ObjCtrl->power_toggle();
   1274                          pBTHandle_ObjCtrl->power_ctl();
   1275                          mSystemParams.sys_event = SYS_EVENT_SYSTEM_DOWN;
   1276                          pSDM_ObjCtrl->SendEvent( &mSystemParams ); 
   1277                          pASH_ObjCtrl->SendEvent( &mSystemParams );
   1278          #if ( configSTM32F411_PORTING == 1 )                
   1279                          pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
   1280          #endif
   1281                      }
   1282                      else
   1283                      {
   1284                          mSystemParams.op_mode = MODE_DEMO_2;
   1285                          HMI_Service_setDemo1n3_SysParams( mSystemParams.op_mode );
   1286                          mSystemParams.sys_event = SYS_EVENT_DEV_CONFIG; /*set audio system event*/
   1287                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
   1288                          pASH_ObjCtrl->SendEvent( &mSystemParams );
   1289          #if ( configSTM32F411_PORTING == 1 )                
   1290                          pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
   1291          #endif
   1292                          pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_ENTER_DEMO2);
   1293                          pBTN_ObjCtrl->register_demo_2_cmd();
   1294                          TRACE_DEBUG((0, "MODE - DEMO 2 "));           
   1295                      }
   1296                  }
   1297                      break;
   1298          
   1299                  case USER_EVENT_MODE_DEMO3:
   1300                  {
   1301                      if ( pSystemParams->op_mode == MODE_DEMO_3 )
   1302                      {
   1303                          mSystemParams.op_mode = MODE_USER;
   1304                          HMI_Service_rstSystemParams();
   1305          
   1306                          pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_EXIT_DEMO);  
   1307                          pBTN_ObjCtrl->register_user_cmd();
   1308                 
   1309                          TRACE_DEBUG((0, "MODE - USER "));
   1310                          pPowerHandle_ObjCtrl->power_toggle();
   1311                          pBTHandle_ObjCtrl->power_ctl();
   1312                          mSystemParams.sys_event = SYS_EVENT_SYSTEM_DOWN;
   1313                          pSDM_ObjCtrl->SendEvent( &mSystemParams ); 
   1314                          pASH_ObjCtrl->SendEvent( &mSystemParams );
   1315          #if ( configSTM32F411_PORTING == 1 )                
   1316                          pUSB_MMP_ObjCtrl->SendEvent(&mSystemParams);
   1317          #endif
   1318                      }
   1319                      else
   1320                      {
   1321                          mSystemParams.op_mode = MODE_DEMO_3;
   1322                          HMI_Service_setDemo1n3_SysParams( mSystemParams.op_mode );
   1323                          mSystemParams.sys_event = SYS_EVENT_DEV_CONFIG; /*set audio system event*/
   1324                          pSDM_ObjCtrl->SendEvent( &mSystemParams );
   1325                          pASH_ObjCtrl->SendEvent( &mSystemParams );
   1326                          pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_ENTER_DEMO3);
   1327                          pBTN_ObjCtrl->register_demo_1n3_cmd();
   1328                          
   1329                          TRACE_DEBUG((0, "MODE - DEMO 3 "));
   1330                      }
   1331                  }
   1332                      break;
   1333          
   1334                  case USER_EVENT_MODE_FACTORY:
   1335                  {
   1336                      /* swithing to factory mode */
   1337                      TRACE_DEBUG((0, "MODE - FACTORY "));
   1338                      mSystemParams.sys_event = SYS_EVENT_SAVE_USER_SETTING;
   1339                      mSystemParams.op_mode = MODE_FACTORY;
   1340                      pSDM_ObjCtrl->SendEvent( &mSystemParams );
   1341                  }
   1342                      break;
   1343          
   1344                  case USER_EVENT_START_MODE:
   1345                  {
   1346                      if(pSystemParams->op_mode == MODE_DEMO_2)
   1347                      {
   1348          #if ( configSTM32F411_PORTING == 1 )            
   1349                          pUSB_MMP_ObjCtrl->StartDemoMode2();
   1350          #endif
   1351                          HMI_Service_setDemo1n3_SysParams(MODE_DEMO_2);
   1352                          mSystemParams.master_gain = 8; /* start demo2 volume as 8 */
   1353                          mSystemParams.sys_event = SYS_EVENT_DEV_CONFIG; /*set audio system event*/
   1354                          pASH_ObjCtrl->SendEvent( &mSystemParams );
   1355                      }
   1356                  }
   1357                  break;
   1358          
   1359                  case USER_EVENT_STOP_MODE:
   1360                  {
   1361                      if(pSystemParams->op_mode == MODE_DEMO_2)
   1362                      {
   1363          #if ( configSTM32F411_PORTING == 1 )             
   1364                          pUSB_MMP_ObjCtrl->StopDemoMode2();
   1365          #endif               
   1366                          HMI_Service_setDemo2_Timeout();
   1367                      }
   1368                  }
   1369                  break;
   1370                  
   1371                  case USER_EVENT_AUTO_INPUT_DETECT_CLEAN:
   1372                  {
   1373                      mSystemParams.sys_event = SYS_EVENT_SAVE_USER_SETTING;
   1374                      mSystemParams.auto_input_detect = FALSE;
   1375                      pSDM_ObjCtrl->SendEvent( &mSystemParams); 
   1376                  }
   1377                      break;
   1378          
   1379                  case USER_EVENT_VERSION:
   1380                  {
   1381                      //led control
   1382                      mSystemParams.sys_event = SYS_EVENT_VERSION; 
   1383                      pUDM_ObjCtrl->SendEvent( &mSystemParams );
   1384                  }
   1385                      break;
   1386          
   1387                  case USER_EVENT_CEC_POWER_OFF:
   1388                  {
   1389                      if ( pPowerHandle_ObjCtrl->get_power_state() == POWER_ON || pPowerHandle_ObjCtrl->get_power_state() == POWER_UP )
   1390                      {
   1391                          xHMISrvEventParams srv_parms = {xHMI_EVENT_CEC, USER_EVENT_UNDEFINED };
   1392          
   1393                          srv_parms.event = USER_EVENT_POWER;
   1394                          HMI_Service_EventSender( &srv_parms );
   1395                      }
   1396                  }
   1397                      break;
   1398          
   1399                  case USER_EVENT_CEC_SET_MUTE:
   1400                  {
   1401                      if ( pSystemParams->input_src == AUDIO_SOURCE_HDMI_IN )
   1402                      {
   1403                          mSystemParams.mute = TRUE;
   1404                          mSystemParams.sys_event = SYS_EVENT_VOLUME_MUTE_SET;
   1405                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
   1406                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
   1407                      }
   1408                  }
   1409                      break;
   1410              
   1411                  case USER_EVENT_CEC_SET_DEMUTE:
   1412                  {
   1413                      if ( pSystemParams->input_src == AUDIO_SOURCE_HDMI_IN )
   1414                      {
   1415                          mSystemParams.mute = FALSE;
   1416                          mSystemParams.sys_event = SYS_EVENT_VOLUME_MUTE_SET;
   1417                          pASH_ObjCtrl->SendEvent( &mSystemParams ); 
   1418                          pUDM_ObjCtrl->SendEvent( &mSystemParams );
   1419                      }
   1420                  }
   1421                      break;
   1422              
   1423                  case USER_EVENT_CEC_SET_SAC_ON:
   1424                  {
   1425                      mSystemParams.cec_sac = TRUE;
   1426                  }
   1427                      break;
   1428                  
   1429                  case USER_EVENT_CEC_SET_SAC_OFF:
   1430                  {
   1431                      mSystemParams.cec_sac = FALSE;
   1432                  }
   1433                      break;
   1434                  
   1435                  case USER_EVENT_CEC_SET_ARC_ON:
   1436                  {
   1437                      mSystemParams.cec_arc = TRUE;
   1438                  }
   1439                      break;
   1440                  
   1441                  case USER_EVENT_CEC_SET_ARC_OFF:
   1442                  {
   1443                      mSystemParams.cec_arc = FALSE;
   1444                  }
   1445                      break;
   1446                  
   1447                  default:
   1448                      break;
   1449               }
   1450          }
   1451          
   1452          static void HMI_FMD_CommandHandle( const xHMISystemParams *params )
   1453          {
   1454              if ( params == NULL )
   1455                  return;
   1456          
   1457              /*notice: the api is only used to factory mode.*/
   1458              if ( params->op_mode != MODE_FACTORY )
   1459                  return;
   1460          
   1461              switch( params->sys_event)    
   1462              {
   1463                  case SYS_EVENT_SYSTEM_UP:
   1464                  case SYS_EVENT_CEC_SYSTEM_UP:
   1465                  case SYS_EVENT_SYSTEM_DOWN:
   1466                  case SYS_EVENT_SEL_SRC:
   1467                  case SYS_EVENT_VOLUME_MUTE_SET:
   1468                  case SYS_EVENT_VOLUME_SET:
   1469                  case SYS_EVENT_TREBLE_SET:
   1470                  case SYS_EVENT_BASS_SET:    
   1471                  {
   1472                      pASH_ObjCtrl->SendEvent( params );
   1473                      pFMD_ObjCtrl->AckSuccess( NULL );
   1474                  }
   1475                      break;
   1476          
   1477                  default:
   1478                      return;
   1479              }
   1480          
   1481              mSystemParams = *params;
   1482          
   1483          }
   1484          
   1485          static bool HMI_Service_EventBypassWhenStandby( xHMISrvEventParams *pEventParams )
   1486          {
   1487              bool ret = FALSE;
   1488          
   1489              if( pPowerHandle_ObjCtrl->get_power_state() == POWER_OFF ) 
   1490              {
   1491                  switch( pEventParams->event )
   1492                  {       
   1493                      case USER_EVENT_POWER:
   1494                      case USER_EVENT_MODE_FACTORY:    
   1495                      case USER_EVENT_CEC_POWER_ON:
   1496                      {    
   1497                          ret = TRUE;
   1498                      }
   1499                          break;
   1500                      case USER_EVENT_VOL_UP:
   1501                      case USER_EVENT_VOL_DN:
   1502                      {
   1503                          pEventParams->event = USER_EVENT_POWER;
   1504                          ret = TRUE;
   1505                      }
   1506                          break;
   1507                      default:
   1508                          ret = FALSE;
   1509                          break;
   1510                  }
   1511              }
   1512              else if ( pPowerHandle_ObjCtrl->get_power_state() == POWER_ON )
   1513              {
   1514                  ret = TRUE;
   1515              }
   1516              return ret;
   1517          }
   1518          
   1519          static void HMI_Service_DetectStopCCKCommand( xHMIUserEvents event )
   1520          {
   1521          #if ( configSTM32F411_PORTING == 1 )
   1522              switch( event )
   1523              {
   1524                  case USER_EVENT_POWER:
   1525                  case USER_EVENT_START_MODE:
   1526                  case USER_EVENT_STOP_MODE:
   1527                  case USER_EVENT_SEL_AUX1:
   1528                  case USER_EVENT_SEL_AUX2:
   1529                  case USER_EVENT_SEL_COAXIAL:
   1530                  case USER_EVENT_SEL_OPTICAL:
   1531                  case USER_EVENT_SEL_USB_PLAYBACK:
   1532                  case USER_EVENT_SEL_BT:
   1533                  case USER_EVENT_SEL_SRC:
   1534                  case USER_EVENT_MODE_DEMO1:
   1535                  case USER_EVENT_MODE_DEMO2:
   1536                  case USER_EVENT_MODE_DEMO3:
   1537                  case USER_EVENT_MODE_FACTORY:
   1538                  case USER_EVENT_BT_PAIR:
   1539                  case USER_EVENT_DEVICE_RESET:
   1540                  case USER_EVENT_BASS_UP:
   1541                  case USER_EVENT_BASS_DN:
   1542                  case USER_EVENT_TREBLE_UP:
   1543                  case USER_EVENT_TREBLE_DN:
   1544                  case USER_EVENT_SUB_UP:
   1545                  case USER_EVENT_SUB_DN:
   1546                  case USER_EVENT_CENTER_UP:
   1547                  case USER_EVENT_CENTER_DN:
   1548                  case USER_EVENT_REAR_UP:
   1549                  case USER_EVENT_REAR_DN:
   1550                  case USER_EVENT_SRS_TRUVOL_ON:
   1551                  case USER_EVENT_SRS_TRUVOL_OFF:
   1552                  case USER_EVENT_SRS_TSHD_ON:
   1553                  case USER_EVENT_SRS_TSHD_OFF:
   1554                  case USER_EVENT_NIGHT_MODE_ON:
   1555                  case USER_EVENT_NIGHT_MODE_OFF:
   1556                  case USER_EVENT_AV_DELAY_UP:
   1557                  case USER_EVENT_AV_DELAY_DN:
   1558                  case USER_EVENT_BALANCE_UP:
   1559                  case USER_EVENT_BALANCE_DN:
   1560                  {
   1561                       pCCKManage_ObjCtrl->stop(&mSystemParams);
   1562                  }
   1563                  break;
   1564              }
   1565          #endif   
   1566          }
   1567          
   1568          static bool HMI_Service_DetectConfirmEvent(void *params)
   1569          {
   1570              xHMISrvEventParams *pEventParams = ( xHMISrvEventParams*)params;
   1571              bool res = TRUE;
   1572          
   1573              switch(pEventParams->event)
   1574              {
   1575                  case USER_EVENT_POWER:
   1576                  case USER_EVENT_MUTE:
   1577                  case USER_EVENT_PREVIOUS:
   1578                  case USER_EVENT_NEXT:
   1579                  case USER_EVENT_PLAY_PAUSE:
   1580                  case USER_EVENT_BT_PAIR:
   1581                  case USER_EVENT_RF_PAIR:
   1582                  case USER_EVENT_DEVICE_RESET:
   1583                  case USER_EVENT_MODE_DEMO1:
   1584                  case USER_EVENT_MODE_DEMO2:
   1585                  case USER_EVENT_MODE_DEMO3:
   1586                  case USER_EVENT_VIZ_RMT_TOOGLE:
   1587                  case USER_EVENT_VIZ_RMT_ON:
   1588                  case USER_EVENT_VIZ_RMT_OFF:
   1589                  case USER_EVENT_MODE_FACTORY:
   1590                  case USER_EVENT_START_MODE:
   1591                  case USER_EVENT_STOP_MODE:
   1592                  case USER_EVENT_SEL_AUX1:
   1593                  case USER_EVENT_SEL_AUX2:
   1594                  case USER_EVENT_SEL_COAXIAL:
   1595                  case USER_EVENT_SEL_OPTICAL:
   1596                  case USER_EVENT_SEL_USB_PLAYBACK:
   1597                  case USER_EVENT_SEL_BT:
   1598                  case USER_EVENT_CCK:
   1599                  {
   1600                      res = FALSE;
   1601                  }
   1602                  break;
   1603              }
   1604              HMI_Service_DetectStopCCKCommand(pEventParams->event);
   1605              return res;
   1606          }
   1607          
   1608          
   1609          
   1610          static bool HMI_Service_checkEventTimoutOrFirstPressed( xHMIUserEvents cur_events )
   1611          {
   1612              static portTickType xTimeTick = 0;
   1613              static xHMIUserEvents lastEvent = USER_EVENT_NULL;
   1614              //static bool HasBeenSetVolumeEvent = FALSE;
   1615              portTickType duration;
   1616              bool ret = FALSE;
   1617              xEventTypeAssort ETA = EVENT_ASSORT_NO_NEED_FIRST_CONFIRM;
   1618              
   1619              if( pPowerHandle_ObjCtrl->get_power_state() == POWER_OFF )
   1620                  return FALSE;
   1621          
   1622              ETA = HMI_Service_Event_Assort(cur_events, lastEvent);
   1623          
   1624              lastEvent = cur_events;
   1625              
   1626              if ( ETA == EVENT_ASSORT_NO_NEED_FIRST_CONFIRM )
   1627              {
   1628                  ret = FALSE;
   1629              }
   1630              else
   1631              {
   1632                  duration = ( xTaskGetTickCount( ) - xTimeTick );
   1633                  xTimeTick = xTaskGetTickCount( );
   1634          
   1635                  if ( ETA == EVENT_ASSORT_DIFFERENT )
   1636                  {
   1637                      ret = TRUE;
   1638                  }
   1639                  else // EVENT_ASSORT_SAME
   1640                  {
   1641                      if ( (duration/portTICK_RATE_MS) > HMI_CMD_TIME_UP_MSEC )    // > 15 sec
   1642                      {
   1643                          ret = TRUE;
   1644                      }
   1645                      else    // < 15 sec
   1646                      {
   1647                          ret = FALSE;
   1648                      }
   1649                  }
   1650              }
   1651              
   1652              return ret;
   1653              
   1654          }
   1655          
   1656          
   1657          static void HMI_Service_FilterDemoModeEvent(void *params)
   1658          {
   1659               xHMISrvEventParams* pParams = ( xHMISrvEventParams *)params;
   1660              if(mSystemParams.op_mode == MODE_DEMO_1 || mSystemParams.op_mode == MODE_DEMO_2 ||\
   1661                 mSystemParams.op_mode == MODE_DEMO_3)
   1662              {
   1663                  switch(pParams->event)
   1664                  {
   1665                      case USER_EVENT_POWER:
   1666                      {
   1667                          if(pPowerHandle_ObjCtrl->get_power_state() == POWER_OFF )
   1668                          {
   1669                              pParams->event = USER_EVENT_POWER;           
   1670                          }
   1671                          else
   1672                          {
   1673                              if(mSystemParams.op_mode == MODE_DEMO_2)
   1674                              {
   1675                                  pParams->event = USER_EVENT_START_MODE;      
   1676                              }
   1677                              else
   1678                              {
   1679                                  pParams->event = USER_EVENT_NULL;
   1680                              }
   1681                          }
   1682                      }
   1683                      break;
   1684          
   1685                      case USER_EVENT_SEL_SRC:
   1686                      {
   1687                          if(mSystemParams.op_mode == MODE_DEMO_2)
   1688                          {
   1689                              pParams->event = USER_EVENT_STOP_MODE;      
   1690                          }
   1691                          else
   1692                          {
   1693                              pParams->event = USER_EVENT_NULL;
   1694                          }
   1695                      }
   1696                      break;
   1697                      
   1698                      case USER_EVENT_SEL_AUX1:
   1699                      case USER_EVENT_SEL_AUX2:
   1700                      case USER_EVENT_SEL_COAXIAL:
   1701                      case USER_EVENT_SEL_OPTICAL:
   1702                      case USER_EVENT_SEL_USB_PLAYBACK:
   1703                      case USER_EVENT_SEL_BT:
   1704                      case USER_EVENT_BT_PAIR:
   1705                      case USER_EVENT_RF_PAIR:
   1706                      {
   1707                          pParams->event = USER_EVENT_NULL;
   1708                      }
   1709                      break;
   1710                  }
   1711              }
   1712          }
   1713          
   1714          static bool HMI_Service_Filter_VIZ_FAC_Event(void *params)
   1715          {
   1716              xHMISrvEventParams *pEventParams = ( xHMISrvEventParams*)params;
   1717              
   1718              if(mSystemParams.vizio_rmt == FALSE && pEventParams->event_id== xHMI_EVENT_VIZ_FAC_IR)
   1719                  return FALSE;
   1720          
   1721              return TRUE;
   1722          }
   1723          
   1724          static void HMI_Service_handleCommand( void *params )
   1725          {
   1726              xHMISrvEventParams *pEventParams = ( xHMISrvEventParams*)params;
   1727          
   1728              if ( pEventParams->event == USER_EVENT_NULL )
   1729              {
   1730                  TRACE_ERROR((0, "Unsupported event "));
   1731                  return;
   1732              }
   1733              if ( pEventParams->event_id == xHMI_EVENT_NULL )
   1734              {
   1735                  return;
   1736              }
   1737              if(HMI_Service_Filter_VIZ_FAC_Event(pEventParams) == FALSE)
   1738              {
   1739                  return;
   1740              }
   1741              if ( HMI_Service_EventBypassWhenStandby( pEventParams ) == FALSE )
   1742              {
   1743                  return;
   1744              }
   1745              HMI_Service_FilterDemoModeEvent(pEventParams);
   1746              if(HMI_Service_DetectConfirmEvent(pEventParams) == FALSE)
   1747              {
   1748                  pIR_PrgRemote_ObjCtrl->SendEvent( pEventParams->event );
   1749                  HMI_Service_sendCommand( pEventParams->event );
   1750              }
   1751              else
   1752              {
   1753                  if ( HMI_Service_checkEventTimoutOrFirstPressed( pEventParams->event ) == TRUE )
   1754                  {
   1755                      /*TODO: could report to UI task*/
   1756                      TRACE_DEBUG((0, "EVENT - First Pressed or TimeOut ")); 
   1757                  }
   1758                  else
   1759                  {
   1760                      pIR_PrgRemote_ObjCtrl->SendEvent( pEventParams->event );
   1761                      HMI_Service_sendCommand( pEventParams->event );
   1762                  }
   1763              }
   1764          }
   1765          
   1766          static uint8 HMI_Service_InstrGetQueueNumber( void )
   1767          {
   1768              return (uint8)uxQueueMessagesWaiting(mHMISrvClusion.serviceQueue.xQueue);
   1769          }
   1770          
   1771          void HMI_ServiceUser( void *pvParameters )
   1772          {
   1773              xHMISrvEventParams EventParams;
   1774          
   1775              for( ;; )
   1776              {
   1777          #if ( configMonitorHeapSize == 1 )        
   1778                  free_heap_size = xPortGetFreeHeapSize();    
   1779          #endif
   1780                  
   1781                  switch( mHMISrvClusion.userState )
   1782                  {
   1783                      case TASK_SUSPENDED:
   1784                      {
   1785                          pSDM_ObjCtrl->Initialize( &mSystemParams ); /*Reloader user parameters from EEPROM*/
   1786                          mHMISrvClusion.userState = TASK_READY;
   1787                      }
   1788                          break;
   1789                      
   1790                      case TASK_READY:
   1791                      {
   1792                          if ( HMI_Service_InstrGetQueueNumber() != 0 )
   1793                          {
   1794                              mHMISrvClusion.userState = TASK_RUNING;
   1795                          }
   1796                      }
   1797                          break;
   1798                  
   1799                      case TASK_RUNING:
   1800                      {
   1801                          if (HMI_Service_EventReceiver( &EventParams ) == TRUE )
   1802                          {
   1803                              HMI_Service_handleCommand( &EventParams );
   1804                              
   1805                              mHMISrvClusion.userState = TASK_BLOCKED;
   1806                          }
   1807                          else
   1808                          {
   1809                              mHMISrvClusion.userState = TASK_READY;
   1810                          }
   1811                      }
   1812                          break;
   1813          
   1814                      case TASK_BLOCKED:
   1815                      {
   1816                          mHMISrvClusion.userState = TASK_READY;
   1817                      }
   1818                          break;
   1819                  }
   1820                      
   1821                  vTaskDelay(HMI_TIME_TICK);
   1822              }
   1823          }
   1824          
   1825          void HMI_AutoPowerControl_Task( void *pvParameters )
   1826          {
   1827              xHMISrvEventParams srv_parms = {xHMI_EVENT_APC, USER_EVENT_UNDEFINED };
   1828              static uint16 timeout = HMI_APD_TIMEOUT;
   1829          
   1830              for( ;; )
   1831              {
   1832                  if( pPowerHandle_ObjCtrl->get_power_state() == POWER_OFF )
   1833                  {
   1834                      timeout = HMI_APD_TIMEOUT;
   1835          
   1836                      switch( pSystemParams->op_mode )
   1837                      {
   1838                          case MODE_FACTORY:
   1839                          {
   1840                              /*TODO*/
   1841                              srv_parms.event_id = xHMI_EVENT_UART; /*ir m2489 or vcp factory command*/
   1842                          }
   1843                              break;
   1844                          case MODE_DEMO_1:
   1845                          {
   1846                              HMI_Service_setDemo1n3_SysParams( pSystemParams->op_mode );
   1847                              pBTN_ObjCtrl->register_demo_1n3_cmd();
   1848                          }
   1849                              break;
   1850                              
   1851                          case MODE_DEMO_2:
   1852                          {
   1853                              HMI_Service_setDemo1n3_SysParams( pSystemParams->op_mode );
   1854                              pBTN_ObjCtrl->register_demo_2_cmd();
   1855                          }
   1856                              break;
   1857                              
   1858                          case MODE_DEMO_3:
   1859                          {
   1860                              HMI_Service_setDemo1n3_SysParams( pSystemParams->op_mode );
   1861                              pBTN_ObjCtrl->register_demo_1n3_cmd();
   1862                          }
   1863                              break;
   1864                      }
   1865          
   1866                      if ( pSystemParams->op_mode != MODE_USER )
   1867                      {
   1868                          srv_parms.event = USER_EVENT_POWER;
   1869                          HMI_Service_EventSender( &srv_parms );
   1870                      }
   1871                  
   1872                  }
   1873                  else if ( pPowerHandle_ObjCtrl->get_power_state() == POWER_ON )
   1874                  {
   1875                      if ( pSystemParams->apd == TRUE )
   1876                      {
   1877                          if ( pASH_ObjCtrl->IsSignalAvailable() == 0)
   1878                          {
   1879                              if ( timeout < 1 )
   1880                              {
   1881                                  timeout = HMI_APD_TIMEOUT;
   1882                                  srv_parms.event = USER_EVENT_POWER;
   1883                                  HMI_Service_EventSender( &srv_parms );
   1884                              }
   1885                              else
   1886                              {
   1887                                  timeout --;
   1888                                  TRACE_DEBUG((0, "APD COUNT = %d", timeout ));
   1889                              }
   1890                          }
   1891                          else
   1892                          {
   1893                              timeout = HMI_APD_TIMEOUT;
   1894                          }
   1895                      }
   1896                  }
   1897                  
   1898                  vTaskDelay(HMI_APC_TIME_TICK);
   1899              }
   1900          }
   1901          
   1902          void HMI_AutoPowerControl_CreateTask( void )
   1903          {
   1904          #if ( configAPP_APD == 1 )
   1905              if ( xTaskCreate( 
   1906                  HMI_AutoPowerControl_Task, 
   1907                  ( portCHAR * ) "HMI_APC", 
   1908                  STACK_SIZE, 
   1909                  NULL, 
   1910                  tskHMI_APC_PRIORITY, 
   1911                  &mHMISrvClusion.apcTaskHandle ) != pdPASS )
   1912              {
   1913                  vTaskDelete( mHMISrvClusion.apcTaskHandle );
   1914              }
   1915              else
   1916              {
   1917                  vTaskSuspend( mHMISrvClusion.apcTaskHandle );
   1918              }
   1919          #endif     
   1920          }
   1921          
   1922          static void HMI_AutoPowerControl_TaskCtl(bool val)
   1923          {
   1924              if( val == BTASK_SUSPENDED )
   1925              {
   1926                  if ( xTaskIsTaskSuspended( mHMISrvClusion.apcTaskHandle ) != pdPASS ) /*task is working*/
   1927                  {
   1928                      TRACE_DEBUG((0, "SUSPEND: HMI_AutoPowerControl_TaskCtl"));
   1929                      vTaskSuspend( mHMISrvClusion.apcTaskHandle );
   1930                  }
   1931              }
   1932              else
   1933              {
   1934                  if ( xTaskIsTaskSuspended( mHMISrvClusion.apcTaskHandle ) == pdPASS ) /*task is not working*/
   1935                  {
   1936                      vTaskResume( mHMISrvClusion.apcTaskHandle );
   1937                      TRACE_DEBUG((0, "RESUME: HMI_AutoPowerControl_TaskCtl"));
   1938                  }
   1939              }
   1940          }
   1941          
   1942          /*******************************************************************************
   1943           * Auto input detect
   1944           ******************************************************************************/
   1945          static void HMI_AutoInputDetect_CreateTask(void)
   1946          {
   1947          #if ( configAPP_AID == 1 )
   1948              if ( xTaskCreate( 
   1949                              HMI_AutoInputDetect_task, 
   1950                              ( portCHAR * ) "Auto_Input_Detect_Manager", 
   1951                              (STACK_SIZE), 
   1952                              NULL, 
   1953                              tskAID_MANAGER_PRIORITY, 
   1954                              &mHMISrvClusion.aidTaskHandle ) != pdPASS )
   1955              {
   1956                  vTaskDelete( mHMISrvClusion.aidTaskHandle  );
   1957                  TRACE_ERROR((0, "Auto_Input_Detect_Manager task create failure " ));
   1958              }
   1959          #endif       
   1960          }
   1961          
   1962          static void HMI_AutoInputDetect_TaskCtl(bool val)
   1963          {
   1964              if( val == BTASK_SUSPENDED )
   1965              {
   1966                  if ( xTaskIsTaskSuspended( mHMISrvClusion.aidTaskHandle ) != pdPASS ) /*task is working*/
   1967                  {
   1968                      TRACE_DEBUG((0, "SUSPEND: Auto_Input_Detect_Manager"));
   1969                      HMI_AutoPowerControl_TaskCtl(BTASK_RESUME);
   1970                      vTaskSuspend( mHMISrvClusion.aidTaskHandle );
   1971                  }
   1972              }
   1973              else
   1974              {
   1975                  if ( xTaskIsTaskSuspended( mHMISrvClusion.aidTaskHandle ) == pdPASS ) /*task is not working*/
   1976                  {
   1977                      AID_timeout = AID_TIMEOUT;
   1978                      mSignalAvaiableCnt = 0;
   1979                      mSignalUnavaiableCnt = 0;
   1980                      mProcessCnt = 0;  
   1981                      vTaskResume( mHMISrvClusion.aidTaskHandle );
   1982                      TRACE_DEBUG((0, "RESUME: Auto_Input_Detect_Manager"));
   1983                      HMI_AutoPowerControl_TaskCtl(BTASK_SUSPENDED);
   1984                      if (  pPowerHandle_ObjCtrl->get_power_state() != POWER_ON )
   1985                      {
   1986                          aid_parms.event = USER_EVENT_POWER; /* Poweron*/
   1987                          HMI_Service_EventSender( &aid_parms );
   1988                      }
   1989                  }
   1990              }
   1991          }
   1992          
   1993          static void HMI_AutoInputDetect_task( void *pvParameters )
   1994          {
   1995              uint8 SignalAvaliableThrehold; 
   1996              uint8 SystemResetType;
   1997          
   1998              for(;;)
   1999              {
   2000                  if( pHMISrvClusion->userState == TASK_READY )
   2001                  {
   2002                      /*Turn off when flag is not set*/
   2003                      if ( pSystemParams->auto_input_detect == FALSE)
   2004                      {
   2005                          HMI_AutoInputDetect_TaskCtl(BTASK_SUSPENDED);
   2006                      }
   2007                      
   2008                      if (  pPowerHandle_ObjCtrl->get_power_state() == POWER_OFF )
   2009                      {
   2010                          aid_parms.event = USER_EVENT_POWER; /* Poweron*/
   2011                          HMI_Service_EventSender( &aid_parms );
   2012                      }
   2013                      
   2014                      if (  pPowerHandle_ObjCtrl->get_power_state() == POWER_ON ) 
   2015                      {
   2016                          mProcessCnt++;
   2017          
   2018                          SystemResetType = pPowerHandle_ObjCtrl->getSystemResetType();
   2019          
   2020                          UserParmsAutoPowerDown = pSystemParams->auto_input_detect;
   2021          
   2022                          /* Terminate the auto detection when it is not User mode. Tony140108 */
   2023                          if ( pSystemParams->op_mode != MODE_USER ) 
   2024                          {
   2025                              HMI_AutoInputDetect_TaskCtl(BTASK_SUSPENDED);
   2026                          }
   2027          
   2028                          /* Clean ac on and reset flag */
   2029                          if ( SystemResetType == RCC_FLAG_PORRST || SystemResetType == RCC_FLAG_SFTRST )
   2030                          {
   2031                              pPowerHandle_ObjCtrl->clrSystemResetType();
   2032                          }
   2033          
   2034                          /*If auto power down condition is changed, reset the time stamp */
   2035                          if (LastUserParmsAutoPowerDown!=UserParmsAutoPowerDown )
   2036                          {
   2037                              AID_timeout = AID_TIMEOUT;
   2038                          }
   2039                          
   2040                          /* Update current AutoPower down flag */
   2041                          LastUserParmsAutoPowerDown = UserParmsAutoPowerDown;
   2042          
   2043                          if ( AID_timeout < 1 )
   2044                          {      
   2045                              if ( pSystemParams->auto_input_detect == TRUE )
   2046                              {
   2047                                  aid_parms.event = USER_EVENT_AUTO_INPUT_DETECT_CLEAN; /*Clean Flag*/
   2048                                  HMI_Service_EventSender( &aid_parms );
   2049                                  if (  pPowerHandle_ObjCtrl->get_power_state() == POWER_ON )
   2050                                  {
   2051                                      aid_parms.event = USER_EVENT_POWER; /* Powerdown*/
   2052                                  }
   2053                                  HMI_Service_EventSender( &aid_parms );
   2054                                  TRACE_DEBUG((0, "  Auto detection 15 mins auto power down   !! ")); 
   2055                                  AID_timeout = AID_TIMEOUT;
   2056                                  HMI_AutoInputDetect_TaskCtl(BTASK_SUSPENDED);
   2057                              }
   2058                              else
   2059                              {
   2060                                  AID_timeout = AID_TIMEOUT;
   2061                                  TRACE_DEBUG((0, "  Auto detection 15 mins reset   !! "));
   2062                              }
   2063                          }
   2064                          else
   2065                          {
   2066                              AID_timeout --;
   2067                              //TRACE_DEBUG((0, "  AID_timeout =%X ",AID_timeout));
   2068                          }
   2069          
   2070                          switch( pSystemParams->input_src ) 
   2071                          {
   2072                              case AUDIO_SOURCE_AUX1:
   2073                              case AUDIO_SOURCE_AUX2:
   2074                              {
   2075                                  SignalAvaliableThrehold = AnalogThrehold;
   2076                              }
   2077                              break;
   2078          
   2079                              case AUDIO_SOURCE_COAXIAL:
   2080                              case AUDIO_SOURCE_OPTICAL:
   2081                              {
   2082                                  SignalAvaliableThrehold = DigitalThrehold;
   2083                              }
   2084                              break;
   2085          
   2086                              default:
   2087                              {
   2088                                  aid_parms.event = USER_EVENT_AUTO_INPUT_DETECT_CLEAN; /*Clean Flag*/
   2089                                  HMI_Service_EventSender( &aid_parms );
   2090          
   2091                                  TRACE_DEBUG((0,"Not a Auto Detection source"));
   2092                                  HMI_AutoInputDetect_TaskCtl(BTASK_SUSPENDED);
   2093          
   2094                                  return;
   2095          }
   2096                              break;
   2097                          }
   2098          
   2099                          if ( mProcessCnt > SignalAvaliableThrehold )
   2100                          {
   2101                              if( pASH_ObjCtrl->IsSignalAvailable() == 1)
   2102                              {
   2103                                  mSignalAvaiableCnt++;
   2104                                  if ( mSignalAvaiableCnt >= CheckSignalAvaiableTime)
   2105                                  {
   2106                                      aid_parms.event = USER_EVENT_AUTO_INPUT_DETECT_CLEAN; 
   2107                                      HMI_Service_EventSender( &aid_parms );
   2108                                      
   2109                                      HMI_AutoInputDetect_TaskCtl(BTASK_SUSPENDED);
   2110                                  } 
   2111                              }
   2112                              else
   2113                              {
   2114                                  //TRACE_DEBUG((0,"mProcessCnt=%X,SignalAvaliableThrehold=%X",mProcessCnt,SignalAvaliableThrehold));
   2115                                  mSignalUnavaiableCnt++;
   2116                                  
   2117                                  if (mSignalUnavaiableCnt >= CheckSignalUnAvaiableTime)
   2118                                  {   
   2119                                      mSignalAvaiableCnt = 0;
   2120                                      mSignalUnavaiableCnt = 0;
   2121                                      mProcessCnt = 0;  
   2122                                      
   2123                                      aid_parms.event = USER_EVENT_AUTO_SEL_SRC;/* Switch source*/
   2124                                      HMI_Service_EventSender( &aid_parms );
   2125                                  }
   2126                              }    
   2127                          }
   2128                      }    
   2129                  }
   2130                  vTaskDelay(HMI_AID_TIME_TICK);
   2131              }     
   2132          }
   2133          
   2134          
   2135          void HMI_Service_CreateTask( void )
   2136          {
   2137              if ( xTaskCreate( 
   2138                  HMI_ServiceUser, 
   2139                  ( portCHAR * ) "HMI_SRV_USER", 
   2140                  (STACK_SIZE), 
   2141                  NULL, 
   2142                  tskHMI_SERVICE_PRIORITY, 
   2143                  &mHMISrvClusion.userTaskHandle ) != pdPASS )
   2144              {
   2145                  vTaskDelete( mHMISrvClusion.userTaskHandle );
   2146                  mHMISrvClusion.xOS_ErrId = xOS_TASK_CREATE_FAIL;
   2147              }
   2148          
   2149              mHMISrvClusion.serviceQueue.xQueue = xQueueCreate( HMI_QUEUE_LENGTH,(unsigned portBASE_TYPE )(sizeof(xHMISrvEventParams)/sizeof(uint8)) );
   2150              mHMISrvClusion.serviceQueue.xBlockTime = BLOCK_TIME(0);
   2151              if( mHMISrvClusion.serviceQueue.xQueue == NULL )
   2152              {
   2153                  mHMISrvClusion.xOS_ErrId = xOS_TASK_QUEUE_CREATE_FAIL;
   2154              }
   2155          
   2156              pPowerHandle_ObjCtrl->initialize(); 
   2157              pASH_ObjCtrl->CreateTask( );
   2158              pUDM_ObjCtrl->CreateTask(); 
   2159              //pBTHandle_ObjCtrl->CreateTask();      /* Create BTHandle task */
   2160              //pRFHandle_ObjCtrl->CreateTask();      /* Create RFHandle task */
   2161              //pCCKManage_ObjCtrl->CreateTask();
   2162              //pUSB_MMP_ObjCtrl->CreateTask();
   2163              //USBMusicManager_RegisterSetDemoMode2Timeout(HMI_Service_setDemo2_Timeout); /* register set Demo2 timeout function */
   2164          
   2165              TRACE_DEBUG((0, "EEpromDefaultParams[0] = %d ",EEpromDefaultParams[0]));    /*for code size 232kb */
   2166          
   2167              //HMI_AutoPowerControl_CreateTask();
   2168              //HMI_AutoInputDetect_CreateTask();
   2169          }
   2170          
   2171          static xEventTypeAssort HMI_Service_Event_Assort( xHMIUserEvents cur_events, xHMIUserEvents last_events )
   2172          {
   2173              xEventTypeAssort ret = EVENT_ASSORT_NO_NEED_FIRST_CONFIRM;
   2174          
   2175              switch ( cur_events )
   2176              {
   2177                  case USER_EVENT_SEL_SRC:
   2178                  case USER_EVENT_AUTO_SEL_SRC:
   2179                  {
   2180                      if ( (last_events == USER_EVENT_SEL_SRC) || (last_events == USER_EVENT_AUTO_SEL_SRC))
   2181                      {
   2182                          ret = EVENT_ASSORT_SAME;
   2183                      }
   2184                      else
   2185                      {
   2186                          ret = EVENT_ASSORT_DIFFERENT;
   2187                      }
   2188                  }
   2189                      break;
   2190          
   2191                  case USER_EVENT_BASS_UP:
   2192                  case USER_EVENT_BASS_DN:
   2193                  {
   2194                      if ( (last_events == USER_EVENT_BASS_UP ) || (last_events == USER_EVENT_BASS_DN) )
   2195                      {
   2196                          ret = EVENT_ASSORT_SAME;
   2197                      }
   2198                      else
   2199                      {
   2200                          ret = EVENT_ASSORT_DIFFERENT;
   2201                      }
   2202                  }
   2203                      break;
   2204          
   2205                  case USER_EVENT_TREBLE_UP:
   2206                  case USER_EVENT_TREBLE_DN:
   2207                  {
   2208                      if ( (last_events == USER_EVENT_TREBLE_UP ) || (last_events == USER_EVENT_TREBLE_DN) )
   2209                      {
   2210                          ret = EVENT_ASSORT_SAME;
   2211                      }
   2212                      else
   2213                      {
   2214                          ret = EVENT_ASSORT_DIFFERENT;
   2215                      }
   2216                  }
   2217                  break;
   2218          
   2219                  case USER_EVENT_SUB_UP:
   2220                  case USER_EVENT_SUB_DN:
   2221                  {
   2222                      if ( (last_events == USER_EVENT_SUB_UP ) || (last_events == USER_EVENT_SUB_DN) )
   2223                      {
   2224                          ret = EVENT_ASSORT_SAME;
   2225                      }
   2226                      else
   2227                      {
   2228                          ret = EVENT_ASSORT_DIFFERENT;
   2229                      }
   2230                  }
   2231                      break;
   2232          
   2233                  case USER_EVENT_CENTER_UP:
   2234                  case USER_EVENT_CENTER_DN:
   2235                  {
   2236                      if ( (last_events == USER_EVENT_CENTER_UP ) || (last_events == USER_EVENT_CENTER_DN) )
   2237                      {
   2238                          ret = EVENT_ASSORT_SAME;
   2239                      }
   2240                      else
   2241                      {
   2242                          ret = EVENT_ASSORT_DIFFERENT;
   2243                      }
   2244                  }
   2245                      break;
   2246          
   2247                  case USER_EVENT_REAR_UP:
   2248                  case USER_EVENT_REAR_DN:
   2249                  {
   2250                      if ( (last_events == USER_EVENT_REAR_UP ) || (last_events == USER_EVENT_REAR_DN) )
   2251                      {
   2252                          ret = EVENT_ASSORT_SAME;
   2253                      }
   2254                      else
   2255                      {
   2256                          ret = EVENT_ASSORT_DIFFERENT;
   2257                      }
   2258                  }
   2259                      break;
   2260          
   2261                  case USER_EVENT_AV_DELAY_UP:
   2262                  case USER_EVENT_AV_DELAY_DN:
   2263                  {
   2264                      if ( (last_events == USER_EVENT_AV_DELAY_UP ) || (last_events == USER_EVENT_AV_DELAY_DN) )
   2265                      {
   2266                          ret = EVENT_ASSORT_SAME;
   2267                      }
   2268                      else
   2269                      {
   2270                          ret = EVENT_ASSORT_DIFFERENT;
   2271                      }
   2272                  }
   2273                      break;
   2274          
   2275                  case USER_EVENT_BALANCE_UP:
   2276                  case USER_EVENT_BALANCE_DN:
   2277                  {
   2278                      if ( (last_events == USER_EVENT_BALANCE_UP ) || (last_events == USER_EVENT_BALANCE_DN) )
   2279                      {
   2280                          ret = EVENT_ASSORT_SAME;
   2281                      }
   2282                      else
   2283                      {
   2284                          ret = EVENT_ASSORT_DIFFERENT;
   2285                      }
   2286                  }
   2287                      break;
   2288          
   2289                  default:
   2290                      ret = EVENT_ASSORT_NO_NEED_FIRST_CONFIRM;
   2291              }
   2292          
   2293              return ret;
   2294          }
   2295          
   2296          static xHMISystemParams HMI_Service_getSystemParams( void )
   2297          {
   2298              return mSystemParams;
   2299          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  HMI_AutoPowerControl_CreateTask
              0 -> vTaskDelete
              0 -> vTaskSuspend
             24 -> xTaskGenericCreate
       32  HMI_AutoPowerControl_Task
             32 -- Indirect call
             32 -> Debug_printDebug
             32 -> HMI_Service_EventSender
             32 -> HMI_Service_setDemo1n3_SysParams
             32 -> vTaskDelay
        8  HMI_FMD_CommandHandle
              8 -- Indirect call
              0 -> __aeabi_memcpy
       24  HMI_ServiceUser
             24 -- Indirect call
             24 -> Debug_printError
             24 -> HMI_Service_handleCommand
             24 -> uxQueueMessagesWaiting
             24 -> vTaskDelay
             24 -> xPortGetFreeHeapSize
             24 -> xQueueGenericReceive
       24  HMI_Service_CreateTask
             24 -- Indirect call
              0 -> Debug_printDebug
             24 -> vTaskDelete
             24 -> xQueueGenericCreate
             24 -> xTaskGenericCreate
       16  HMI_Service_EventSender
             16 -> Debug_printError
             16 -> xQueueGenericSend
       24  HMI_Service_checkEventTimoutOrFirstPressed
             24 -- Indirect call
             24 -> xTaskGetTickCount
        0  HMI_Service_getSystemParams
              0 -> __aeabi_memcpy
       16  HMI_Service_handleCommand
             16 -- Indirect call
              0 -> Debug_printDebug
              0 -> Debug_printError
             16 -> HMI_Service_checkEventTimoutOrFirstPressed
              0 -> HMI_Service_sendCommand
        0  HMI_Service_rstSystemParams
       48  HMI_Service_sendCommand
             48 -- Indirect call
             48 -> Debug_printDebug
             48 -> Debug_printError
             48 -> HMI_Service_EventSender
             48 -> HMI_Service_rstSystemParams
             48 -> HMI_Service_setDemo1n3_SysParams
        0  HMI_Service_setDemo1n3_SysParams
        0  HMI_Service_setSystemParams
              0 -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      44  ?<Constant " HMI_InstrSender rece...">
      40  ?<Constant " HMI_InstrSender send...">
      16  ?<Constant "APD COUNT = %d">
      32  ?<Constant "EEpromDefaultParams[0...">
      36  ?<Constant "EVENT - First Pressed...">
      32  ?<Constant "HMI Service sender er...">
       8  ?<Constant "HMI_APC">
      16  ?<Constant "HMI_SRV_USER">
      16  ?<Constant "MODE - DEMO 1 ">
      16  ?<Constant "MODE - DEMO 2 ">
      16  ?<Constant "MODE - DEMO 3 ">
      16  ?<Constant "MODE - FACTORY ">
      16  ?<Constant "MODE - USER ">
      44  ?<Constant "System power has not ...">
      20  ?<Constant "Unsupported event ">
       4  ?<Constant {6, 100}>
       4  ?<Constant {8, 100}>
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_10
       4  ??DataTable33_11
       4  ??DataTable33_12
       4  ??DataTable33_13
       4  ??DataTable33_14
       4  ??DataTable33_2
       4  ??DataTable33_3
       4  ??DataTable33_4
       4  ??DataTable33_5
       4  ??DataTable33_6
       4  ??DataTable33_7
       4  ??DataTable33_8
       4  ??DataTable33_9
       8  ?Subroutine0
      10  ?Subroutine1
       8  ?Subroutine10
      12  ?Subroutine11
       8  ?Subroutine12
      10  ?Subroutine13
      10  ?Subroutine14
       8  ?Subroutine2
       8  ?Subroutine3
       6  ?Subroutine4
      12  ?Subroutine5
      14  ?Subroutine6
      14  ?Subroutine7
      10  ?Subroutine8
      16  ?Subroutine9
      58  HMI_AutoPowerControl_CreateTask
     164  HMI_AutoPowerControl_Task
      12  HMI_FACTORY_OBJ
      74  HMI_FMD_CommandHandle
      16  HMI_SRV_OBJ
     120  HMI_ServiceUser
     114  HMI_Service_CreateTask
      62  HMI_Service_EventSender
     196  HMI_Service_checkEventTimoutOrFirstPressed
       4  HMI_Service_getSystemParams
     240  HMI_Service_handleCommand
      74  HMI_Service_rstSystemParams
    1670  HMI_Service_sendCommand
      92  HMI_Service_setDemo1n3_SysParams
      10  HMI_Service_setSystemParams
       8  lastEvent
          xTimeTick
      32  mHMISrvClusion
      36  mSystemParams
          master_gain_limit
          mBTHandleCommand
          timeout
          free_heap_size
       4  pHFS_ObjCtrl
       4  pHS_ObjCtrl
       4  pSystemParams

 
    40 bytes in section .bss
    48 bytes in section .data
    28 bytes in section .rodata
 3 468 bytes in section .text
 
 3 468 bytes of CODE  memory
    28 bytes of CONST memory
    88 bytes of DATA  memory

Errors: none
Warnings: 4

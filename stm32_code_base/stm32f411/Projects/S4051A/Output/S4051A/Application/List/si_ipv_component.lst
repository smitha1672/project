###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:25:11 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\sii953x\component\ipv\si_ipv_co #
#                    mponent.c                                                #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\sii953x\component\ipv\si_ipv_co #
#                    mponent.c -D S4051A -D DEBUG -D FREE_RTOS -D             #
#                    STM32F40_41xxx -D USE_STM324xG_EVAL -D                   #
#                    USE_STDPERIPH_DRIVER -D __ARM_CORTEX_MX__ -D             #
#                    IAR_ARM_CM4F -D USE_USB_OTG_FS -lcN                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\ #
#                    DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applica #
#                    tion\Obj\ --debug --endian=little --cpu=Cortex-M4 -e     #
#                    --fpu=VFPv4_sp --dlib_config "C:\Program Files           #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\si_ipv_component.lst                                  #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\si_ipv_component.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Libraries\AMT_Drivers\sii953x\component\ipv\si_ipv_component.c
      1          //***************************************************************************
      2          //!file     si_ipv_component.c
      3          //!brief    Silicon Image InstaPrevue Component.
      4          //
      5          // No part of this work may be reproduced, modified, distributed,
      6          // transmitted, transcribed, or translated into any language or computer
      7          // format, in any form or by any means without written permission of
      8          // Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
      9          //
     10          // Copyright 2002-2012, Silicon Image, Inc.  All rights reserved.
     11          //***************************************************************************/
     12          
     13          #include "string.h"
     14          #include "si_common.h"
     15          #include "si_ipv_internal.h"
     16          #include "si_drv_ipv_internal.h"
     17          
     18          IpvInstanceData_t ipvInstance[SII_NUM_IPV];
     19          IpvInstanceData_t *pIpv = &ipvInstance[0];
     20          
     21          //-------------------------------------------------------------------------------------------------
     22          //! @brief      Initialize the IPV component.
     23          //!
     24          //! @return     SiiResultCodes_t
     25          //-------------------------------------------------------------------------------------------------
     26          bool_t SiiIpvInitialize ( void )
     27          {
     28              int_t i;
     29          
     30              // Initialize the internal data structures
     31              memset( pIpv, 0, sizeof( IpvInstanceData_t ));
     32          
     33              pIpv->currentTheme          = SiiIpvLEFT_MIDDLE;    // Set default theme
     34              pIpv->lastTheme             = SiiIpvThemeCount;     // Force default theme to be loaded
     35              pIpv->alphaSteppingEnabled  = true;
     36          
     37              pIpv->allowBounce           = true;
     38              pIpv->bounceStep            = SII_IPV_BOUNCE_AMPL;
     39          
     40              for(i = 0; i < IPV_WINDOW_COUNT; i++)
     41              {
     42                  siiIpvAlphaMax[i] = 0;
     43                  siiIpvAlphaStep[i] = 4;
     44              }
     45          
     46              return( SiiDrvIpvInitialize());
     47          }
     48          
     49          //-------------------------------------------------------------------------------------------------
     50          //! @brief      Returns the result of the last call to a IPV component function.
     51          //!
     52          //! @return     true - success  false - some failure occurred
     53          //-------------------------------------------------------------------------------------------------
     54          SiiIpvResultCodes_t SiiIpvGetLastResult( void )
     55          {
     56              return( pIpv->lastResultCode );
     57          }
     58          
     59          //-------------------------------------------------------------------------------------------------
     60          //! @brief      Select the basic operating mode for InstaPrevue.
     61          //!
     62          //! @param[in]  mode -  SiiIpvModeALL:      Always display all 5 ports
     63          //!                     SiiIpvModeACTIVE:   Display only active ports
     64          //!                     SiiIpvModeSELECT:   Display only RP selected port (PIP mode)
     65          //
     66          //! @comment    IPV must be disabled when this function is called.
     67          //-------------------------------------------------------------------------------------------------
     68          void SiiIpvModeSet ( SiiIpvMode_t mode )
     69          {
     70              // For now, everything is done in the driver.
     71              SiiDrvIpvModeSet( mode );
     72              pIpv->lastResultCode = (SiiIpvResultCodes_t)SiiDrvIpvGetLastResult();
     73          }
     74          
     75          //-------------------------------------------------------------------------------------------------
     76          //! @brief      Start or stop the IPV engine and display.
     77          //!
     78          //! @param[in]  enable
     79          //-------------------------------------------------------------------------------------------------
     80          bool_t SiiIpvEnable ( bool_t isEnable )
     81          {
     82              if (( isEnable == true ) && pIpv->alphaSteppingEnabled )
     83              {
     84                  pIpv->isAlphaStepping = true;
     85                  pIpv->alphaStepRemainingDelay = pIpv->windowSpecs.alphaStepSpeedMs;
     86                  memset( &pIpv->alphaCurrentValue[0], 31, sizeof( pIpv->alphaCurrentValue));
     87                  SiiDrvIpvWindowAlphaSet( -1, 31 );
     88              }
     89              SiiDrvIpvEnable( isEnable );
     90              pIpv->lastResultCode = (SiiIpvResultCodes_t)SiiDrvIpvGetLastResult();
     91              if ( pIpv->lastResultCode == SII_IPV_SUCCESS )
     92              {
     93                  pIpv->isEnabled = isEnable;
     94              }
     95          
     96              return( true );
     97          }
     98          
     99          
    100          //-------------------------------------------------------------------------------------------------
    101          //! @brief      Refreshes IPV windows when AVI data changes without affecting input video clock.
    102          //-------------------------------------------------------------------------------------------------
    103          void SiiIpvRefresh(void)
    104          {
    105              if (pIpv->isEnabled)
    106              {
    107                  SiiDrvIpvDownsamplerReset();
    108              }
    109          }
    110          
    111          //-------------------------------------------------------------------------------------------------
    112          //! @brief      Move highlight to requested InstaPrevue window.  If not active, increment until an
    113          //!             active input is found.  Returns the actual highlighted window index.
    114          //! @param[in]  highlightIndex - index of a window to highlight,
    115          //! @param[in]  isForward      - direction of a search for an active window.
    116          //-------------------------------------------------------------------------------------------------
    117          int_t SiiIpvHighlightWindow ( int_t highlightIndex, bool_t isForward )
    118          {
    119              int_t   i;
    120              uint_t  activeMask;
    121          
    122              // Get active window mask.  If none are active, we'll end up leaving
    123              // without a highlighted window
    124              activeMask = SiiDrvIpvActiveWindowsGet();
    125          //    if ( activeMask == 0 )
    126          //    {
    127          //        highlightIndex = -1;
    128          //    }
    129          
    130              // Only look for a highlighted window if asked (highlightIndex != -1).
    131              if ( highlightIndex != -1 )
    132              {
    133                  if (( activeMask & ( 1 << highlightIndex)) == 0 )
    134                  {
    135                      for ( i = 0; i < IPV_WINDOW_COUNT; i++ )
    136                      {
    137                          if ( activeMask & ( 1 << highlightIndex))
    138                          {
    139                              break;
    140                          }
    141          
    142                          if(isForward)
    143                          {
    144                              highlightIndex++;
    145                              if ( highlightIndex >= IPV_WINDOW_COUNT )
    146                              {
    147                                  highlightIndex = 0;
    148                              }
    149                          }
    150                          else
    151                          {
    152                              if ( highlightIndex == 0 )
    153                              {
    154                                  highlightIndex = IPV_WINDOW_COUNT;
    155                              }
    156                              else
    157                              {
    158                                  highlightIndex--;
    159                              }
    160                          }
    161                      }
    162                  }
    163              }
    164              SiiIpvHighlightSet( highlightIndex );
    165              return( highlightIndex );
    166          }
    167          
    168          //-------------------------------------------------------------------------------------------------
    169          //! @brief      Returns the port number of the highlighted window (not
    170          //!             necessarily corresponding to the prevue window index).
    171          //! @param[in]
    172          //-------------------------------------------------------------------------------------------------
    173          int_t SiiIpvHighlightPortGet ( int_t currentPortIndex, int_t highlightIndex )
    174          {
    175              // If nothing is highlighted, don't change port selection
    176              if(highlightIndex == -1)
    177              {
    178                  return currentPortIndex;
    179              }
    180          
    181              // The selected port is skipped in the prevue window index.
    182              if ( highlightIndex >= currentPortIndex )
    183              {
    184                  // The highlight actually is pointing to the next highest port.
    185                  highlightIndex++;
    186              }
    187          
    188              return( highlightIndex );
    189          }
    190          
    191          //-------------------------------------------------------------------------------------------------
    192          //! @brief      Determine the X/Y Coordinates and sizes of the preview windows based on the
    193          //!             current resolution.
    194          //-------------------------------------------------------------------------------------------------
    195          static bool_t UpdateWindowSpecs ( void )
    196          {
    197              SiiIpvSizeSet_t     sizeIndex;
    198              SiiWinCoords_t      mpResolution, upperLeft, increment = {0,0};
    199              int_t               i, totalWidth, totalHeight;
    200              bool_t              isInterlaced;
    201          #if DETECT_ASPECT_RATIO
    202              bool_t 				pictureAspectRatio;
    203          #endif
    204              pIpv->lastResultCode = SII_IPV_SUCCESS;
    205              if ( !SiiIpvCbVideoInfoGet( &mpResolution.x, &mpResolution.y, &isInterlaced))
    206              {
    207                  DEBUG_PRINT( MSG_ERR, "IPV could not obtain res info for selected port\n");
    208                  mpResolution.x = 640;
    209                  mpResolution.y = 480;
    210              }
    211          
    212              // Cap resolution @ 1920x1080
    213              if (( mpResolution.x > 1920  ) && ( mpResolution.y > 1080  ))
    214              {
    215                  DEBUG_PRINT( MSG_ERR, "IPV Detected > 1920x1080 res: %dx%d, forcing to 1920x1080\n", mpResolution.x, mpResolution.y );
    216                  mpResolution.x = 1920;
    217                  mpResolution.y = 1080;
    218              }
    219          
    220              // If nothing's changed, get out now.
    221              if (( pIpv->currentResolution.x == mpResolution.x   ) &&
    222                  ( pIpv->currentResolution.y == mpResolution.y   ) &&
    223                  ( pIpv->currentIsInterlaced == isInterlaced     ) &&
    224                  ( pIpv->currentTheme        == pIpv->lastTheme ))
    225              {
    226                  return( false );    // No need to change
    227              }
    228              pIpv->currentResolution.x   = mpResolution.x;
    229              pIpv->currentResolution.y   = mpResolution.y;
    230              pIpv->currentIsInterlaced   = isInterlaced;
    231              pIpv->lastTheme             = pIpv->currentTheme;
    232          
    233              DEBUG_PRINT( MSG_DBG, "Windows placed for %dx%d%c resolution\n", mpResolution.x, mpResolution.y, isInterlaced ? 'i' : 'p' );
    234          
    235              // Convert the current main window resolution into an index
    236              for ( sizeIndex = 0; sizeIndex < SiiIpvSizeCount; sizeIndex++ )
    237              {
    238                  if ( mpResolution.x <= siiMainWindowSizes[ sizeIndex].x )
    239                  {
    240                      break;
    241                  }
    242              }
    243          
    244              // Protection
    245              if (sizeIndex >= SiiIpvSizeCount)
    246              {
    247                  sizeIndex = SiiIpvSize1920x1080;
    248              }
    249          
    250              // Pre-calculate some info using the widest aspect ratio
    251              totalWidth =    ((IPV_WINDOW_COUNT      * siiIpvWinSizes[ sizeIndex].width16x9) +
    252                              ((IPV_WINDOW_COUNT - 1) * siiIpvWinSizes[ sizeIndex].horizSpacer));
    253              totalHeight =   ((IPV_WINDOW_COUNT      * siiIpvWinSizes[ sizeIndex].height) +
    254                              ((IPV_WINDOW_COUNT - 1) * siiIpvWinSizes[ sizeIndex].vertSpacer));
    255              DEBUG_PRINT( MSG_DBG, "Total Width: %d  Total Height: %d SizeIndex: %d\n", totalWidth, totalHeight, sizeIndex );
    256              if (( totalWidth > mpResolution.x) || ( totalHeight > mpResolution.y ))
    257              {
    258                  pIpv->lastResultCode = SII_IPV_ERR_SCREEN_RES_TOO_SMALL;
    259                  DEBUG_PRINT( MSG_ERR, "**** SII_IPV_ERR_SCREEN_RES_TOO_SMALL ****\n" );
    260              }
    261          
    262              // Re-calculate the window positioning for the current theme
    263              switch ( pIpv->currentTheme  )
    264              {
    265                  case SiiIpvTOP_CENTER:
    266                      upperLeft.x = (mpResolution.x - totalWidth) / 2;
    267                      upperLeft.y = (siiIpvWinSizes[ sizeIndex].vertSpacer) & ~0x07;  // Multiple of 8 for best performance
    268                      increment.x = siiIpvWinSizes[ sizeIndex].width16x9 + siiIpvWinSizes[ sizeIndex].horizSpacer;
    269                      increment.y = 0;
    270                      pIpv->highLightHoriz = 0;
    271                      pIpv->highLightVert = siiIpvWinSizes[ sizeIndex].height;
    272                      break;
    273          
    274                  case SiiIpvBOTTOM_CENTER:
    275                      upperLeft.x = (mpResolution.x - totalWidth) / 2;
    276                      upperLeft.y = mpResolution.y - (siiIpvWinSizes[ sizeIndex].height + (siiIpvWinSizes[ sizeIndex].vertSpacer)) - 1;// * 2)) - 1;
    277                      increment.x = siiIpvWinSizes[ sizeIndex].width16x9 + siiIpvWinSizes[ sizeIndex].horizSpacer;
    278                      increment.y = 0;
    279                      pIpv->highLightHoriz = 0;
    280                      pIpv->highLightVert = -siiIpvWinSizes[ sizeIndex].height;
    281                      break;
    282          
    283                  case SiiIpvLEFT_MIDDLE:
    284                      upperLeft.x = siiIpvWinSizes[ sizeIndex].horizSpacer * 2;
    285                      upperLeft.y = ((mpResolution.y - totalHeight) / 2) & ~0x07; // Multiple of 8 for best performance
    286                      increment.x = 0;
    287                      increment.y = siiIpvWinSizes[ sizeIndex].height + siiIpvWinSizes[ sizeIndex].vertSpacer;
    288                      pIpv->highLightHoriz = siiIpvWinSizes[ sizeIndex].width16x9;
    289                      pIpv->highLightVert = 0;
    290                      break;
    291          
    292                  case SiiIpvRIGHT_MIDDLE:
    293                      upperLeft.x = mpResolution.x - (siiIpvWinSizes[ sizeIndex].width16x9 + (siiIpvWinSizes[ sizeIndex].horizSpacer * 2));
    294                      upperLeft.y = (mpResolution.y - totalHeight) / 2;
    295                      increment.x = 0;
    296                      increment.y = siiIpvWinSizes[ sizeIndex].height + siiIpvWinSizes[ sizeIndex].vertSpacer;
    297                      pIpv->highLightHoriz = -siiIpvWinSizes[ sizeIndex].width16x9;
    298                      pIpv->highLightVert = 0;
    299                      break;
    300          
    301                  case SiiIpvPentagram:
    302                      upperLeft.x = siiIpvWinSizes[ sizeIndex].width16x9 / 2;
    303                      upperLeft.y = siiIpvWinSizes[ sizeIndex].height / 2;
    304                      pIpv->highLightVert = 0;
    305                      pIpv->highLightHoriz = 0;
    306                      break;
    307          
    308                  case SiiIpvPIP:
    309                      // Use the position specified by the PIP window data.
    310                      upperLeft.x = siiIpvPipCoords[ sizeIndex].x;
    311                      upperLeft.y = siiIpvPipCoords[ sizeIndex].y;
    312          
    313                      // All windows must be programmed to the same location.
    314                      increment.x = 0;
    315                      increment.y = 0;
    316          
    317                      // Set size independent of the normal method (only needs info from one window size)
    318                      pIpv->windowSpecs.width16x9[0]  = siiIpvPipSizes[ sizeIndex].width16x9;
    319                      pIpv->windowSpecs.width4x3[0]   = siiIpvPipSizes[ sizeIndex].width4x3;
    320                      pIpv->windowSpecs.height[0]     = siiIpvPipSizes[ sizeIndex].height;
    321                      sizeIndex = SiiIpvSizePIP;
    322                      pIpv->highLightHoriz = 0;
    323                      pIpv->highLightVert = 0;
    324                      break;
    325          
    326                  default:
    327                      upperLeft.x = 0;
    328                      upperLeft.y = 0;
    329                      increment.x = 0;
    330                      increment.y = 0;
    331                      break;
    332              }
    333          
    334          
    335              // Coordinates for all of the windows
    336              if (pIpv->currentTheme != SiiIpvPentagram)
    337              {
    338                  if ( isInterlaced )     // Must consider interlace format when calculating Y coordinate
    339                  {
    340                      upperLeft.y /= 2;
    341                      increment.y /= 2;
    342                  }
    343          #if DETECT_ASPECT_RATIO
    344                  pictureAspectRatio =  SiiDrvSwitchPictAspectRatioGet();
    345          #endif
    346                  for (i = 0; i < IPV_WINDOW_COUNT; i++)
    347                  {
    348                      pIpv->windowSpecs.coords[i].x = upperLeft.x & ~1; // Ensure even X coord in case it is YCbCr 4:2:2
    349                      pIpv->windowSpecs.coords[i].y = upperLeft.y;
    350          
    351                      if (sizeIndex != SiiIpvSizePIP)
    352                      {
    353                          pIpv->windowSpecs.width16x9[i] = siiIpvWinSizes[sizeIndex].width16x9;
    354          #if DETECT_ASPECT_RATIO
    355                          if(pictureAspectRatio == PICTURE_ASPECT16_9)
    356                          {
    357                              pIpv->windowSpecs.width4x3[i] = siiIpvWinSizes[sizeIndex].width16x9;
    358                          }
    359                          else
    360          #endif
    361                          {
    362                              pIpv->windowSpecs.width4x3[i] = siiIpvWinSizes[sizeIndex].width16x9;     //Bug 31705 - Huawei Mobile is delivering 1080p/24Hz video but Melbourne is detecting as 480p resolution
    363                          }
    364          
    365                          pIpv->windowSpecs.height[i] = siiIpvWinSizes[sizeIndex].height;
    366                          DEBUG_PRINT(
    367                                  MSG_DBG, "%d) %4d/%dx%d @ %dx%d\n",
    368                                  i,
    369                                  pIpv->windowSpecs.width16x9[i], pIpv->windowSpecs.width4x3[i], pIpv->windowSpecs.height[i],
    370                                  pIpv->windowSpecs.coords[i].x, pIpv->windowSpecs.coords[i].y
    371                          );
    372                      }
    373                      else if (i == 0) // Only print PIP location once
    374                      {
    375                          DEBUG_PRINT( MSG_DBG, "PIP) %4dx%4d\n", pIpv->windowSpecs.coords[0].x, pIpv->windowSpecs.coords[0].y );
    376                      }
    377          
    378                      upperLeft.x += increment.x;
    379                      upperLeft.y += increment.y;
    380                  }
    381              }
    382              else
    383              {
    384                  int32_t radius = (siiIpvRad[0] * mpResolution.y) / siiIpvRad[1] / 2;
    385          
    386          #if DETECT_ASPECT_RATIO
    387                  pictureAspectRatio =  SiiDrvSwitchPictAspectRatioGet();
    388          #endif
    389                  for (i = 0; i < IPV_WINDOW_COUNT; i++)
    390                  {
    391                      pIpv->windowSpecs.coords[i].x = siiIpvCc[i] * radius / 10000 + mpResolution.x / 2 - upperLeft.x;
    392                      pIpv->windowSpecs.coords[i].y = siiIpvCs[i] * radius / 10000 + mpResolution.y / 2 - upperLeft.y;
    393                      // Compensate for interlaced
    394                      if (isInterlaced)
    395                      {
    396                          pIpv->windowSpecs.coords[i].y /= 2;
    397                      }
    398          
    399                      pIpv->windowSpecs.width16x9[i] = siiIpvWinSizes[sizeIndex].width16x9;
    400          #if DETECT_ASPECT_RATIO
    401                      if(pictureAspectRatio == PICTURE_ASPECT16_9)
    402                      {
    403                          pIpv->windowSpecs.width4x3[i] = siiIpvWinSizes[sizeIndex].width16x9;
    404                      }
    405                      else
    406          #endif
    407                      {
    408                          pIpv->windowSpecs.width4x3[i] = siiIpvWinSizes[sizeIndex].width4x3;
    409                      }
    410                      pIpv->windowSpecs.height[i] = siiIpvWinSizes[sizeIndex].height;
    411                  }
    412              }
    413          
    414              pIpv->windowSpecs.heightIsInterlaced = isInterlaced;
    415              return( true ); // Window specs have been updated
    416          }
    417          
    418          //-------------------------------------------------------------------------------------------------
    419          //! @brief      Enable highlighting for passed preview window.  Removes previous highlight if any.
    420          //! @param[in]  windowIndex:  0 - IPV_WINDOW_COUNT - Window to highlight
    421          //!                          -1 - Remove all highlighting.
    422          //-------------------------------------------------------------------------------------------------
    423          void SiiIpvHighlightSet( int_t windowIndex )
    424          {
    425              SiiWinCoords_t hl;
    426              int_t i, j, k;
    427              int_t step;
    428              int_t x[IPV_WINDOW_COUNT];
    429              int_t y[IPV_WINDOW_COUNT];
    430          
    431              if(pIpv->currentTheme == SiiIpvPentagram)
    432              {
    433                  if ( pIpv->highLightIndex != -1 && (pIpv->highLightIndex != windowIndex))
    434                  {
    435                      SiiDrvIpvAnimationEnable(true);
    436                      // Store current coordinates
    437                      for (k = 0; k < IPV_WINDOW_COUNT; k++)
    438                      {
    439                          x[k] = pIpv->windowSpecs.coords[k].x;
    440                          y[k] = pIpv->windowSpecs.coords[k].y;
    441                      }
    442          
    443                      // Shift coordinates
    444                      i = windowIndex;
    445                      j = pIpv->highLightIndex;
    446          
    447                      step = ((i - j) > 0) ? 1 : -1;
    448          
    449                      for (k = 0; k < IPV_WINDOW_COUNT; k++)
    450                      {
    451          
    452                          pIpv->windowSpecs.coords[i].x = x[j];
    453                          pIpv->windowSpecs.coords[i].y = y[j];
    454          
    455                          j += step;
    456                          // modulo logic for j
    457                          if (j < 0)
    458                              j += IPV_WINDOW_COUNT;
    459                          else if (j >= IPV_WINDOW_COUNT)
    460                              j -= IPV_WINDOW_COUNT;
    461          
    462                          i += step;
    463                          // modulo logic for i
    464                          if (i < 0)
    465                              i += IPV_WINDOW_COUNT;
    466                          else if (i >= IPV_WINDOW_COUNT)
    467                              i -= IPV_WINDOW_COUNT;
    468                      }
    469          
    470                      pIpv->highLightIndex = windowIndex;
    471          
    472                      // Do move
    473                      for (i = 0; i < IPV_WINDOW_COUNT; i++)
    474                      {
    475                          hl.x = pIpv->windowSpecs.coords[i].x;
    476                          hl.y = pIpv->windowSpecs.coords[i].y;
    477                          SiiDrvIpvWindowCoordSet( i, hl.x, hl.y);
    478                      }
    479                  }
    480              }
    481              else
    482              {
    483                  // Remove old highlight, if any...
    484                  if ( pIpv->highLightIndex != -1 )
    485                  {
    486                      // Animation will work without glitches if there is no horizontal overlapping only,
    487                      // so disable animation for top and bottom horizontal arrangements
    488                      SiiDrvIpvAnimationEnable( (pIpv->currentTheme == SiiIpvLEFT_MIDDLE) || (pIpv->currentTheme == SiiIpvRIGHT_MIDDLE));
    489                      SiiDrvIpvWindowCoordSet(
    490                          pIpv->highLightIndex,
    491                          pIpv->windowSpecs.coords[pIpv->highLightIndex].x,
    492                          pIpv->windowSpecs.coords[pIpv->highLightIndex].y);
    493                  }
    494                  // Apply new highlight, if any...
    495                  pIpv->highLightIndex = windowIndex;
    496                  if (( pIpv->highLightIndex != -1 ) && pIpv->highLightEnabled )
    497                  {
    498                      hl.x = pIpv->windowSpecs.coords[pIpv->highLightIndex].x + pIpv->highLightHoriz;
    499                      hl.y = pIpv->windowSpecs.coords[pIpv->highLightIndex].y;
    500          
    501                      // Compensate for interlaced.
    502                      if ( pIpv->currentIsInterlaced )
    503                      {
    504                          hl.y = pIpv->windowSpecs.coords[pIpv->highLightIndex].y + (pIpv->highLightVert / 2);
    505                      }
    506                      else
    507                      {
    508                          hl.y = pIpv->windowSpecs.coords[pIpv->highLightIndex].y + pIpv->highLightVert;
    509                      }
    510                      SiiDrvIpvWindowCoordSet( pIpv->highLightIndex, hl.x, hl.y);
    511                      // Trigger bouncing effect start
    512                      if (pIpv->currentTheme != SiiIpvPIP)
    513                      {
    514                          pIpv->isBounceEffect =
    515                              (((pIpv->currentTheme == SiiIpvLEFT_MIDDLE) ||
    516                              (pIpv->currentTheme == SiiIpvRIGHT_MIDDLE)) &&
    517                              pIpv->allowBounce );
    518                          // Set bounce step depending on initial bouncing direction
    519                          if (pIpv->isBounceEffect)
    520                          {
    521                              switch(pIpv->currentTheme)
    522                              {
    523                                  case SiiIpvRIGHT_MIDDLE:
    524                                      pIpv->bounceStep =  SII_IPV_BOUNCE_AMPL;
    525                                      break;
    526                                  case SiiIpvLEFT_MIDDLE:
    527                                      pIpv->bounceStep =  -SII_IPV_BOUNCE_AMPL;
    528                                      break;
    529                                  default:
    530                                      break;
    531                              }
    532                          }
    533                      }
    534                  }
    535                  else
    536                  {
    537                      // disable bouncing if selection is unavailable
    538                      pIpv->isBounceEffect = false;
    539                  }
    540              }
    541          }
    542          
    543          //-------------------------------------------------------------------------------------------------
    544          //! @brief      Load the passed border color arrays into instance (but not hardware).
    545          //! @param[in]  pNewColors
    546          //-------------------------------------------------------------------------------------------------
    547          bool_t SiiIpvWindowSpecsGet ( int window, SiiIpvSingleWindowSpecs_t *pSpecs )
    548          {
    549              SiiIpvSingleWindowSpecs_t specs;
    550          
    551              if ( window < IPV_WINDOW_COUNT )
    552              {
    553                  pIpv->lastResultCode = SII_IPV_SUCCESS;
    554          
    555                  specs.coords.x  = pIpv->windowSpecs.coords[ window].x;
    556                  specs.coords.y  = (pIpv->windowSpecs.heightIsInterlaced) ?
    557                      pIpv->windowSpecs.coords[ window].y * 2 :
    558                      pIpv->windowSpecs.coords[ window].y;
    559          
    560                  specs.height    = pIpv->windowSpecs.height[ window];
    561                  specs.width16x9 = pIpv->windowSpecs.width16x9[ window];
    562                  specs.width4x3  = pIpv->windowSpecs.width4x3[ window];
    563          
    564                  memcpy( pSpecs, &specs, sizeof(SiiIpvSingleWindowSpecs_t));
    565              }
    566              else
    567              {
    568                  pIpv->lastResultCode = SII_IPV_ERR_INVALID_PARAMETER;
    569          
    570              }
    571          
    572              return( pIpv->lastResultCode == SII_IPV_SUCCESS );
    573          }
    574          
    575          //-------------------------------------------------------------------------------------------------
    576          //! @brief      Enable or disable the preview window highlighting
    577          //! @param[in]  isEnable
    578          //! @return     previous enable state
    579          //-------------------------------------------------------------------------------------------------
    580          bool_t SiiIpvHighlightEnable ( bool_t isEnable )
    581          {
    582              bool_t  oldEnable = pIpv->highLightEnabled;
    583          
    584              pIpv->lastResultCode    = SII_IPV_SUCCESS;
    585              pIpv->highLightEnabled  = isEnable;
    586          
    587              return( oldEnable );
    588          }
    589          //-------------------------------------------------------------------------------------------------
    590          //! @brief      Load the passed border color arrays into instance (but not hardware).
    591          //! @param[in]  pNewColors
    592          //-------------------------------------------------------------------------------------------------
    593          void SiiIpvBorderColorsLoad ( uint8_t newColors[][YCBCR_LEN] )
    594          {
    595              if ( pIpv->isEnabled )
    596              {
    597                  pIpv->lastResultCode = SII_IPV_ERR_IN_USE;
    598              }
    599              else
    600              {
    601                  memcpy( pIpv->borderColors, newColors, sizeof( pIpv->borderColors ));
    602                  pIpv->lastResultCode = SII_IPV_SUCCESS;
    603              }
    604          }
    605          
    606          //-------------------------------------------------------------------------------------------------
    607          //! @brief
    608          //! @param[in]
    609          //-------------------------------------------------------------------------------------------------
    610          void SiiIpvAlphaLoad ( uint8_t *pNewAlphaMaxTable, uint8_t *pNewAlphaStepTable, int_t stepMs )
    611          {
    612              if ( pIpv->isEnabled )
    613              {
    614                  pIpv->lastResultCode = SII_IPV_ERR_IN_USE;
    615              }
    616              else
    617              {
    618                  memcpy( pIpv->windowSpecs.alphaMax, pNewAlphaMaxTable, sizeof( pIpv->windowSpecs.alphaMax ));
    619                  memcpy( pIpv->windowSpecs.alphaStep, pNewAlphaStepTable, sizeof( pIpv->windowSpecs.alphaStep ));
    620                  pIpv->windowSpecs.alphaStepSpeedMs = stepMs;
    621                  pIpv->lastResultCode = SII_IPV_SUCCESS;
    622              }
    623          }
    624          
    625          //-------------------------------------------------------------------------------------------------
    626          //! @brief      Sets the alpha blending level for the specified window if enabled.
    627          //!
    628          //! @param[in]  windowIndex
    629          //! @param[in]  newLevel
    630          //-------------------------------------------------------------------------------------------------
    631          void SiiIpvAlphaBlendSet ( int_t windowIndex, int_t newLevel )
    632          {
    633              SiiDrvIpvWindowAlphaSet( windowIndex, newLevel );
    634              pIpv->lastResultCode = SII_IPV_SUCCESS;
    635          }
    636          
    637          //-------------------------------------------------------------------------------------------------
    638          //! @brief      Perform alpha stepping for all windows
    639          //!
    640          //! @returns    true if all windows at maximum alpha.
    641          //-------------------------------------------------------------------------------------------------
    642          bool_t SiiIpvAlphaStep( void )
    643          {
    644              int_t   i;
    645              bool_t  atMax = true;
    646          
    647              for ( i = 0; i < IPV_WINDOW_COUNT; i++ )
    648              {
    649                  if ( pIpv->alphaCurrentValue[ i] > pIpv->windowSpecs.alphaMax[i])
    650                  {
    651                      if ( pIpv->windowSpecs.alphaStep[i] >= pIpv->alphaCurrentValue[ i] )
    652                      {
    653                          pIpv->alphaCurrentValue[ i] = 0;
    654                      }
    655                      else
    656                      {
    657                          pIpv->alphaCurrentValue[ i] -= pIpv->windowSpecs.alphaStep[i];
    658                          atMax = false;  // At least one window is not at max
    659                      }
    660                      SiiDrvIpvWindowAlphaSet( i, pIpv->alphaCurrentValue[ i] );
    661                  }
    662              }
    663          
    664              return( atMax );
    665          }
    666          
    667          //-------------------------------------------------------------------------------------------------
    668          //! @brief      Select one of the built-in themes stored in firmware and load it into firmware.
    669          //!             The theme is automatically adjusted for screen resolution,
    670          //!             aspect ratio and preview window size.
    671          //! @param[in]  newTheme
    672          //-------------------------------------------------------------------------------------------------
    673          void SiiIpvThemeSet ( SiiIpvTheme_t newTheme )
    674          {
    675              int_t   i;
    676          
    677              pIpv->lastResultCode = SII_IPV_SUCCESS;
    678              do
    679              {
    680                  if ( pIpv->isEnabled )
    681                  {
    682                      pIpv->lastResultCode = SII_IPV_ERR_IN_USE;
    683                      break;
    684                  }
    685                  if (( newTheme >= SiiIpvThemeCount ) && ( newTheme != SiiIpvPIP))
    686                  {
    687                      pIpv->lastResultCode = SII_IPV_ERR_INVALID_PARAMETER;
    688                      break;
    689                  }
    690          
    691                  // Calculate window specs based on new theme.
    692                  pIpv->currentTheme  = newTheme;
    693                  pIpv->highLightIndex = 0;
    694                  UpdateWindowSpecs();    // Ignore res change response; we'll always reload window specs.
    695          
    696                  // Load it all into the hardware.
    697                  for ( i = 0; i < SiiIpvBorderColorCount; i++ )
    698                  {
    699                      SiiDrvIpvBoundaryColorTableSet( i, pIpv->borderColors[i] );
    700                  }
    701                  SiiDrvIpvWindowAlphaTableSet( 0, pIpv->windowSpecs.alphaMax, pIpv->windowSpecs.alphaStep, IPV_WINDOW_COUNT );
    702                  SiiDrvIpvBorderEnablesSet( siiIpvBorderEnables[ pIpv->currentTheme]);
    703          
    704                  SiiDrvIpvAnimationEnable(false);
    705                  for ( i = 0; i < IPV_WINDOW_COUNT; i++ )
    706                  {
    707                      SiiDrvIpvWindowCoordSet( i, pIpv->windowSpecs.coords[i].x, pIpv->windowSpecs.coords[i].y);
    708                  }
    709                  SiiDrvIpvSizeSet( pIpv->windowSpecs.width16x9, pIpv->windowSpecs.width4x3, pIpv->windowSpecs.height);
    710              } while (0);
    711          }
    712          
    713          //-------------------------------------------------------------------------------------------------
    714          //! @brief      Displays the single window InstaPrevue mode known as PIP using the passed value
    715          //!             as the PIP source.  To turn off PIP, call SiiIpvEnable( false );
    716          //! @param[in]  pipSource - Source port for PIP window.
    717          //-------------------------------------------------------------------------------------------------
    718          bool_t SiiIpvPipModeEnable ( void )
    719          {
    720              SiiIpvEnable( false );
    721              SiiIpvThemeSet( SiiIpvPIP );
    722          
    723              SiiIpvModeSet( SiiIpvModeSELECT );
    724              SiiIpvEnable( true );
    725          
    726              return( true );
    727          }
    728          
    729          //-------------------------------------------------------------------------------------------------
    730          //! @brief      Check the state of the InstaPrevue windows.
    731          //!
    732          //! @return     true if alpha stepping is not complete yet
    733          //-------------------------------------------------------------------------------------------------
    734          bool_t SiiIpvHandler ( clock_time_t msDiff )
    735          {
    736              int_t   i;
    737          
    738              // Handle any pending interrupts
    739              if ( SiiDrvIpvHandleInterrupts())
    740              {
    741                  // There was a change from unstable to stable resolution, recalculate as necessary...
    742                  if ( UpdateWindowSpecs())
    743                  {
    744                      SiiDrvIpvAnimationEnable(false);
    745                      // ...reload...
    746                      for ( i = 0; i < IPV_WINDOW_COUNT; i++ )
    747                      {
    748                          SiiDrvIpvWindowCoordSet( i, pIpv->windowSpecs.coords[i].x, pIpv->windowSpecs.coords[i].y);
    749                      }
    750                      SiiDrvIpvSizeSet( pIpv->windowSpecs.width16x9, pIpv->windowSpecs.width4x3, pIpv->windowSpecs.height );
    751                      SiiIpvHighlightSet( -1 );
    752                  }
    753                  SiiDrvIpvEnable( true );    // ...and turn IPV back on
    754              }
    755          
    756              // Perform window alpha stepping if needed
    757              if ( pIpv->isAlphaStepping )
    758              {
    759                  if ( msDiff >= (clock_time_t)pIpv->alphaStepRemainingDelay )
    760                  {
    761                      pIpv->alphaStepRemainingDelay = pIpv->windowSpecs.alphaStepSpeedMs;
    762                      pIpv->isAlphaStepping = !SiiIpvAlphaStep();
    763                  }
    764                  else
    765                  {
    766                      pIpv->alphaStepRemainingDelay -= msDiff;
    767                  }
    768              }
    769          
    770              // Perform selected window bouncing effect if needed
    771              if (pIpv->isBounceEffect)
    772              {
    773                  if ((pIpv->highLightIndex != -1) && SiiDrvIpvAnimationIsComplete() && pIpv->highLightEnabled )
    774                  {
    775                      //SiiDrvIpvAnimationEnable(true);
    776                      i = pIpv->highLightIndex;
    777                      SiiDrvIpvWindowCoordSet( i, pIpv->windowSpecs.coords[i].x + pIpv->highLightHoriz + pIpv->bounceStep,
    778                                                  pIpv->windowSpecs.coords[i].y);
    779                      pIpv->bounceStep = -pIpv->bounceStep;
    780                      pIpv->bounceStep /= 2;
    781          
    782                      if (pIpv->bounceStep == 0)
    783                      {
    784                          pIpv->isBounceEffect = false;
    785                          pIpv->bounceStep = SII_IPV_BOUNCE_AMPL;
    786                          SiiDrvIpvAnimationEnable(false);
    787                      }
    788                  }
    789              }
    790          
    791              return (pIpv->isAlphaStepping || pIpv->isBounceEffect);
    792          }
    793          
    794          
    795          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  SiiIpvAlphaBlendSet
              8 -> SiiDrvIpvWindowAlphaSet
       16  SiiIpvAlphaLoad
             16 -> __aeabi_memcpy
       16  SiiIpvAlphaStep
             16 -> SiiDrvIpvWindowAlphaSet
        8  SiiIpvBorderColorsLoad
              8 -> __aeabi_memcpy
       16  SiiIpvEnable
             16 -> SiiDrvIpvEnable
             16 -> SiiDrvIpvGetLastResult
             16 -> SiiDrvIpvWindowAlphaSet
             16 -> __aeabi_memset4
        0  SiiIpvGetLastResult
       16  SiiIpvHandler
             16 -> SiiDrvIpvAnimationEnable
             16 -> SiiDrvIpvAnimationIsComplete
             16 -> SiiDrvIpvEnable
             16 -> SiiDrvIpvHandleInterrupts
             16 -> SiiDrvIpvSizeSet
             16 -> SiiDrvIpvWindowCoordSet
             16 -> SiiIpvAlphaStep
             16 -> SiiIpvHighlightSet
             16 -> UpdateWindowSpecs
        0  SiiIpvHighlightEnable
        0  SiiIpvHighlightPortGet
       48  SiiIpvHighlightSet
             48 -> SiiDrvIpvAnimationEnable
             48 -> SiiDrvIpvWindowCoordSet
       16  SiiIpvHighlightWindow
             16 -> SiiDrvIpvActiveWindowsGet
             16 -> SiiIpvHighlightSet
        8  SiiIpvInitialize
              0 -> SiiDrvIpvInitialize
              8 -> __aeabi_memclr4
        8  SiiIpvModeSet
              8 -> SiiDrvIpvGetLastResult
              8 -> SiiDrvIpvModeSet
        8  SiiIpvPipModeEnable
              8 -> SiiIpvEnable
              8 -> SiiIpvModeSet
              8 -> SiiIpvThemeSet
        0  SiiIpvRefresh
              0 -> SiiDrvIpvDownsamplerReset
       16  SiiIpvThemeSet
             16 -> SiiDrvIpvAnimationEnable
             16 -> SiiDrvIpvBorderEnablesSet
             16 -> SiiDrvIpvBoundaryColorTableSet
              0 -> SiiDrvIpvSizeSet
             16 -> SiiDrvIpvWindowAlphaTableSet
             16 -> SiiDrvIpvWindowCoordSet
             16 -> UpdateWindowSpecs
       32  SiiIpvWindowSpecsGet
       48  UpdateWindowSpecs
             48 -> SiiIpvCbVideoInfoGet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      20  ?Subroutine0
      12  ?Subroutine1
      10  ?Subroutine2
      18  SiiIpvAlphaBlendSet
      54  SiiIpvAlphaLoad
      74  SiiIpvAlphaStep
      36  SiiIpvBorderColorsLoad
      76  SiiIpvEnable
      10  SiiIpvGetLastResult
     240  SiiIpvHandler
      20  SiiIpvHighlightEnable
      16  SiiIpvHighlightPortGet
     344  SiiIpvHighlightSet
      70  SiiIpvHighlightWindow
      70  SiiIpvInitialize
      20  SiiIpvModeSet
      30  SiiIpvPipModeEnable
      18  SiiIpvRefresh
     136  SiiIpvThemeSet
      86  SiiIpvWindowSpecsGet
     756  UpdateWindowSpecs
     164  ipvInstance
       4  pIpv

 
   164 bytes in section .bss
     4 bytes in section .data
 2 160 bytes in section .text
 
 2 160 bytes of CODE memory
   168 bytes of DATA memory

Errors: none
Warnings: 3

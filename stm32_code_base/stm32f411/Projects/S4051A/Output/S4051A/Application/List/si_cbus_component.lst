###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:23:27 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\sii953x\component\cbus\si_cbus_ #
#                    component.c                                              #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\sii953x\component\cbus\si_cbus_ #
#                    component.c -D S4051A -D DEBUG -D FREE_RTOS -D           #
#                    STM32F40_41xxx -D USE_STM324xG_EVAL -D                   #
#                    USE_STDPERIPH_DRIVER -D __ARM_CORTEX_MX__ -D             #
#                    IAR_ARM_CM4F -D USE_USB_OTG_FS -lcN                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\ #
#                    DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applica #
#                    tion\Obj\ --debug --endian=little --cpu=Cortex-M4 -e     #
#                    --fpu=VFPv4_sp --dlib_config "C:\Program Files           #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\si_cbus_component.lst                                 #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\si_cbus_component.o                                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Libraries\AMT_Drivers\sii953x\component\cbus\si_cbus_component.c
      1          //***************************************************************************
      2          //!file     si_cbus_component.c
      3          //!brief    Silicon Image CBUS Component.
      4          //
      5          // No part of this work may be reproduced, modified, distributed,
      6          // transmitted, transcribed, or translated into any language or computer
      7          // format, in any form or by any means without written permission of
      8          // Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
      9          //
     10          // Copyright 2011-2012, Silicon Image, Inc.  All rights reserved.
     11          //***************************************************************************/
     12          
     13          
     14          #include "string.h"
     15          #include "si_common.h"
     16          #include "si_cbus_internal.h"
     17          #include "si_drv_cbus.h"
     18          #include "si_debug.h"
     19          #include "si_regs_pp953x.h"
     20          #include "si_cra.h"
     21          #include "si_edid_tx_component.h"
     22          #include "si_cbus_config.h"
     23          #if (MHL_EXTRA == ENABLE)
     24          
     25          // 2D SVDs and DTDs that are supported in 3D
     26          extern  uint8_t g3DEdidTableVIC [ EDID_3D_VIC_TABLE_LEN ];
     27          extern const uint8_t g3DEdidTableDTD [ EDID_3D_DTD_TABLE_LEN ];
     28          #endif
     29          
     30          #if (MHL_20 == ENABLE)
     31          #include "si_edid_tx_config.h"
     32          MHL3DSupportData_t gMHL3D_VIC[SII_NUM_EDID_TX];
     33          MHL3DSupportData_t gMHL3D_DTD[SII_NUM_EDID_TX];
     34          MHL3DSupportData_t  *pMHL3D_VIC = &gMHL3D_VIC[0];
     35          MHL3DSupportData_t  *pMHL3D_DTD = &gMHL3D_DTD[0];
     36          #endif
     37          
     38          //  active index in cbus queue
     39          #define CH_ACTIVE_INDEX     (pCbus->activeIndex)
     40          
     41          //static functions
     42          static void 	CBusProcessSubCommand (uint8_t* vsCmdData);
     43          static void 	CBusResetToIdle ();
     44          static int_t 	CBusSendNextInQueue ();
     45          static void 	CBusDumpQueueContents ( void );
     46          static void 	CBusClearQueueEntry ( uint8_t cmd );
     47          static bool_t 	CBusWriteCommand ( cbus_req_t *pReq  );
     48          static bool_t 	CBusWritePeersScratchpad();
     49          static uint8_t 	CBusCheckInterruptStatus ();
     50          static bool_t 	CBusSendDcapRdyMsg ();
     51          static bool_t 	CBusSetInt ( uint8_t regOffset, uint8_t regBit );
     52          
     53          /*static */bool_t 	CBusSendMscCommand(uint8_t cmd);
     54          static bool_t 	CBusSendDscrChange ();
     55          static bool_t 	CBusReqWrt ();
     56          static bool_t 	CBusGrtWrt ();
     57          static bool_t 	CBusWriteStatus ( uint8_t regOffset, uint8_t value );
     58          static bool_t 	CBusSendDcapRdy ();
     59          static bool_t 	CBusTimerExpired(clock_time_t *pTimer, uint16_t waitTime);
     60          static void 	CBusChkTimers ();
     61          
     62          
     63          
     64          #if (MHL_20 == ENABLE)
     65          static void		CBus3DCheckInstance( uint_t instanceIndex );
     66          static void 	CBus3DInstanceSet ( uint_t instanceIndex );
     67          static void 	CBusSend3DInfo();
     68          static int seq;
     69          #endif
     70          
     71          //------------------------------------------------------------------------------
     72          //  CBUS Component Instance Data
     73          //------------------------------------------------------------------------------
     74          
     75          CbusInstanceData_t cbusInstance[MHL_MAX_CHANNELS];
     76          CbusInstanceData_t *pCbus = &cbusInstance[0];
     77          
     78          //------------------------------------------------------------------------------
     79          //! @brief  Assign port and support mask to this CBUS instance (channel)
     80          //! @param[in]  port - Receiver input port
     81          //! @param[in]  supportMask - combination of SiiMhlLogicalDeviceTypes_t types
     82          //!                           supported by this device.
     83          //------------------------------------------------------------------------------
     84          void SiiCbusConfigure ( uint8_t port, uint8_t supportMask )
     85          {
     86              pCbus->port = port;
     87              pCbus->supportMask  = supportMask;
     88              SiiDrvCbusConfigure(port);
     89          }
     90          
     91          //------------------------------------------------------------------------------
     92          // Description: Set the component global data pointer to the requested instance.
     93          // Parameters:  instanceIndex
     94          // Returns:     true if legal index, false if index value is illegal.
     95          //------------------------------------------------------------------------------
     96          
     97          bool_t SiiCbusInstanceSet ( uint_t instanceIndex )
     98          {
     99              if ( instanceIndex < MHL_MAX_CHANNELS )
    100              {
    101                  SiiDrvCbusInstanceSet( instanceIndex );
    102                  pCbus = &cbusInstance[ instanceIndex];
    103                  pCbus->instanceIndex = instanceIndex;
    104          #if (MHL_20 == ENABLE)
    105                  CBus3DCheckInstance ( instanceIndex );
    106          #endif
    107                  return( true );
    108              }
    109          
    110              return( false );
    111          }
    112          
    113          //------------------------------------------------------------------------------
    114          // Description: Set the component global data pointer to the requested instance
    115          //				based on Port
    116          // Parameters:  portIndex
    117          // Returns:     true if legal index, false if index value is illegal.
    118          //------------------------------------------------------------------------------
    119          void SiiCbusInstanceSetBasedOnPort ( uint_t portIndex )
    120          {
    121          	uint8_t i;
    122          
    123          	for ( i=0; i < MHL_MAX_CHANNELS; i++ )
    124          	{
    125          		pCbus = &cbusInstance[ i ];
    126          		if( pCbus->port == portIndex )
    127          		{
    128          			//DEBUG_PRINT( MSG_ALWAYS, "\n\n*******Setting Instance: %02X\n", i);
    129          			SiiCbusInstanceSet(i);
    130          			break;
    131          		}
    132          	}
    133          }
    134          
    135          //------------------------------------------------------------------------------
    136          // Function:    SiiCbusStatus
    137          // Description: Returns a status flag word containing CBUS-specific
    138          //				information about the state of the device.
    139          // Parameters:  none
    140          // Returns:     Sixteen-bit misc flags word for the CBUS Component
    141          //------------------------------------------------------------------------------
    142          
    143          uint16_t SiiCbusStatus ( void )
    144          {
    145          	return( pCbus->miscFlags );
    146          }
    147          
    148          //------------------------------------------------------------------------------
    149          // Function:    SiiCbusStandby
    150          // Description: Places the CBUS component into standby mode if available
    151          // Parameters:  none
    152          // Returns:     true if the CBUS component entered standby mode successfully,
    153          //				or false if some failure occurred.
    154          //------------------------------------------------------------------------------
    155          
    156          bool_t SiiCbusStandby ( void )
    157          {
    158          	return( true );
    159          }
    160          
    161          //------------------------------------------------------------------------------
    162          // Function:    SiiCbusResume
    163          // Description: Causes operation of the CBUS component to return to the state
    164          //				it was prior to the previous call to SiiCbusStandby.
    165          // Parameters:  none
    166          // Returns:     true if the CBUS component successfully exited standby mode,
    167          //				or false if some failure occurred.
    168          //------------------------------------------------------------------------------
    169          
    170          bool_t SiiCbusResume ( void )
    171          {
    172          	return( true );
    173          }
    174          
    175          //------------------------------------------------------------------------------
    176          // Function:    SiiMhlRxCbusConnected
    177          // Description: Return the CBUS channel connected status for this channel.
    178          // Returns:     true if connected.
    179          //              false if disconnected.
    180          //------------------------------------------------------------------------------
    181          
    182          bool_t SiiMhlRxCbusConnected ()
    183          {
    184              return( pCbus->connected );
    185          }
    186          
    187          //------------------------------------------------------------------------------
    188          // Function:    SiiMhlRxChannelEnable
    189          // Description: Enable or disable the specified CBUS channel.
    190          // param		isEnable - true to enable, false to disable
    191          //------------------------------------------------------------------------------
    192          void SiiMhlRxChannelEnable ( bool_t isEnable )
    193          {
    194          	SiiDrvCbusChnEn( isEnable, pCbus->port );
    195          }
    196          
    197          //------------------------------------------------------------------------------
    198          // Function:    SiiMhlRxIsQueueFull
    199          // Description: is cbus queue full ?
    200          // Parameters:  none
    201          // Returns:     true/false
    202          //------------------------------------------------------------------------------
    203          bool_t SiiMhlRxIsQueueFull ( void )
    204          {
    205              int_t   queueIndex;
    206          
    207          	for ( queueIndex = 0; queueIndex < CBUS_MAX_COMMAND_QUEUE; queueIndex++ )
    208          	{
    209          		if ( pCbus->request[ queueIndex].reqStatus == CBUS_REQ_IDLE )
    210          		{
    211          			return false;
    212          		}
    213          	}
    214          
    215          	return true;
    216          }
    217          
    218          //------------------------------------------------------------------------------
    219          // Function:    SiiMhlRxIsQueueEmpty
    220          // Description: is cbus queue empty ?
    221          // Parameters:  none
    222          // Returns:     true/false
    223          //------------------------------------------------------------------------------
    224          bool_t SiiMhlRxIsQueueEmpty ( void )
    225          {
    226              int_t   queueIndex;
    227          
    228              for ( queueIndex = 0; queueIndex < CBUS_MAX_COMMAND_QUEUE; queueIndex++ )
    229              {
    230                  if ( pCbus->request[ queueIndex].reqStatus == CBUS_REQ_PENDING )
    231                  {
    232                      return false;
    233                  }
    234              }
    235          
    236              return true;
    237          }
    238          
    239          //------------------------------------------------------------------------------
    240          // Function:    SiiMhlRxSendRAPCmd
    241          // Description: Send MSC_MSG (RAP) message to the specified CBUS channel (port)
    242          //
    243          // Parameters:  actCode 	- RAP action code
    244          // Returns:     true        - successful queue/write
    245          //              false       - write and/or queue failed
    246          //------------------------------------------------------------------------------
    247          bool_t SiiMhlRxSendRAPCmd ( uint8_t actCode )
    248          {
    249              return CBusSendMscMsgCmd(MHL_MSC_MSG_RAP, actCode);
    250          }
    251          
    252          //------------------------------------------------------------------------------
    253          // Function:    SiiMhlRxSendACPCmd
    254          // Description: Send MSC_MSG (ACP) message to the specified CBUS channel (port)
    255          //
    256          // Parameters:  asciiCode 	- ACP ASCII character
    257          // Returns:     true        - successful queue/write
    258          //              false       - write and/or queue failed
    259          //------------------------------------------------------------------------------
    260          bool_t SiiMhlRxSendUCPCmd ( uint8_t asciiCode )
    261          {
    262              return CBusSendMscMsgCmd(MHL_MSC_MSG_UCP, asciiCode);
    263          }
    264          
    265          //------------------------------------------------------------------------------
    266          // Function:    SiiMhlRxGetMscMsgCmd
    267          // Description: Get MSC_MSG (RCP/RAP) message that came on CBUS channel
    268          //
    269          // Parameters:  cmd    		- MSC_MSG cmd (RCP/RAP/ACP)
    270          //              data     	- keyCode
    271          // Returns:     true        - successful queue/write
    272          //              false       - write and/or queue failed
    273          //------------------------------------------------------------------------------
    274          
    275          bool_t SiiMhlRxGetMscMsgCmd ( uint8_t* cmd, uint8_t* data )
    276          {
    277              *cmd = pCbus->lastCbusRcvdCmd;
    278              *data = pCbus->lastCbusRcvdData;
    279          	return true;
    280          }
    281          
    282          //------------------------------------------------------------------------------
    283          // Function:    SiiMhlRxSendRcpk
    284          // Description: Send RCPK (ack) message
    285          //
    286          // Parameters:  keyCode
    287          // Returns:     true        - successful queue/write
    288          //              false       - write and/or queue failed
    289          //------------------------------------------------------------------------------
    290          
    291          bool_t SiiMhlRxSendRcpk ( uint8_t keyCode)
    292          {
    293              return( CBusSendMscMsgCmd( MHL_MSC_MSG_RCPK, keyCode ));
    294          }
    295          
    296          //------------------------------------------------------------------------------
    297          // Function:    SiiMhlRxSendAcpe
    298          // Description: Send ACPE (error) message
    299          //
    300          // Parameters:  cmdStatus
    301          // Returns:     true        - successful queue/write
    302          //              false       - write and/or queue failed
    303          //------------------------------------------------------------------------------
    304          bool_t SiiMhlRxSendUcpe ( uint8_t cmdStatus )
    305          {
    306              return( CBusSendMscMsgCmd( MHL_MSC_MSG_UCPE, cmdStatus ));
    307          }
    308          
    309          //------------------------------------------------------------------------------
    310          // Function:    SiiMhlRxSendAcpk
    311          // Description: Send ACPK (ack) message
    312          //
    313          // Parameters:  asciiCode
    314          // Returns:     true        - successful queue/write
    315          //              false       - write and/or queue failed
    316          //------------------------------------------------------------------------------
    317          
    318          bool_t SiiMhlRxSendUcpk ( uint8_t asciiCode)
    319          {
    320              return( CBusSendMscMsgCmd( MHL_MSC_MSG_UCPK, asciiCode ));
    321          }
    322          
    323          //------------------------------------------------------------------------------
    324          // Function:    SiiMhlRxSendRcpe
    325          // Description: Send RCPE (error) message
    326          //
    327          // Parameters:  cmdStatus
    328          // Returns:     true        - successful queue/write
    329          //              false       - write and/or queue failed
    330          //------------------------------------------------------------------------------
    331          bool_t SiiMhlRxSendRcpe ( uint8_t cmdStatus )
    332          {
    333              return( CBusSendMscMsgCmd( MHL_MSC_MSG_RCPE, cmdStatus ));
    334          }
    335          
    336          //------------------------------------------------------------------------------
    337          // Function:    SiiMhlRxSendRapk
    338          // Description: Send RAPK (acknowledge) message to the specified CBUS channel
    339          //              and set the request status to idle.
    340          //
    341          // Parameters:  cmdStatus
    342          // Returns:     true        - successful queue/write
    343          //              false       - write and/or queue failed
    344          //------------------------------------------------------------------------------
    345          
    346          bool_t SiiMhlRxSendRapk ( uint8_t cmdStatus )
    347          {
    348              return( CBusSendMscMsgCmd( MHL_MSC_MSG_RAPK, cmdStatus ));
    349          }
    350          
    351          //------------------------------------------------------------------------------
    352          // Function:    SiiMhlRxSendMsge
    353          // Description: Send MSGE msg back if the MSC command received is not recognized
    354          //
    355          // Returns:     true        - successful
    356          //              false       - failed
    357          //------------------------------------------------------------------------------
    358          
    359          bool_t SiiMhlRxSendMsge ()
    360          {
    361              return( CBusSendMscMsgCmd( MHL_MSC_MSG_E, MHL_MSC_INVALID_SUBCMD ));
    362          }
    363          
    364          //------------------------------------------------------------------------------
    365          // Function:    SiiMhlRxHpdSet
    366          // Description: Send MHL_SET_HPD to source
    367          // parameters:	setHpd - self explanatory :)
    368          // Returns:     true/false
    369          //------------------------------------------------------------------------------
    370          bool_t SiiMhlRxHpdSet (bool_t setHpd)
    371          {
    372          	if( setHpd )
    373          	{
    374          		if( SiiMhlRxCbusConnected() )
    375          		{
    376          			if( !CBusSendMscCommand( MHL_SET_HPD ) )
    377          			{
    378          				DEBUG_PRINT(MSG_ALWAYS,"MHL SET HPD FAILED\n");
    379          				return false;
    380          			}
    381          			//Bug 31921 - Melbourne on power up, Unconnected port to MHL connected port switch not working 
    382          //			if( !SiiMhlRxSendEdidChange() )
    383          //				return false;
    384          			if( !SiiMhlRxPathEnable(true) )
    385          				return false;
    386          			// Configure always MHL 1x mode
    387          			SiiRegWrite(PA_MHL1X_CONF_REG_1, (BIT_ALWAYS_1X_MHL1X | BIT_MHL_OPMODE_3X_DEF) );
    388          		}
    389              }
    390          	else
    391          	{
    392          		if( SiiMhlRxCbusConnected() )
    393          		{
    394          			if( !SiiMhlRxPathEnable(false) )
    395          				return false;
    396          			if( !CBusSendMscCommand( MHL_CLR_HPD ) )
    397          				return false;
    398          		}
    399              }
    400          
    401          	return true;
    402          }
    403          
    404          //------------------------------------------------------------------------------
    405          // Function:    SiiMhlRxWritePeerScratchpad
    406          // Description: sends MHL write burst cmd to peer
    407          // Parameters:  startOffset - start offset of peer's scratchpad register
    408          //				length - total# of scratchpad registers to be written
    409          //				pMsgData - pointer to data needs to be written in peer's scratchpad
    410          // Returns:     SUCCESS or one of CBUS_SOFTWARE_ERRORS_t
    411          //------------------------------------------------------------------------------
    412          
    413          bool_t SiiMhlRxWritePeerScratchpad(uint8_t startOffset, uint8_t length, uint8_t* pMsgData)
    414          {
    415          	if( pCbus->miscFlags & FLAGS_SCRATCHPAD_BUSY )
    416          	{
    417          		DEBUG_PRINT( MSG_ALWAYS, "Scratchpad busy!! Please come back later!!\n" );
    418          		return false;
    419          	}
    420          
    421          	pCbus->wbLength = length;
    422          	pCbus->wbStartOffset = startOffset;
    423          
    424          	// write different values in different registers
    425          	SiiDrvCbusWriteLocalScratchpad( startOffset, length, pMsgData );
    426          
    427          	// send REQ_WRT interrupt to peer
    428          	if( !(CBusReqWrt()) )
    429          	{
    430          		DEBUG_PRINT( MSG_ALWAYS, "Couldn't send REQ_WRT to peer\n" );
    431          		return false;
    432          	}
    433          
    434          	pCbus->miscFlags |= FLAGS_SCRATCHPAD_BUSY;
    435          
    436          	return true;
    437          }
    438          
    439          
    440          //------------------------------------------------------------------------------
    441          // Function:    SiiMhlRxReadDevCapReg
    442          // Description: Read device capability register
    443          // Parameters:  regOffset - offset of peer's device capability register
    444          // Returns:     true/false
    445          //------------------------------------------------------------------------------
    446          
    447          bool_t SiiMhlRxReadDevCapReg(uint8_t regOffset)
    448          {
    449          	cbus_req_t 	req;
    450          	bool_t		success;
    451          
    452          	pCbus->lastCbusSentCmd = req.command = MHL_READ_DEVCAP;
    453          	req.offsetData = regOffset;
    454          
    455          	if( !(success = CBusWriteCommand(&req)) )
    456          	{
    457          		DEBUG_PRINT( MSG_ALWAYS, "Couldn't send MHL_READ_DEVCAP to peer\n" );
    458          	}
    459          
    460          	return success;
    461          }
    462          
    463          //------------------------------------------------------------------------------
    464          // Function:    SiiMhlRxSendEdidChange
    465          // Description: set edid_chg interrupt
    466          //------------------------------------------------------------------------------
    467          bool_t SiiMhlRxSendEdidChange ( void )
    468          {
    469          	return ( CBusSetInt(0x01, BIT1) );
    470          }
    471          
    472          //------------------------------------------------------------------------------
    473          // Function:    SiiMhlRxSendDevCapChange
    474          // Description: sends device capability change interrupt to peer
    475          // Parameters:  none
    476          // Returns:     true/false
    477          //------------------------------------------------------------------------------
    478          bool_t SiiMhlRxSendDevCapChange ( void )
    479          {
    480          	return ( CBusSetInt(0x00, BIT0) );
    481          }
    482          
    483          //------------------------------------------------------------------------------
    484          // Function:    SiiMhlRxPathEnable
    485          //------------------------------------------------------------------------------
    486          bool_t SiiMhlRxPathEnable ( bool_t enable )
    487          {
    488          	bool_t success = true;
    489          
    490          //	DEBUG_PRINT( MSG_DBG, "\nSiiMhlRxPathEnable:: pCbus->pathEnableSent = %X.\n", pCbus->pathEnableSent );
    491          	if ( enable )
    492              {
    493          		if ( !pCbus->pathEnableSent )
    494          		{
    495          			// enable PATH_EN bit on peer's appropriate status register (offset 0x31)
    496          			DEBUG_PRINT( MSG_DBG, "\nSiiMhlRxPathEnable:: Setting bit 3 to peer's status register.\n" );
    497          			if( (success = CBusWriteStatus(0x01, BIT3)) == true )
    498          			{
    499          				pCbus->pathEnableSent = true;
    500          			}
    501          		}
    502              }
    503              else
    504              {
    505              	if ( pCbus->pathEnableSent )
    506              	{
    507                      // disable PATH_EN bit on peer's appropriate status register (offset 0x31)
    508          //    		DEBUG_PRINT( MSG_DBG, "\nSiiMhlRxPathEnable:: Clearing bit 3 to peer's status register.\n" );
    509              		if( (success = CBusWriteStatus(0x01, 0)) == true )
    510              		{
    511              			pCbus->pathEnableSent = false;
    512              		}
    513              	}
    514              }
    515          
    516          	return success;
    517          }
    518          
    519          #if INC_CEC
    520          extern void SkAppCbusCecSendVendorId(uint8_t instanceIndex, uint8_t *vendorId );
    521          #endif
    522          
    523          //------------------------------------------------------------------------------
    524          // Function:    SiiMhlRxHandler
    525          // Description: Check the state of any current CBUS message on specified channel.
    526          //              Handle responses or failures and send any pending message if
    527          //              channel is IDLE.
    528          // Parameters:  channel - CBUS channel to check, must be in range, NOT 0xFF
    529          // Returns:     SUCCESS or one of CBUS_SOFTWARE_ERRORS_t
    530          //------------------------------------------------------------------------------
    531          
    532          uint8_t SiiMhlRxHandler ( void )
    533          {
    534          #if ( configSII_DEV_953x_PORTING == 1 )
    535              uint8_t result = CBUS_SUCCESS;
    536          #else
    537             uint8_t result = SUCCESS; 
    538          #endif 
    539          
    540              /* Check the channel interrupt status to see if anybody is  */
    541              /* talking to us. If they are, talk back.                   */
    542          
    543          	if( !(pCbus->miscFlags & FLAGS_SENT_DCAP_RDY) && !pCbus->initTimer && SiiMhlRxCbusConnected())
    544          	{
    545          		// Send MHL_SET_HPD command
    546          		//  Bug 31921 - Melbourne on power up, Unconnected port to MHL connected port switch not working 
    547          		// Clear queue
    548          		memset(&pCbus->request[0], 0, (sizeof(cbus_req_t) * CBUS_MAX_COMMAND_QUEUE) );
    549          		pCbus->queueDepth = 0;
    550          
    551          		pCbus->sendMHLCommands = 1;
    552          
    553          		SiiMhlRxHpdSet(false);
    554          		SiiMhlRxHpdSet(true);
    555          
    556          		// send DCAP_RDY and DCAP_CHG
    557          		CBusSendDcapRdyMsg();
    558          	}
    559          
    560          	if(!pCbus->sendMHLCommands)
    561          	{
    562          		//  Bug 31921 - Melbourne on power up, Unconnected port to MHL connected port switch not working 
    563          		memset(&pCbus->request[0], 0, (sizeof(cbus_req_t) * CBUS_MAX_COMMAND_QUEUE) );
    564          		pCbus->queueDepth = 0;
    565          	}
    566          
    567          	//checkMhlRsense();
    568          	result = CBusCheckInterruptStatus();
    569          
    570              // check for all the f/w timers
    571              CBusChkTimers();
    572          
    573              /* Update the channel state machine as necessary.   */
    574          	if ( pCbus->state == CBUS_IDLE )
    575          	{
    576          		result = CBusSendNextInQueue(); // No command in progress, write new command immediately.
    577          	}
    578          
    579          	if ( pCbus->state & CBUS_XFR_DONE )
    580          	{
    581          		pCbus->state = pCbus->state & ~CBUS_XFR_DONE;
    582          		if ( pCbus->lastCbusSentCmd == MHL_READ_DEVCAP )
    583          		{
    584          			pCbus->lastReadDevCapReg = pCbus->request[ CH_ACTIVE_INDEX ].msgData[0];
    585          			SiiMhlCbRxMscCmdResponseData( pCbus->lastCbusSentCmd, pCbus->lastReadDevCapReg );
    586          		}
    587          #if INC_CEC
    588          		if ( pCbus->lastCbusSentCmd == MHL_GET_VENDOR_ID )
    589          		{
    590          			SkAppCbusCecSendVendorId( pCbus->instanceIndex,pCbus->request[ CH_ACTIVE_INDEX ].msgData );
    591          		}
    592          #endif
    593          
    594          		if ( pCbus->lastCbusSentCmd == MHL_WRITE_BURST )
    595          		{
    596          			//DEBUG_PRINT( MSG_DBG, "Send DSCR Change!\n" );
    597          			// send DSCR_CHG interrupt to peer
    598          			if( !(CBusSendDscrChange()) )
    599          			{
    600          				DEBUG_PRINT( MSG_ALWAYS, "Couldn't send DSCR_CHG to peer\n" );
    601          			}
    602          			pCbus->miscFlags &= ~FLAGS_SCRATCHPAD_BUSY;
    603          
    604          #if (MHL_EXTRA == ENABLE)
    605          			if ( pCbus->serving3dVicReq || pCbus->serving3dDtdReq )
    606          			{
    607          				//CBusSend3DInfo();
    608          			}
    609          #endif
    610          #if (MHL_20 == ENABLE)
    611          			if ( pCbus->sending_3D_info)
    612          			{
    613          				CBusSend3DInfo();
    614          			}
    615          #endif
    616          		}
    617          
    618          		pCbus->waitTimer = 0;
    619          		if( pCbus->queueDepth )
    620          		{
    621          			pCbus->queueDepth--;
    622          		}
    623          		DEBUG_PRINT( MSG_DBG, "\n-------Transfer Done!!------ "
    624          								"Queue Depth: %02X active index(cbus): %02X\n", pCbus->queueDepth, CH_ACTIVE_INDEX);
    625          		memset( &(pCbus->request[CH_ACTIVE_INDEX]), 0, sizeof( cbus_req_t ) );
    626          	}
    627          
    628          	if ( pCbus->state & CBUS_RECEIVED )
    629          	{
    630          	    // Process RCPx/RAPx messages
    631          		pCbus->state = pCbus->state & ~CBUS_RECEIVED;
    632          		if( (pCbus->lastCbusRcvdCmd == MHL_MSC_MSG_RCPK) || (pCbus->lastCbusRcvdCmd == MHL_MSC_MSG_RAPK) || ( pCbus->lastCbusRcvdCmd == MHL_MSC_MSG_UCPK))
    633          		{
    634          			pCbus->rcpRapAbortTimer = 0;
    635          		}
    636          //		DEBUG_PRINT( MSG_DBG, "\nMSG MSG received!! active index(cbus): %02X\n", CH_ACTIVE_INDEX);
    637          		CbusProcessRcpRap( pCbus->lastCbusRcvdCmd, pCbus->lastCbusRcvdData);
    638          	}
    639          
    640          	if ( pCbus->state & CBUS_FAILED )
    641          	{
    642          		pCbus->state = pCbus->state & ~CBUS_FAILED;
    643          		pCbus->request[ CH_ACTIVE_INDEX ].reqStatus = CBUS_REQ_IDLE;
    644          		if( pCbus->queueDepth )
    645          		{
    646          			pCbus->queueDepth--;
    647          		}
    648          		DEBUG_PRINT( MSG_DBG, "\n-----Last Cbus cmd failed!!------"
    649          						"Queue Depth: %02X cmd failed: %02X\n", pCbus->queueDepth, pCbus->request[ CH_ACTIVE_INDEX ].command);
    650          		memset( &(pCbus->request[CH_ACTIVE_INDEX]), 0, sizeof( cbus_req_t ) );
    651          	}
    652          
    653              return( result );
    654          }
    655          
    656          //------------------------------------------------------------------------------
    657          // Function:    SiiMhlRxInitialize
    658          // Description: Attempts to initialize the CBUS. If register reads return 0xFF,
    659          //              it declares error in initialization.
    660          //              Initializes discovery enabling registers and anything needed in
    661          //              config register, interrupt masks.
    662          // Returns:     TRUE if no problem
    663          //------------------------------------------------------------------------------
    664          
    665          bool_t SiiMhlRxInitialize ( void )
    666          {
    667              int_t instanceIndex;
    668          
    669              // Clear instance data
    670              instanceIndex = pCbus->instanceIndex;       // Remember our instance
    671              memset( pCbus, 0, sizeof( CbusInstanceData_t ));
    672              memset( &(pCbus->request), 0, sizeof( cbus_req_t ) * CBUS_MAX_COMMAND_QUEUE);
    673              pCbus->instanceIndex = instanceIndex;       // Restore our instance
    674          
    675          #if (MHL_20 == ENABLE)
    676              memset(&gMHL3D_VIC[0], 0, sizeof(MHL3DSupportData_t)*SII_NUM_EDID_TX);
    677              memset(&gMHL3D_DTD[0], 0, sizeof(MHL3DSupportData_t)*SII_NUM_EDID_TX);
    678          #endif
    679              return( SiiDrvCbusInitialize() );
    680          }
    681          
    682          //------------------------------------------------------------------------------
    683          // Function:    SiiMhlCbHpdSetState
    684          // Description: This callback is used when the Receiver finishes with all its
    685          //              initialization and ready for Transmitter to read
    686          //              EDID/KSV FIFO/BCAPS ...
    687          // Returns:     true: success
    688          //              false: either port is not MHL or CBUS is not ready.
    689          //------------------------------------------------------------------------------
    690          bool_t SiiMhlCbHpdSetState ( int_t portIndex, SiiDrvHpdActions_t newState )
    691          {
    692              bool_t success;
    693          
    694              success = false;
    695          
    696              // Translate request to CBUS command.
    697              switch ( newState )
    698              {
    699              case SiiHPD_INACTIVE:
    700              case SiiHPD_TOGGLE:             // Start with a toggle to OFF
    701                  success = SiiMhlRxHpdSet(false);
    702                  break;
    703              case SiiHPD_ACTIVE:
    704              	success = SiiMhlRxHpdSet(true);
    705                  break;
    706              default:
    707                  break;
    708              }
    709          
    710              // If a toggle, queue up the second command.
    711              if ( success && ( newState == SiiHPD_TOGGLE ))
    712              {
    713                  success = SiiMhlRxHpdSet(true);
    714              }
    715          
    716              return( success );
    717          }
    718          
    719          //------------------------------------------------------------------------------
    720          // Function:    CBusSendNextInQueue
    721          // Description: Starting at the current active index, send the next pending
    722          //              entry, if any
    723          //------------------------------------------------------------------------------
    724          
    725          static int_t CBusSendNextInQueue ()
    726          {
    727          #if ( configSII_DEV_953x_PORTING == 1 )
    728              int_t   result = CBUS_SUCCESS;
    729          #else
    730           int_t   result = SUCCESS;
    731          #endif 
    732              int_t   nextIndex = 0;
    733          
    734              if ( ( !pCbus->hpdWaitTimer ) && ( !pCbus->abortTimer ) && ( !pCbus->waitTimer )  )
    735              {
    736          		nextIndex = (CH_ACTIVE_INDEX == ( CBUS_MAX_COMMAND_QUEUE - 1 )) ? 0 : (CH_ACTIVE_INDEX + 1);
    737          
    738          		while (	( pCbus->request[ nextIndex].reqStatus != CBUS_REQ_PENDING ) ||
    739          				( pCbus->rcpeRcpkGapTimer && ( (pCbus->request[ nextIndex].msgData[0] == MHL_MSC_MSG_RCPK) || (pCbus->request[ nextIndex].msgData[0] == MHL_MSC_MSG_UCPK) )) ||
    740          				( pCbus->rcpRapAbortTimer && ( pCbus->request[ nextIndex].msgData[0] == MHL_MSC_MSG )))
    741          		{
    742          			if ( nextIndex == CH_ACTIVE_INDEX )     // Searched whole queue, no pending
    743          			{
    744          				CH_ACTIVE_INDEX = CBUS_MAX_COMMAND_QUEUE - 1;
    745          
    746          #if ( configSII_DEV_953x_PORTING == 1 )
    747          				return( CBUS_SUCCESS );  // No pending messages is still success
    748          #else
    749          				return( SUCCESS );  // No pending messages is still success
    750          #endif
    751          
    752          			}
    753          			nextIndex = ( nextIndex == (CBUS_MAX_COMMAND_QUEUE - 1)) ? 0 : (nextIndex + 1);
    754          		}
    755          
    756          //		DEBUG_PRINT( MSG_DBG, "Active Index: %0x\n", nextIndex);
    757          		CBusDumpQueueContents();
    758                  //  Bug 31921 - Melbourne on power up, Unconnected port to MHL connected port switch not working 
    759          
    760          		if( pCbus->request[nextIndex].command == MHL_CLR_HPD )
    761          		{
    762          			SiiDrvRxHdcpDdcControl( pCbus->port, false );
    763          			SiiDrvRxEdidDdcControl( pCbus->port, false );
    764          		}
    765          		else if( pCbus->request[nextIndex].command == MHL_SET_HPD )
    766          		{
    767          			SiiDrvRxHdcpDdcControl( pCbus->port, true );
    768          			SiiDrvRxEdidDdcControl( pCbus->port, true );
    769          		}
    770          
    771          		// Found a pending message, send it out
    772          		if ( SiiDrvInternalCBusWriteCommand( &pCbus->request[ nextIndex] ))
    773          		{
    774          			CH_ACTIVE_INDEX = nextIndex;
    775          			pCbus->waitTimer = SiiOsTimerTotalElapsed();
    776          			pCbus->state = CBUS_SENT;
    777          			pCbus->lastCbusSentCmd = pCbus->request[CH_ACTIVE_INDEX].command;
    778          
    779          			if( pCbus->request[CH_ACTIVE_INDEX].command == MHL_CLR_HPD )
    780          			{
    781          				pCbus->hpdWaitTimer = SiiOsTimerTotalElapsed();
    782          			}
    783          			if( (pCbus->request[CH_ACTIVE_INDEX].command == MHL_SET_INT) && (pCbus->request[CH_ACTIVE_INDEX].msgData[0] == BIT2) )
    784          			{
    785          				DEBUG_PRINT( MSG_DBG, "\n\nWaiting for peer to respond to reqWrt!!\n");
    786          				pCbus->reqWrtTimer = SiiOsTimerTotalElapsed();
    787          			}
    788          			if( pCbus->request[ nextIndex].command == MHL_MSC_MSG )
    789          			{
    790          				if( (pCbus->request[ nextIndex].msgData[0] != MHL_MSC_MSG_RCPK) &&
    791          					(pCbus->request[ nextIndex].msgData[0] != MHL_MSC_MSG_RAPK) &&
    792          					(pCbus->request[ nextIndex].msgData[0] != MHL_MSC_MSG_UCPK) )
    793          				{
    794          					pCbus->rcpRapAbortTimer = SiiOsTimerTotalElapsed();
    795          				}
    796          				if( (pCbus->request[ nextIndex].msgData[0] == MHL_MSC_MSG_RCPE) || (pCbus->request[ nextIndex].msgData[0] == MHL_MSC_MSG_UCPE))
    797          				{
    798          					pCbus->rcpeRcpkGapTimer = SiiOsTimerTotalElapsed();
    799          				}
    800          			}
    801          		}
    802          		else
    803          		{
    804                      //  Bug 31921 - Melbourne on power up, Unconnected port to MHL connected port switch not working 
    805          			if( pCbus->request[nextIndex].command == MHL_SET_HPD )
    806          			{
    807          				SiiDrvRxHdcpDdcControl( pCbus->port, false );
    808          				SiiDrvRxEdidDdcControl( pCbus->port, false );
    809          			}
    810          
    811          			result = ERROR_WRITE_FAILED;
    812          		}
    813              }
    814          
    815              return( result );
    816          }
    817          
    818          //------------------------------------------------------------------------------
    819          // Function:    CBusProcessSubCommand
    820          // Description: Process a sub-command
    821          //------------------------------------------------------------------------------
    822          static void CBusProcessSubCommand (uint8_t* vsCmdData)
    823          {
    824              uint8_t vs_cmd, vs_data;
    825          
    826              vs_cmd = vsCmdData[0];
    827              vs_data = vsCmdData[1];
    828          
    829              // Save MSC_MSG data in the request structure to be returned
    830              // to the upper level.
    831          
    832              pCbus->lastCbusRcvdCmd = vs_cmd;
    833              pCbus->lastCbusRcvdData = vs_data;
    834          
    835          //    DEBUG_PRINT( MSG_DBG, "CBUS:: MSG_MSC CMD:  0x%02X\n", vsCmdData[0] );
    836          //    DEBUG_PRINT( MSG_DBG, "CBUS:: MSG_MSC Data: 0x%02X\n", vsCmdData[1] );
    837          }
    838          
    839          //------------------------------------------------------------------------------
    840          // Function:    CBusResetToIdle
    841          // Description: Set the specified channel state to IDLE. Clears any messages that
    842          //              are in progress or queued.  Usually used if a channel connection
    843          //              changed or the channel heartbeat has been lost.
    844          //------------------------------------------------------------------------------
    845          
    846          static void CBusResetToIdle ()
    847          {
    848          	uint8_t port, instanceIndex, supportMask;
    849          
    850          	// we have to preserve the port and instance information
    851          	port = pCbus->port;
    852          	instanceIndex = pCbus->instanceIndex;
    853          	supportMask = pCbus->supportMask;
    854          
    855          	memset( pCbus, 0, sizeof( CbusInstanceData_t ));
    856              memset( &(pCbus->request), 0, sizeof( cbus_req_t ) * CBUS_MAX_COMMAND_QUEUE);
    857          
    858              // fill back the port and instance information
    859          	pCbus->port = port;
    860          	pCbus->instanceIndex = instanceIndex;
    861          	pCbus->supportMask = supportMask;
    862          
    863          }
    864          
    865          
    866          //------------------------------------------------------------------------------
    867          // Function:    CBusSendMscMsgCmd
    868          // Description: Send MSC_MSG message to the specified CBUS channel (port)
    869          //
    870          // Parameters:  subCmd   - MSC_MSG cmd (RCP/RAP/ACP)
    871          //              data     - MSC_MSG data
    872          // Returns:     true     - successful queue/write
    873          //              false    - write and/or queue failed
    874          //------------------------------------------------------------------------------
    875          
    876          bool_t CBusSendMscMsgCmd ( uint8_t subCmd, uint8_t data )
    877          {
    878              cbus_req_t  req;
    879          
    880              // Send MSC_MSG command (Vendor Specific command)
    881          
    882              req.command     = MHL_MSC_MSG;
    883              req.msgData[0]  = subCmd;
    884              req.msgData[1]  = data;
    885          	if( !(CBusWriteCommand(&req)) )
    886          	{
    887          		DEBUG_PRINT( MSG_ALWAYS, "Couldn't send MHL_MSC_MSG to peer\n");
    888          		return false;
    889          	}
    890          	return true;
    891          }
    892          
    893          //------------------------------------------------------------------------------
    894          // Function:    CBusDumpQueueContents
    895          // Description: print the cbus queue contents
    896          // Parameters:  none
    897          // Returns:     void
    898          //------------------------------------------------------------------------------
    899          static void CBusDumpQueueContents ( void )
    900          {
    901          //    int_t   	queueIndex;
    902          //    cbus_req_t 	temp;
    903          //
    904          //    DEBUG_PRINT( MSG_DBG, "SiiMhlRxDumpQueueContents:: ---- \n", pCbus->queueDepth );
    905          //	for ( queueIndex = 0; queueIndex < CBUS_MAX_COMMAND_QUEUE; queueIndex++ )
    906          //	{
    907          //		temp = pCbus->request[ queueIndex];
    908          //		if( temp.reqStatus != CBUS_REQ_IDLE )
    909          //		{
    910          //			DEBUG_PRINT( MSG_DBG, "index: %0x requestStatus: %0x, cmd: %0x, subcmd: %0x, data: %0x \n", queueIndex, temp.reqStatus, temp.command, temp.msgData[0], temp.msgData[1] );
    911          //		}
    912          //	}
    913          }
    914          
    915          //------------------------------------------------------------------------------
    916          // Function:    CBusClearQueueEntry
    917          // Description: clear a particular entry from the queue
    918          // Parameters:  cmd - the one that needs to be removed
    919          // Returns:     void
    920          //------------------------------------------------------------------------------
    921          static void CBusClearQueueEntry ( uint8_t cmd )
    922          {
    923              int_t   	queueIndex;
    924          
    925          //    DEBUG_PRINT( MSG_DBG, "CBusClearQueueEntry:: clearing cmd: %02X\n", cmd );
    926          	for ( queueIndex = 0; queueIndex < CBUS_MAX_COMMAND_QUEUE; queueIndex++ )
    927          	{
    928          		if( pCbus->request[queueIndex].command == cmd )
    929          		{
    930          			memset( &(pCbus->request[queueIndex]), 0, sizeof( cbus_req_t ) );
    931          			break;
    932          		}
    933          	}
    934          }
    935          
    936          //------------------------------------------------------------------------------
    937          // Function:    CBusWriteCommand
    938          // Description: Place a command in the CBUS message queue.
    939          //
    940          // Parameters:  pReq    - Pointer to a cbus_req_t structure containing the
    941          //                        command to write
    942          // Returns:     true    - successful queue/write
    943          //              false   - write and/or queue failed
    944          //------------------------------------------------------------------------------
    945          
    946          static bool_t CBusWriteCommand ( cbus_req_t *pReq  )
    947          {
    948              int_t   queueIndex, loop_count = 0;
    949              bool_t  success = false;
    950          
    951              /* Copy the request to the queue.   */
    952          
    953              if( SiiMhlRxCbusConnected() )
    954              {
    955              	queueIndex = (CH_ACTIVE_INDEX == ( CBUS_MAX_COMMAND_QUEUE - 1 )) ? 0 : (CH_ACTIVE_INDEX + 1);
    956          		for ( loop_count = 0; loop_count < CBUS_MAX_COMMAND_QUEUE; loop_count++ )
    957          		{
    958          			if ( pCbus->request[ queueIndex].reqStatus == CBUS_REQ_IDLE )
    959          			{
    960          				// Found an idle queue entry, copy the request and set to pending.
    961          
    962          				memcpy( &pCbus->request[ queueIndex], pReq, sizeof( cbus_req_t ));
    963          				pCbus->request[ queueIndex].reqStatus = CBUS_REQ_PENDING;
    964          				pCbus->queueDepth++;
    965          				success = true;
    966          //				DEBUG_PRINT( MSG_DBG, "\nCBUS:: CBusWriteCommand:: Queue Depth: %02X\n", pCbus->queueDepth );
    967          				break;
    968          			}
    969          			queueIndex++;
    970          			if( queueIndex == CBUS_MAX_COMMAND_QUEUE )
    971          			{
    972          				queueIndex = 0;
    973          			}
    974          		}
    975          
    976          		if ( !success )
    977          		{
    978          			DEBUG_PRINT( MSG_DBG, "\nCBUS:: Queue Full\n" );
    979          			for ( queueIndex = 0; queueIndex < CBUS_MAX_COMMAND_QUEUE; queueIndex++ )
    980          			{
    981          				DEBUG_PRINT( MSG_DBG, "\nCBUS:: CBusWriteCommand:: Queue Index: %02X, Cmd: %02X data: %02X\n",
    982          						queueIndex, pCbus->request[ queueIndex].command, pCbus->request[ queueIndex].offsetData );
    983          			}
    984          		}
    985              }
    986              else
    987              {
    988              	DEBUG_PRINT( MSG_DBG, "CBus is not connected yet! MHL command could not be sent!\n" );
    989              }
    990          
    991              return( success );
    992          }
    993          
    994          //------------------------------------------------------------------------------
    995          // Function:    CBusWritePeersScratchpad
    996          // Description: sends MHL write burst cmd
    997          //------------------------------------------------------------------------------
    998          static bool_t CBusWritePeersScratchpad()
    999          {
   1000          	cbus_req_t req;
   1001          
   1002          	req.command = MHL_WRITE_BURST;
   1003          	req.offsetData = pCbus->wbStartOffset;
   1004          	req.length = pCbus->wbLength;
   1005          
   1006          	if( !(CBusWriteCommand(&req)) )
   1007          	{
   1008          		DEBUG_PRINT( MSG_ALWAYS, "Couldn't send Write Burst to peer\n" );
   1009          		return false;
   1010          	}
   1011          
   1012          	return true;
   1013          }
   1014          
   1015          //------------------------------------------------------------------------------
   1016          // Function:    CBusCheckInterruptStatus
   1017          // Description: If any interrupts on the specified channel are set, process them.
   1018          // Parameters:  none
   1019          // Returns:     success or error code
   1020          //------------------------------------------------------------------------------
   1021          static uint8_t CBusCheckInterruptStatus ( void )
   1022          {
   1023              uint8_t result;
   1024              uint8_t busStatus;
   1025              uint8_t	temp;
   1026              uint8_t data[2];
   1027          #if ( configSII_DEV_953x_PORTING == 1 )
   1028              result = CBUS_SUCCESS;
   1029          #else
   1030          result = SUCCESS;
   1031          #endif 
   1032          
   1033              if ( SiiDrvCbusIntrFlagGet() )
   1034              {
   1035                  if ( SiiDrvCbusVsDataGet( &data[0] ) )
   1036                  {
   1037                      CBusProcessSubCommand( &data[0] );
   1038                      pCbus->state |= CBUS_RECEIVED;
   1039                  }
   1040                  if ( SiiDrvCbusCmdRetDataGet( &pCbus->request[ CH_ACTIVE_INDEX ].msgData[0] ) )
   1041                  {
   1042                  	pCbus->state &= ~CBUS_SENT;
   1043          
   1044          			/* A previous MSC sub-command has been acknowledged by the responder.   */
   1045          			pCbus->state |= CBUS_XFR_DONE;
   1046          
   1047                  }
   1048                  else
   1049                  {
   1050              		if( SiiDrvCbusDdcAbortReasonGet( &temp ) )
   1051              		{
   1052              			DEBUG_PRINT( MSG_DBG, "CBUS DDC ABORT happened, reason: %02X\n", temp );
   1053              			pCbus->state &= ~CBUS_SENT;
   1054              			pCbus->abortTimer = SiiOsTimerTotalElapsed();
   1055              			result = ERROR_CBUS_ABORT;
   1056              			pCbus->state |= CBUS_FAILED;
   1057              		}
   1058          
   1059          
   1060              		if ( SiiDrvCbusMscAbortTransReasonGet( &temp ) )
   1061              		{
   1062              			DEBUG_PRINT( MSG_DBG, "MSC CMD aborted (this device was a transmitter), reason: %02X\n", temp );
   1063              			pCbus->state &= ~CBUS_SENT;
   1064              			pCbus->abortTimer = SiiOsTimerTotalElapsed();
   1065              			result = ERROR_CBUS_ABORT;
   1066              			pCbus->state |= CBUS_FAILED;
   1067              		}
   1068          
   1069              		if ( SiiDrvCbusMscAbortRcvrReasonGet( &temp ) )
   1070              		{
   1071              			DEBUG_PRINT( MSG_DBG, "MSC CMD aborted (this device was a receiver) , reason: %02X\n", temp );
   1072              			pCbus->state &= ~CBUS_SENT;
   1073              			pCbus->abortTimer = SiiOsTimerTotalElapsed();
   1074              			result = ERROR_CBUS_ABORT;
   1075              			pCbus->state |= CBUS_FAILED;
   1076              		}
   1077                  }
   1078          
   1079                  if ( SiiDrvCbusBusStatusGet( &busStatus ) )
   1080                  {
   1081                  	/* The connection change interrupt has been received.   */
   1082          			pCbus->connected = busStatus ? true : false;
   1083                  	DEBUG_PRINT( MSG_DBG, "\nCBUS:: ----Connection Change---- %s \n", pCbus->connected ? "Connected" : "Disconnected" );
   1084          			if( pCbus->connected )
   1085          			{
   1086          				pCbus->initTimer = SiiOsTimerTotalElapsed();
   1087          			}
   1088          			else
   1089          			{
   1090          				//set the cbus to idle
   1091          				CBusResetToIdle();
   1092          			}
   1093          
   1094          			SiiMhlCbRxConnectChange(pCbus->connected);
   1095                  }
   1096          
   1097              	// request received from peer to write into scratchpad
   1098              	if ( SiiDrvCbusReqWrtGet() )
   1099              	{
   1100              		if( !(pCbus->miscFlags & FLAGS_SCRATCHPAD_BUSY) )
   1101          			{
   1102          //				DEBUG_PRINT( MSG_DBG, "\n\ngranting peer's request to write scratchpad!!\n");
   1103          				CBusGrtWrt();
   1104          				pCbus->miscFlags |= FLAGS_SCRATCHPAD_BUSY;
   1105          			}
   1106          			else
   1107          			{
   1108          				DEBUG_PRINT( MSG_DBG, "\nGot request from peer for scratchpad write, "
   1109          						"couldn't grant request as the scartchpad is busy!!\n" );
   1110          			}
   1111          		}
   1112          
   1113              	// scratchpad write notification received from peer
   1114              	if ( SiiDrvCbusScratchpadWrtnGet() )
   1115          		{
   1116              		pCbus->miscFlags &= ~FLAGS_SCRATCHPAD_BUSY;
   1117          			// send it to app layer
   1118          			SiiMhlCbRxScratchpadWritten();
   1119          		}
   1120          
   1121              	// request to write into peer's scratchpad is granted
   1122              	if ( SiiDrvCbusGrtWrtGet() )
   1123              	{
   1124          //    		DEBUG_PRINT( MSG_DBG, "\n\npeer sent grtWrt!!\n");
   1125              		if( pCbus->miscFlags & FLAGS_SCRATCHPAD_BUSY )
   1126          			{
   1127          				pCbus->reqWrtTimer = 0;
   1128          				CBusWritePeersScratchpad();
   1129          			}
   1130                  }
   1131          
   1132          #if (MHL_EXTRA == ENABLE)
   1133              	// request to send over 3D information
   1134          //    	if ( SiiDrvCbus3DReqGet() )
   1135          //    	{
   1136          //    		DEBUG_PRINT( MSG_DBG, "\n\npeer sent 3D data request!!\n");
   1137          //    		pCbus->serving3dVicReq = true;
   1138          //    		CBusSend3DInfo();
   1139          //        }
   1140          #endif
   1141          #if (MHL_20 == ENABLE)
   1142              	// request to send over 3D information
   1143              	if ( SiiDrvCbus3DReqGet() )
   1144              	{
   1145              		DEBUG_PRINT( MSG_DBG, "\n\n************* peer sent 3D data request!! ********************\n");
   1146              		pCbus->sending_3D_info = true;
   1147              		pCbus->cbus3Dstate = WB_3D_SENDING_VIC;
   1148              		seq = 0;
   1149              		CBusSend3DInfo();
   1150                  }
   1151          #endif
   1152          
   1153              }
   1154          
   1155              SiiDrvCbusIntrFlagSet();
   1156              SiiDrvCbusInterruptStatusSet();
   1157              return( result );
   1158          }
   1159          
   1160          #if (MHL_EXTRA == ENABLE)
   1161          //------------------------------------------------------------------------------
   1162          // Function:    CalculateChecksum_3D
   1163          // Description: Calculate the checksum
   1164          // Parameters:  pData - pointer to data
   1165          //                     length - length of data
   1166          // Returns:     void
   1167          //------------------------------------------------------------------------------
   1168          static uint8_t CalculateChecksum_3D(uint8_t *pData, uint8_t length)
   1169          		{
   1170              uint8_t i;
   1171              uint8_t checksum = 0;
   1172          
   1173              for (i = 0; i < length; i++)
   1174          	{
   1175                  if (i==2) continue;
   1176                  checksum += pData[i];
   1177          	}
   1178          
   1179              return (0 - checksum);
   1180          }
   1181          
   1182          //------------------------------------------------------------------------------
   1183          // Function:    setVICdata
   1184          // Description: set up VIC data for 3D info
   1185          // Parameters:  pReq - pointer to cbus_req_t
   1186          //                     seq - sequence number
   1187          // Returns:     void
   1188          //------------------------------------------------------------------------------
   1189          static void setVICdata( cbus_req_t *pReq, int seq )
   1190          				{
   1191          	int i;
   1192          	int num_ent = 0;
   1193          	uint8_t rest_ent;
   1194          
   1195          	memset(&(pReq->msgData), 0, MHL_MAX_BUFFER_SIZE);
   1196          
   1197          #if 0
   1198          	DEBUG_PRINT( MSG_DBG, "gMHL3D_VIC[0]\n");
   1199          	DEBUG_PRINT( MSG_DBG, "TOT : %02X\n", gMHL3D_VIC[0].tot);
   1200          	for (i=0; i<16; i++){
   1201          		DEBUG_PRINT( MSG_DBG, "VDI%02X_L : %02X\n", i, gMHL3D_VIC[0].vdi[i].vdi_l);
   1202          		DEBUG_PRINT( MSG_DBG, "VDI%02X_H : %02X\n", i, gMHL3D_VIC[0].vdi[i].vdi_h);
   1203          				}
   1204          	DEBUG_PRINT( MSG_DBG, "gMHL3D_VIC[1]\n");
   1205          	DEBUG_PRINT( MSG_DBG, "TOT : %02X\n", gMHL3D_VIC[1].tot);
   1206          	for (i=0; i<16; i++){
   1207          		DEBUG_PRINT( MSG_DBG, "VDI%02X_L : %02X\n", i, gMHL3D_VIC[1].vdi[i].vdi_l);
   1208          		DEBUG_PRINT( MSG_DBG, "VDI%02X_H : %02X\n", i, gMHL3D_VIC[1].vdi[i].vdi_h);
   1209          			}
   1210          #endif
   1211          
   1212          #if ( MHL_20 == ENABLE )  /*Smith modifies: Fix building error when MHL20 == DISABLE*/
   1213          	pReq->msgData[0] = BURST_3D_VIC_H;
   1214          	pReq->msgData[1] = BURST_3D_VIC_L;
   1215          
   1216          	pReq->msgData[3] = pMHL3D_VIC->tot;  // total entries of VICs
   1217          	if( pMHL3D_VIC->tot )
   1218          	{
   1219          		pReq->msgData[4] = seq + 1;
   1220          	}
   1221          
   1222          	if (pReq->msgData[3] !=0){
   1223          		rest_ent = pMHL3D_VIC->tot - seq * 5;
   1224          		num_ent = (rest_ent > 5)? 5 : rest_ent;
   1225          		pReq->msgData[5] = num_ent;
   1226          		for (i=0; i<num_ent; i++){
   1227          			pReq->msgData[7 + i*2] = pMHL3D_VIC->vdi[seq * 5 + i].vdi_l;
   1228          		}
   1229          			}
   1230          
   1231          	pReq->msgData[2] = CalculateChecksum_3D(pReq->msgData, num_ent*2 + 6);
   1232          
   1233          	pReq->offsetData = 0x00;  // 0x40 will be added as offset 
   1234          	pReq->length = num_ent*2 + 6;
   1235          
   1236          	for (i=0; i<num_ent*2+6; i++){
   1237          		DEBUG_PRINT( MSG_DBG, "CBUS 3D(VIC) WRITE_BURST - %02X : %02X\n", i, pReq->msgData[i] );
   1238          	}
   1239          #endif 	
   1240          }
   1241          
   1242          //------------------------------------------------------------------------------
   1243          // Function:    setDTDdata
   1244          // Description: set up VIC data for 3D info
   1245          // Parameters:  pReq - pointer to cbus_req_t
   1246          //                     seq - sequence number
   1247          // Returns:     void
   1248          //------------------------------------------------------------------------------
   1249          static void setDTDdata( cbus_req_t *pReq, int seq )
   1250          				{
   1251          	int i;
   1252          	int num_ent = 0;
   1253          	uint8_t rest_ent;
   1254          
   1255          	memset(&(pReq->msgData), 0, MHL_MAX_BUFFER_SIZE);
   1256          
   1257          #if (MHL_20 == ENABLE)  /*Smith modifies*/
   1258          	pReq->msgData[0] = BURST_3D_DTD_H;
   1259          	pReq->msgData[1] = BURST_3D_DTD_L;
   1260          
   1261          	pReq->msgData[3] = pMHL3D_DTD->tot;  // total entries of VICs
   1262          	if( pMHL3D_DTD->tot )
   1263          	{
   1264          		pReq->msgData[4] = seq + 1;
   1265          	}
   1266          
   1267          	if (pReq->msgData[3] !=0){
   1268          		rest_ent = pMHL3D_DTD->tot - seq * 5;
   1269          		num_ent = (rest_ent > 5)? 5 : rest_ent;
   1270          		pReq->msgData[5] = num_ent;
   1271          		for (i=0; i<num_ent; i++){
   1272          			pReq->msgData[7 + i*2] = pMHL3D_DTD->vdi[seq * 5 + i].vdi_l;
   1273          				}
   1274          			}
   1275          
   1276          	pReq->msgData[2] = CalculateChecksum_3D(pReq->msgData, num_ent*2 + 6);
   1277          
   1278          	pReq->offsetData = 0x00;  // 0x40 will be added as offset 
   1279          	pReq->length = num_ent*2 + 6;
   1280          
   1281          	for (i=0; i<num_ent*2+6; i++){
   1282          		DEBUG_PRINT( MSG_DBG, "CBUS 3D(DTD) WRITE_BURST - %02X : %02X\n", i, pReq->msgData[i] );
   1283          		}
   1284          #endif
   1285          
   1286          }
   1287          
   1288          	
   1289          
   1290          //------------------------------------------------------------------------------
   1291          // Function:    CBusSend3DInfo
   1292          // Description: send over 3D write bursts
   1293          // Parameters:  none
   1294          // Returns:     void
   1295          //------------------------------------------------------------------------------
   1296          static void CBusSend3DInfo()
   1297          {
   1298          	cbus_req_t 	req;
   1299          
   1300          #if (MHL_20 == ENABLE) /*Smith modifies*/
   1301          
   1302          	switch (pCbus->cbus3Dstate){
   1303          
   1304          		case WB_3D_IDLE:
   1305          			pCbus->sending_3D_info = false;
   1306          			break;
   1307          
   1308          		case WB_3D_SENDING_VIC:  // granted, start sending VICs
   1309          			// if need to send more VICs, send REQ_WRT and go to STEP 2
   1310          			if (pMHL3D_VIC->tot == 0)
   1311          			{
   1312          				setVICdata(&req, seq);
   1313          				SiiMhlRxWritePeerScratchpad(req.offsetData, req.length, &(req.msgData[0]));
   1314          				pCbus->cbus3Dstate = WB_3D_SENDING_DTD;
   1315          			}
   1316          			else if ((pMHL3D_VIC->tot - seq * 5) > 0)
   1317          			{
   1318          				setVICdata(&req, seq);
   1319          				SiiMhlRxWritePeerScratchpad(req.offsetData, req.length, &(req.msgData[0]));
   1320          				seq++;
   1321          				if ((pMHL3D_VIC->tot - seq * 5) <= 0)
   1322          				{
   1323          					seq = 0;
   1324          					pCbus->cbus3Dstate = WB_3D_SENDING_DTD;
   1325          				}
   1326          				DEBUG_PRINT( MSG_DBG, "CBUS State: %02X seq:: %02X\n", pCbus->cbus3Dstate, seq );
   1327          			}
   1328          
   1329          			break;
   1330          
   1331          		case WB_3D_SENDING_DTD:  // granted, start sending DTDs
   1332          			if (pMHL3D_DTD->tot == 0)
   1333          			{
   1334          				setDTDdata(&req, seq);
   1335          				SiiMhlRxWritePeerScratchpad(req.offsetData, req.length, &(req.msgData[0]));
   1336          				pCbus->cbus3Dstate = WB_3D_IDLE;
   1337          			}
   1338          			else if ((pMHL3D_DTD->tot - seq * 5) > 0)
   1339          			{
   1340          				setDTDdata(&req, seq);
   1341          				SiiMhlRxWritePeerScratchpad(req.offsetData, req.length, &(req.msgData[0]));
   1342          				seq++;
   1343          				if ((pMHL3D_DTD->tot - seq*5) <= 0)
   1344          				{
   1345          					seq = 0;
   1346          					pCbus->cbus3Dstate = WB_3D_IDLE;
   1347          				}
   1348          			}
   1349          			DEBUG_PRINT( MSG_DBG, "CBUS State: %02X seq:: %02X\n", pCbus->cbus3Dstate, seq );
   1350          			break;
   1351          	}
   1352          #endif 
   1353          
   1354          }
   1355          #endif
   1356          
   1357          //------------------------------------------------------------------------------
   1358          // Function:    CBusSendDcapRdyMsg
   1359          // Description: Send a msg to peer informing the devive capability registers are
   1360          //				ready to be read.
   1361          // Returns:     TRUE    - success
   1362          //              FALSE   - failure
   1363          //------------------------------------------------------------------------------
   1364          
   1365          static bool_t CBusSendDcapRdyMsg ()
   1366          {
   1367          	bool_t result = true;
   1368          
   1369          	if( SiiMhlRxCbusConnected() )
   1370          	{
   1371          //		DEBUG_PRINT( MSG_DBG, ( "cbusSendDcapRdyMsg() Called!!\n"));
   1372          		pCbus->miscFlags |= FLAGS_SENT_DCAP_RDY;
   1373          
   1374          		//send a msg to peer that the device capability registers are ready to be read.
   1375          		//set DCAP_RDY bit
   1376          		result = CBusSendDcapRdy();
   1377          
   1378          		//set DCAP_CHG bit
   1379          		result = SiiMhlRxSendDevCapChange();
   1380          	}
   1381          
   1382          	return result;
   1383          }
   1384          
   1385          //------------------------------------------------------------------------------
   1386          // Function:    CBusSendMscCommand
   1387          // Description: sends general MHL commands
   1388          //------------------------------------------------------------------------------
   1389          /*static */bool_t CBusSendMscCommand(uint8_t cmd)
   1390          {
   1391          	cbus_req_t 	req;
   1392          	bool_t		success = true;
   1393          
   1394          	req.command = cmd;
   1395          
   1396          	switch(cmd)
   1397          	{
   1398          		case MHL_GET_STATE:
   1399          		case MHL_GET_VENDOR_ID:
   1400          		case MHL_SET_HPD:
   1401          		case MHL_CLR_HPD:
   1402          		case MHL_GET_SC1_ERRORCODE:
   1403          		case MHL_GET_DDC_ERRORCODE:
   1404          		case MHL_GET_MSC_ERRORCODE:
   1405          		case MHL_GET_SC3_ERRORCODE:
   1406          
   1407          			if( !(success = CBusWriteCommand(&req)) )
   1408          			{
   1409          				DEBUG_PRINT( MSG_ALWAYS, "Couldn't send cmd: %02X to peer\n", cmd );
   1410          				return false;
   1411          			}
   1412          			break;
   1413          
   1414          		default:
   1415          			DEBUG_PRINT( MSG_ALWAYS, "Invalid command send request!!\n", cmd );
   1416          			success = false;
   1417          	}
   1418          	return success;
   1419          }
   1420          
   1421          //------------------------------------------------------------------------------
   1422          // Function:    CBusSetInt
   1423          // Description: write peer's status registers
   1424          //				regOffset - peer's register offset
   1425          //				regBit - bit to be set
   1426          //------------------------------------------------------------------------------
   1427          static bool_t CBusSetInt ( uint8_t regOffset, uint8_t regBit )
   1428          {
   1429          	cbus_req_t req;
   1430          
   1431          	req.command = MHL_SET_INT;
   1432          	req.offsetData = regOffset;
   1433          	req.msgData[0] = regBit;
   1434          
   1435          	if( SiiMhlRxCbusConnected() )
   1436          	{
   1437          		if( !(CBusWriteCommand(&req)) )
   1438          		{
   1439          			DEBUG_PRINT( MSG_ALWAYS, "Couldn't send MHL_SET_INT to peer\n" );
   1440          			return false;
   1441          		}
   1442          	}
   1443          	return true;
   1444          }
   1445          
   1446          //------------------------------------------------------------------------------
   1447          // Function:    CBusSendDscrChange
   1448          //------------------------------------------------------------------------------
   1449          static bool_t CBusSendDscrChange ()
   1450          {
   1451          	return ( CBusSetInt(0x00, BIT1) );
   1452          }
   1453          
   1454          //------------------------------------------------------------------------------
   1455          // Function:    CBusReqWrt
   1456          //------------------------------------------------------------------------------
   1457          static bool_t CBusReqWrt ()
   1458          {
   1459          	return ( CBusSetInt(0x00, BIT2) );
   1460          }
   1461          
   1462          //------------------------------------------------------------------------------
   1463          // Function:    CBusGrtWrt
   1464          // Description:
   1465          //------------------------------------------------------------------------------
   1466          static bool_t CBusGrtWrt ()
   1467          {
   1468          	return ( CBusSetInt(0x00, BIT3) );
   1469          }
   1470          
   1471          //------------------------------------------------------------------------------
   1472          // Function:    CBusWriteStatus
   1473          // Description: write peer's status registers
   1474          // Parameters:  regOffset - peer's register offset
   1475          //				value - value to be written
   1476          //------------------------------------------------------------------------------
   1477          static bool_t CBusWriteStatus ( uint8_t regOffset, uint8_t value )
   1478          {
   1479          	cbus_req_t req;
   1480          
   1481          	req.command = MHL_WRITE_STAT;
   1482          	req.offsetData = regOffset;
   1483          	req.msgData[0] = value;
   1484          
   1485          	if( !(CBusWriteCommand(&req)) )
   1486          	{
   1487          		DEBUG_PRINT( MSG_ALWAYS, "Couldn't send MHL_WRITE_STAT to peer\n" );
   1488          		return false;
   1489          	}
   1490          
   1491          	return true;
   1492          }
   1493          
   1494          //------------------------------------------------------------------------------
   1495          // Function:    CBusSendDcapRdy
   1496          //------------------------------------------------------------------------------
   1497          static bool_t CBusSendDcapRdy ()
   1498          {
   1499          	return ( CBusWriteStatus(0x00, BIT0) );
   1500          
   1501          }
   1502          
   1503          static bool_t CBusTimerExpired(clock_time_t *pTimer, uint16_t waitTime)
   1504          {
   1505          	if( (*pTimer > 0) && ((SiiOsTimerTotalElapsed() - *pTimer ) > waitTime) )
   1506          	{
   1507          //		DEBUG_PRINT( MSG_DBG, "\n*pTimer = %02X SiiOsTimerTotalElapsed(): %02X\n", *pTimer, SiiOsTimerTotalElapsed());
   1508          		*pTimer = 0;
   1509          		return true;
   1510          	}
   1511          	else
   1512          	{
   1513          		return false;
   1514          	}
   1515          
   1516          }
   1517          
   1518          // This is to check all the Timers
   1519          static void CBusChkTimers ()
   1520          {
   1521          	CBusTimerExpired(&(pCbus->hpdWaitTimer), CBUS_HPD_WAIT_TIMER);
   1522          	CBusTimerExpired(&(pCbus->abortTimer), CBUS_ABORT_TIMER);
   1523          	CBusTimerExpired(&(pCbus->initTimer), CBUS_INIT_TIMER);
   1524          	CBusTimerExpired(&(pCbus->rcpeRcpkGapTimer), CBUS_RCPE_RCPK_GAP_TIMER);
   1525          
   1526          	if( CBusTimerExpired(&(pCbus->reqWrtTimer), CBUS_WB_REQ_TIMER) )
   1527          	{
   1528          		CBusClearQueueEntry( MHL_WRITE_BURST );
   1529          		pCbus->miscFlags &= ~FLAGS_SCRATCHPAD_BUSY;
   1530          		DEBUG_PRINT( MSG_DBG, "GrtWrt interrupt did not come from peer within the timeout limit!! \n");
   1531          	}
   1532          
   1533          	if( CBusTimerExpired(&(pCbus->waitTimer), CBUS_MSG_RSP_TIMER) )
   1534          	{
   1535          		pCbus->state |= CBUS_FAILED;
   1536          		DEBUG_PRINT( MSG_DBG, "\npCbus->waitTimer = %02X \n", pCbus->waitTimer);
   1537          	}
   1538          
   1539          	if( CBusTimerExpired(&(pCbus->rcpRapAbortTimer), CBUS_RCP_RCP_ABORT_TIMER) )
   1540          	{
   1541          		pCbus->state |= CBUS_FAILED;
   1542          		DEBUG_PRINT( MSG_DBG, "Ack didn't come back for MSC_MSG cmd for %02X milliseconds.\n", pCbus->rcpRapAbortTimer);
   1543          	}
   1544          
   1545          }
   1546          
   1547          #if (MHL_20 == ENABLE)
   1548          static void CBus3DInstanceSet( uint_t instanceIndex )
   1549          {
   1550          	pMHL3D_VIC = &gMHL3D_VIC[instanceIndex];
   1551          	pMHL3D_DTD = &gMHL3D_DTD[instanceIndex];
   1552          }
   1553          
   1554          static void CBus3DCheckInstance ( uint_t instanceIndex )
   1555          {
   1556          #if INC_RTPI
   1557          	uint_t port;
   1558          	uint8_t tx_video_src;
   1559          #endif
   1560          	
   1561          	if (!SiiDrvSwitchMatrixModeEnableGet())
   1562          	{
   1563          		// InstaPort mode
   1564          		CBus3DInstanceSet( 0 );
   1565          		return;
   1566          	}
   1567          #if INC_RTPI
   1568          	// Matrix mode
   1569          	port = (instanceIndex == 0)? 0 : 5;
   1570          	tx_video_src = SiiDrvSwitchStateGet(SiiSwitch_TX_VIDEO_SRC);
   1571          	if (SiiDrvSwitchStateGet(SiiSwitch_SELECTED_PORT) == port){
   1572          		// port is main
   1573          		if ((tx_video_src & 0x0c) == 0x00) CBus3DInstanceSet(0);  // Tx0 is main
   1574          		else if ((tx_video_src & 0x30) == 0x00) CBus3DInstanceSet(1);  // Tx1 is main
   1575          	}
   1576          	else if (SiiDrvSwitchStateGet(SiiSwitch_SELECTED_PORT_SUB) == port){
   1577          		// port is sub
   1578          		if ((tx_video_src & 0x0c) == 0x04) CBus3DInstanceSet(0);  // Tx0 is sub
   1579          		else if ((tx_video_src & 0x30) == 0x10) CBus3DInstanceSet(1);  // Tx1 is sub
   1580          	}
   1581          #endif
   1582          }
   1583          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       32  CBusCheckInterruptStatus
             32 -> CBusSetInt
             32 -> CBusWritePeersScratchpad
             32 -> SiiDrvCbusBusStatusGet
             32 -> SiiDrvCbusCmdRetDataGet
             32 -> SiiDrvCbusDdcAbortReasonGet
             32 -> SiiDrvCbusGrtWrtGet
             32 -> SiiDrvCbusInterruptStatusSet
             32 -> SiiDrvCbusIntrFlagGet
             32 -> SiiDrvCbusIntrFlagSet
             32 -> SiiDrvCbusMscAbortRcvrReasonGet
             32 -> SiiDrvCbusMscAbortTransReasonGet
             32 -> SiiDrvCbusReqWrtGet
             32 -> SiiDrvCbusScratchpadWrtnGet
             32 -> SiiDrvCbusVsDataGet
             32 -> SiiMhlCbRxConnectChange
             32 -> SiiMhlCbRxScratchpadWritten
             32 -> SiiOsTimerTotalElapsed
             32 -> __aeabi_memclr
             32 -> __aeabi_memclr4
        8  CBusChkTimers
              8 -> CBusTimerExpired
              8 -> __aeabi_memclr
       24  CBusSendMscCommand
             24 -> CBusWriteCommand
       24  CBusSendMscMsgCmd
             24 -> CBusWriteCommand
       24  CBusSendNextInQueue
             24 -> SiiDrvInternalCBusWriteCommand
             24 -> SiiDrvRxEdidDdcControl
             24 -> SiiDrvRxHdcpDdcControl
             24 -> SiiOsTimerTotalElapsed
       24  CBusSetInt
             24 -> CBusWriteCommand
       16  CBusTimerExpired
             16 -> SiiOsTimerTotalElapsed
       20  CBusWriteCommand
             20 -> __aeabi_memcpy
       24  CBusWritePeersScratchpad
             24 -> CBusWriteCommand
       24  CBusWriteStatus
             24 -> CBusWriteCommand
        0  SiiCbusConfigure
              0 -> SiiDrvCbusConfigure
        8  SiiCbusInstanceSet
              8 -> SiiDrvCbusInstanceSet
        8  SiiCbusInstanceSetBasedOnPort
              0 -> SiiCbusInstanceSet
        0  SiiCbusResume
        0  SiiCbusStandby
        0  SiiCbusStatus
        8  SiiMhlCbHpdSetState
              0 -> SiiMhlRxHpdSet
              8 -> SiiMhlRxHpdSet
        0  SiiMhlRxCbusConnected
        0  SiiMhlRxChannelEnable
              0 -> SiiDrvCbusChnEn
        0  SiiMhlRxGetMscMsgCmd
       16  SiiMhlRxHandler
             16 -> CBusCheckInterruptStatus
             16 -> CBusChkTimers
             16 -> CBusSendNextInQueue
             16 -> CBusSetInt
             16 -> CBusWriteStatus
             16 -> CbusProcessRcpRap
             16 -> SiiMhlCbRxMscCmdResponseData
             16 -> SiiMhlRxHpdSet
             16 -> SiiMhlRxSendDevCapChange
             16 -> SkAppCbusCecSendVendorId
             16 -> __aeabi_memclr
        8  SiiMhlRxHpdSet
              8 -> CBusSendMscCommand
              8 -> SiiMhlRxPathEnable
              8 -> SiiRegWrite
       16  SiiMhlRxInitialize
              0 -> SiiDrvCbusInitialize
             16 -> __aeabi_memclr
             16 -> __aeabi_memclr4
        0  SiiMhlRxIsQueueEmpty
        0  SiiMhlRxIsQueueFull
        8  SiiMhlRxPathEnable
              8 -> CBusWriteStatus
       24  SiiMhlRxReadDevCapReg
             24 -> CBusWriteCommand
        0  SiiMhlRxSendDevCapChange
              0 -> CBusSetInt
        0  SiiMhlRxSendEdidChange
              0 -> CBusSetInt
        0  SiiMhlRxSendMsge
              0 -> CBusSendMscMsgCmd
        0  SiiMhlRxSendRAPCmd
              0 -> CBusSendMscMsgCmd
        0  SiiMhlRxSendRapk
              0 -> CBusSendMscMsgCmd
        0  SiiMhlRxSendRcpe
              0 -> CBusSendMscMsgCmd
        0  SiiMhlRxSendRcpk
              0 -> CBusSendMscMsgCmd
        0  SiiMhlRxSendUCPCmd
              0 -> CBusSendMscMsgCmd
        0  SiiMhlRxSendUcpe
              0 -> CBusSendMscMsgCmd
        0  SiiMhlRxSendUcpk
              0 -> CBusSendMscMsgCmd
       16  SiiMhlRxWritePeerScratchpad
             16 -> CBusSetInt
             16 -> SiiDrvCbusWriteLocalScratchpad


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
      14  ?Subroutine0
      14  ?Subroutine1
      14  ?Subroutine2
      16  ?Subroutine3
      10  ?Subroutine4
      16  ?Subroutine5
       8  ?Subroutine6
     306  CBusCheckInterruptStatus
     154  CBusChkTimers
      40  CBusSendMscCommand
      26  CBusSendMscMsgCmd
     332  CBusSendNextInQueue
      40  CBusSetInt
      34  CBusTimerExpired
      90  CBusWriteCommand
      28  CBusWritePeersScratchpad
      18  CBusWriteStatus
      16  SiiCbusConfigure
      40  SiiCbusInstanceSet
      46  SiiCbusInstanceSetBasedOnPort
       4  SiiCbusResume
       4  SiiCbusStandby
      10  SiiCbusStatus
      38  SiiMhlCbHpdSetState
      10  SiiMhlRxCbusConnected
      12  SiiMhlRxChannelEnable
      20  SiiMhlRxGetMscMsgCmd
     326  SiiMhlRxHandler
      68  SiiMhlRxHpdSet
      34  SiiMhlRxInitialize
      36  SiiMhlRxIsQueueEmpty
      34  SiiMhlRxIsQueueFull
      52  SiiMhlRxPathEnable
      34  SiiMhlRxReadDevCapReg
       6  SiiMhlRxSendDevCapChange
       6  SiiMhlRxSendEdidChange
       6  SiiMhlRxSendMsge
       6  SiiMhlRxSendRAPCmd
       6  SiiMhlRxSendRapk
       6  SiiMhlRxSendRcpe
       6  SiiMhlRxSendRcpk
       6  SiiMhlRxSendUCPCmd
       6  SiiMhlRxSendUcpe
       6  SiiMhlRxSendUcpk
      52  SiiMhlRxWritePeerScratchpad
     632  cbusInstance
       4  pCbus

 
   632 bytes in section .bss
     4 bytes in section .data
 2 064 bytes in section .text
 
 2 064 bytes of CODE memory
   636 bytes of DATA memory

Errors: none
Warnings: 12

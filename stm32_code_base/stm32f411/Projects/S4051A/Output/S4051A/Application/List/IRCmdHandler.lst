###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:25:37 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\APP_SRC\Managers\IRCmdHandler.c       #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\APP_SRC\Managers\IRCmdHandler.c -D    #
#                    S4051A -D DEBUG -D FREE_RTOS -D STM32F40_41xxx -D        #
#                    USE_STM324xG_EVAL -D USE_STDPERIPH_DRIVER -D             #
#                    __ARM_CORTEX_MX__ -D IAR_ARM_CM4F -D USE_USB_OTG_FS      #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applicati #
#                    on\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Ap #
#                    plication\Obj\ --debug --endian=little --cpu=Cortex-M4   #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\IRCmdHandler.lst                                      #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\IRCmdHandler.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Projects\S4051A\APP_SRC\Managers\IRCmdHandler.c
      1          /* Scheduler includes. */
      2          #include "freertos_conf.h"
      3          #include "freertos_task.h"
      4          #include "freertos_typedef.h"
      5          #include "api_typedef.h"
      6          
      7          #include "device_config.h"
      8          #include "command.h"
      9          #include "Debug.h"
     10          
     11          #include "HMI_Service.h" 
     12          #include "IRKeyCode.h"
     13          #include "IRLowLevel.h"
     14          #include "IRCmdHandler.h"
     15          #include "PowerHandler.h"
     16          #include "StorageDeviceManager.h"
     17          #include "UIDeviceManager.h"
     18          //____________________________________________________________________________________________________________
     19          #define IR_BUILD_DEBUG 0
     20          
     21          //____________________________________________________________________________________________________________
     22          typedef struct IR_CMD_PARAMETERS
     23          {
     24              xTaskHandle IrCmdTaskHandle;
     25              xOS_TaskErrIndicator xOS_ErrId;
     26              xQueueParameters queue;
     27          } xOS_IR_CMD_HanlderParams;
     28          
     29          typedef enum{
     30          	IR_MODE_NULL = 0,
     31          	IR_MODE_RELOAD_PRG_KEY,	
     32          	IR_MODE_PROGRAM,
     33          	IR_MODE_OPERATION
     34          }IR_MODE;
     35          
     36          typedef enum {
     37          	IR_PRG_NULL = 0,
     38          	IR_PRG_FAILURE,
     39          	IR_PRG_SUCCESS,
     40          }eIR_PRG_REMOTE_STATE;
     41          
     42          typedef struct _IR_PRG_REMOTE_STATE
     43          {
     44          	IR_MODE ir_mode;
     45          	eIR_PRG_REMOTE_STATE ir_prg_state;
     46          	uint8 index;
     47          }IR_PRG_REMOTE_STATE;
     48          
     49          
     50          //____________________________________________________________________________________________________________
     51          xOS_IR_CMD_HanlderParams xOS_IrCmd;
     52          
     53          //____________________________________________________________________________________________________________
     54          //static api header
     55          static void IRCmdHandler_Initialize( void );
     56          
     57          static void IRCmdHandler_ServiceHandle(void *pvParameters);
     58          
     59          static void IRCmdHandler_CreateTask(void);
     60          
     61          static uint16 IRCmdHandler_getQueueNumber( void );
     62          
     63          static void IRCmdHandler_getQueue( IR_PROTOCOL_PAYLOAD *pData );
     64          
     65          static void IRCmdHandler_InsertQueue( IR_PROTOCOL_PAYLOAD ir_payload );
     66          
     67          static void IRCmdHandler_ProgramRemoteEvent( xHMIUserEvents event );
     68          
     69          static void IRCmdHandler_Initialize( void );
     70          
     71          static void IRCmdHandler_ReloadProgramRemoteEvent( void );
     72          
     73          
     74          //____________________________________________________________________________________________________________
     75          /* extern variable */
     76          
     77          #if ( configSTM32F411_PORTING == 0 )
     78          extern HMI_SERVICE_OBJECT *pHS_ObjCtrl; /*HMI service*/
     79          //extern STORAGE_DEVICE_MANAGER_OBJECT *pSDM_ObjCtrl;
     80          #endif
     81          
     82          
     83          const IR_CMD_HANDLER_OBJECT   IRCmdHandle =
     84          {
     85              IRCmdHandler_CreateTask,
     86              IRCmdHandler_getQueueNumber,
     87              IRCmdHandler_getQueue,
     88              IRCmdHandler_InsertQueue
     89          };
     90          
     91          const IR_CMD_PROGRAM_OBJECT IRCMDPrgHandle = 
     92          {
     93          	IRCmdHandler_Initialize,	
     94          	IRCmdHandler_ProgramRemoteEvent,
     95          };
     96          
     97          const IR_CMD_HANDLER_OBJECT *pIRCmdHandle_ObjCtrl = &IRCmdHandle;
     98          const IR_CMD_PROGRAM_OBJECT *pIR_PrgRemote_ObjCtrl = &IRCMDPrgHandle;
     99          
    100          //____________________________________________________________________________________________________________
    101          /*static variable*/
    102          static const uint8 SIZE_AMTRAN_IR_CMD_KEY_MAP = sizeof(IR_CMD_KEY_MAP)/sizeof(IR_CMD_KEY_MAP[0]);
    103          static const uint8 SIZE_VIZ_FAC_IR_CMD_KEY_MAP = sizeof(VIZ_FAC_IR_CMD_KEY_MAP)/sizeof(VIZ_FAC_IR_CMD_KEY_MAP[0]);
    104          
    105          IR_PRG_REMOTE_STATE mIrState = { IR_MODE_RELOAD_PRG_KEY, IR_PRG_NULL, 0 };
    106          IR_PRG_REMOTE_USER_EVENT mIrPrgRemoteUserEvent[3] = 
    107          {
    108          	{IR_PROTOCOL_NULL, IR_PROTOCOL_REPEAT_NULL, 0xffffffff, USER_EVENT_VOL_UP },
    109          	{IR_PROTOCOL_NULL, IR_PROTOCOL_REPEAT_NULL, 0xffffffff, USER_EVENT_VOL_DN },
    110          	{IR_PROTOCOL_NULL, IR_PROTOCOL_REPEAT_NULL, 0xffffffff, USER_EVENT_MUTE }
    111          };
    112          
    113          //____________________________________________________________________________________________________________
    114          static xHMISrvEventParams IRCmdHandler_TriggerFactoryModeEventHandle( NEC_PROTOCOL_PAYLOAD nec_ir_payload )
    115          {
    116          	uint16 ir_address = 0;
    117          	static portTickType xTimeTick = 0;
    118          	static uint8 check_state = 0;
    119          	xHMISrvEventParams srv_parms = {xHMI_EVENT_NULL, USER_EVENT_UNDEFINED };
    120          
    121          	ir_address = ( ( nec_ir_payload.address << 8 ) | nec_ir_payload.int_address );
    122          
    123          	if ( ir_address == VIZ_FAC_RMT_ADDRESS )
    124          	{
    125          
    126          		switch( check_state )
    127          		{
    128          			case 0:
    129          			{
    130          				if ( ENTER_FACTORY_KEY_MAP[0] == nec_ir_payload.command )
    131          				{
    132          					xTimeTick = xTaskGetTickCount( );
    133          					check_state++;
    134          				}
    135          			}
    136          				break;
    137          
    138          			case 1:
    139          			{
    140          				if ( ENTER_FACTORY_KEY_MAP[1] == nec_ir_payload.command )
    141          				{
    142          					if ( (xTaskGetTickCount( ) - xTimeTick) < 2000 )
    143          					{
    144          						check_state++;
    145          						xTimeTick = xTaskGetTickCount( );
    146          					}
    147          				}
    148          				else
    149          				{
    150          					check_state = 0;
    151          				}
    152          			}
    153          				break;
    154          
    155          			case 2:
    156          			{
    157          				if ( ENTER_FACTORY_KEY_MAP[2] == nec_ir_payload.command )
    158          				{
    159          					if ( (xTaskGetTickCount( ) - xTimeTick) < 2000 )
    160          					{
    161          						check_state++;
    162          						xTimeTick = xTaskGetTickCount( );
    163          					}
    164          				}
    165          				else
    166          				{
    167          					check_state = 0;
    168          				}
    169          			}
    170          				break;
    171          
    172          			case 3:
    173          			{
    174          				if ( ENTER_FACTORY_KEY_MAP[3] == nec_ir_payload.command )
    175          				{
    176          					if ( (xTaskGetTickCount( ) - xTimeTick) < 2000 )
    177          					{
    178          						check_state++;
    179          						xTimeTick = xTaskGetTickCount( );
    180          					}
    181          				}
    182          				else
    183          				{
    184          					check_state = 0;
    185          				}
    186          			}
    187          				break;
    188          
    189          			case 4:
    190          			{
    191          				if ( ENTER_FACTORY_KEY_MAP[4] == nec_ir_payload.command )
    192          				{
    193          					if ( (xTaskGetTickCount( ) - xTimeTick) < 2000 )
    194          					{
    195          						srv_parms.event_id = xHMI_EVENT_XRS351_IR;
    196          						srv_parms.event = USER_EVENT_MODE_FACTORY;
    197          						check_state = 0;
    198          						xTimeTick = xTaskGetTickCount( );
    199          					}
    200          				}
    201          				else
    202          				{
    203          					check_state = 0;
    204          				}
    205          			}
    206          				break;
    207          
    208          		}
    209          		
    210          	}
    211          
    212          
    213          	return srv_parms;
    214          	
    215          }
    216          
    217          static xHMISrvEventParams IRCmdHandler_UserEventHandle( NEC_PROTOCOL_PAYLOAD nec_ir_payload )
    218          {
    219          	uint16 ir_address = 0;
    220          	xHMISrvEventParams srv_parms = {xHMI_EVENT_NULL, USER_EVENT_UNDEFINED };
    221          	uint8 i = 0;
    222          	
    223          	ir_address = ( ( nec_ir_payload.address << 8 ) | nec_ir_payload.int_address );
    224          	
    225          	if ( ir_address == XRS351_ADDRESS )
    226          	{
    227          
    228          #if 0
    229          		TRACE_DEBUG((0, "sb ir command = 0x%X", nec_ir_payload.command ));
    230          #endif 	
    231          
    232          		for( i=0; i<SIZE_AMTRAN_IR_CMD_KEY_MAP; i++ )
    233          		{
    234          			if(IR_CMD_KEY_MAP[i].keyCode == nec_ir_payload.command )
    235          			{
    236          				srv_parms.event_id = xHMI_EVENT_XRS351_IR;
    237          				srv_parms.event = IR_CMD_KEY_MAP[i].UserEvent;
    238          				break;
    239          			}
    240          		}
    241          	}
    242          	else if ( ir_address == VIZ_FAC_RMT_ADDRESS )
    243          	{
    244          		for( i=0; i<SIZE_VIZ_FAC_IR_CMD_KEY_MAP; i++ )
    245          	    {
    246          	        if( VIZ_FAC_IR_CMD_KEY_MAP[i].keyCode == nec_ir_payload.command )
    247          	        {
    248          				srv_parms.event_id = xHMI_EVENT_VIZ_FAC_IR;
    249          	            srv_parms.event = VIZ_FAC_IR_CMD_KEY_MAP[i].UserEvent;
    250          				break;
    251          	        }
    252          	    }
    253          	}
    254          	
    255              return srv_parms; 
    256          }
    257          
    258          static uint16 IRCmdHandler_getQueueNumber( void )
    259          {
    260              if(  xOS_IrCmd.queue.xQueue != NULL )
    261              {
    262                  return (uint16)uxQueueMessagesWaiting(  xOS_IrCmd.queue.xQueue );
    263              }
    264          
    265              return 0;
    266          }
    267          
    268          static void IRCmdHandler_getQueue( IR_PROTOCOL_PAYLOAD *pData )
    269          {
    270              if ( pData == NULL )
    271                  return;
    272          
    273              if ( xOS_IrCmd.queue.xQueue == NULL )
    274              {
    275                  return;
    276              }
    277          
    278          	if ( xQueueReceive( xOS_IrCmd.queue.xQueue, pData , xOS_IrCmd.queue.xBlockTime ) != pdPASS )
    279              {
    280                  xOS_IrCmd.xOS_ErrId = xOS_TASK_QUEUE_GET_FAIL;
    281              }
    282          
    283          	xQueueReset( xOS_IrCmd.queue.xQueue );
    284          	return;
    285          }
    286          
    287          static void IRCmdHandler_InsertQueue( IR_PROTOCOL_PAYLOAD ir_payload )
    288          {
    289          	IR_PROTOCOL_PAYLOAD data = ir_payload;
    290          	
    291          	if( xOS_IrCmd.queue.xQueue != NULL )
    292          	{
    293          		xQueueReset( xOS_IrCmd.queue.xQueue );
    294          		if (xQueueSend( xOS_IrCmd.queue.xQueue, &data, xOS_IrCmd.queue.xBlockTime)!= pdPASS )
    295                  {
    296                      xOS_IrCmd.xOS_ErrId = xOS_TASK_QUEUE_SET_FAIL;
    297                  }
    298          	}
    299          }
    300          
    301          static xHMIUserEvents IRCmdHandler_AdmitRepeatUserEvent( xHMIUserEvents event )
    302          {
    303          	xHMIUserEvents ret = USER_EVENT_NULL;
    304          #if ( configSII_DEV_953x_PORTING == 1 )
    305              if( ( event == USER_EVENT_VOL_UP ) || \
    306                  ( event == USER_EVENT_VOL_DN ) || \
    307                  ( event == USER_EVENT_BASS_UP ) || \
    308                  ( event == USER_EVENT_BASS_DN ) || \
    309                  ( event == USER_EVENT_TREBLE_UP ) || \
    310                  ( event == USER_EVENT_TREBLE_DN ) || \
    311                  ( event == USER_EVENT_SUB_UP ) || \
    312                  ( event == USER_EVENT_SUB_DN ) || \
    313                  ( event == USER_EVENT_CENTER_UP ) || \
    314                  ( event == USER_EVENT_CENTER_DN ) || \
    315                  ( event == USER_EVENT_REAR_UP ) || \
    316                  ( event == USER_EVENT_REAR_DN ) || \
    317                  ( event == USER_EVENT_BALANCE_UP ) || \
    318                  ( event == USER_EVENT_BALANCE_DN ) || \
    319                  ( event == USER_EVENT_AV_DELAY_UP ) || \
    320                  ( event == USER_EVENT_AV_DELAY_DN ) || \
    321                  ( event == USER_EVENT_START_AUTO_SEL_SRC)
    322                )
    323              {
    324                  ret = event;
    325              }
    326          #else
    327          	if( ( event == USER_EVENT_VOL_UP ) || \
    328          		( event == USER_EVENT_VOL_DN ) || \
    329          		( event == USER_EVENT_BASS_UP ) || \
    330          		( event == USER_EVENT_BASS_DN ) || \
    331          		( event == USER_EVENT_TREBLE_UP ) || \
    332          		( event == USER_EVENT_TREBLE_DN ) || \
    333          		( event == USER_EVENT_SUB_UP ) || \
    334          		( event == USER_EVENT_SUB_DN ) || \
    335          		( event == USER_EVENT_CENTER_UP ) || \
    336          		( event == USER_EVENT_CENTER_DN ) || \
    337          		( event == USER_EVENT_REAR_UP ) || \
    338          		( event == USER_EVENT_REAR_DN ) || \
    339          		( event == USER_EVENT_BALANCE_UP ) || \
    340          		( event == USER_EVENT_BALANCE_DN ) || \
    341          		( event == USER_EVENT_AV_DELAY_UP ) || \
    342                  ( event == USER_EVENT_AV_DELAY_DN ) || \
    343                  ( event == USER_EVENT_START_AUTO_SEL_SRC)
    344          		)
    345          	{
    346          		ret = event;
    347          	}
    348          #endif   
    349              return ret;
    350          
    351          }
    352          
    353          static xHMIUserEvents IRCmdHandler_VizioSpecialUserEvent(bool repeatCode, xHMIUserEvents event)
    354          {
    355           //Angus added for VIZIO Spec 2.1.2 which is defined long press input key will enter auto detect mode.
    356              static portTickType RepeatTick = 0;
    357              portTickType RepeatDuration;
    358              static bool startTimer = FALSE;
    359              xHMIUserEvents ret = event;  
    360          
    361          
    362              if(repeatCode)
    363              {
    364                  switch(event)
    365                  {
    366                      case USER_EVENT_SEL_AUX1:
    367                      case USER_EVENT_SEL_AUX2:
    368                      case USER_EVENT_SEL_COAXIAL:
    369                      case USER_EVENT_SEL_OPTICAL:
    370          #if( configSII_DEV_953x_PORTING == 1 )
    371                      case USER_EVENT_SEL_HDMI_IN:
    372                      case USER_EVENT_SEL_HDMI_ARC:
    373          #endif
    374                      case USER_EVENT_SEL_BT:
    375                      case USER_EVENT_SEL_USB_PLAYBACK:   
    376                      {
    377                          if(startTimer == FALSE)
    378                          {
    379                              startTimer = TRUE;
    380                              RepeatDuration = xTaskGetTickCount( );
    381                              RepeatTick = RepeatDuration;
    382                          }
    383                          else
    384                          {
    385                              RepeatDuration = ( xTaskGetTickCount( ) - RepeatTick);
    386                              if((RepeatDuration/portTICK_RATE_MS) > TASK_MSEC2TICKS(2000))
    387                              {
    388                                  ret = USER_EVENT_START_AUTO_SEL_SRC;
    389          
    390                                  RepeatDuration = 0;
    391                                  RepeatTick = 0;
    392                                  startTimer = FALSE;
    393                              }
    394                          }
    395                      }
    396                      break;
    397              
    398                      default:
    399                      {
    400                          RepeatDuration = 0;
    401                          RepeatTick = 0;
    402                          startTimer = FALSE;
    403                      }
    404                      break;           
    405                  }
    406                  
    407              }
    408              else
    409              {
    410                  if(startTimer)
    411                  {
    412                      startTimer = FALSE;
    413                      RepeatDuration = 0;
    414                      RepeatTick = 0;
    415                      startTimer = FALSE;
    416                  }  
    417              }
    418          
    419          	return ret;
    420          }
    421          
    422          static xHMISrvEventParams IRCmdHandler_ProgramCode_UserEventHandle( IR_PROTOCOL_PAYLOAD ir_payload )
    423          {
    424          	uint8 i = 0;
    425          	xHMISrvEventParams event = { xHMI_EVENT_NULL, USER_EVENT_UNDEFINED };
    426          
    427          	for( i = 0; i < 3; i++ )
    428          	{
    429          		if( mIrPrgRemoteUserEvent[i].ir_payload.payload == ir_payload.payload )
    430          		{
    431          			event.event_id = xHMI_EVENT_PROGRAM_IR;
    432          			event.event = mIrPrgRemoteUserEvent[i].user_event;
    433          		}
    434          	}
    435          
    436          	return event;
    437          }
    438          
    439          static xHMISrvEventParams IRCmdHandler_NEC_CmdEvent( IR_PROTOCOL_PAYLOAD ir_payload )
    440          {
    441          	NEC_PROTOCOL_PAYLOAD *pNecProtocol;
    442          	IR_PROTOCOL_PAYLOAD IrPayload = ir_payload;
    443          	xHMISrvEventParams srv_parms = { xHMI_EVENT_NULL, USER_EVENT_UNDEFINED };
    444          	
    445          
    446          	pNecProtocol = (NEC_PROTOCOL_PAYLOAD*)&IrPayload.payload;
    447          	
    448          	if( ir_payload.info.bits.repeat_type == IR_PROTOCOL_REPEAT_NULL ) 
    449          	{
    450          		srv_parms = IRCmdHandler_ProgramCode_UserEventHandle( ir_payload );
    451          		if ( srv_parms.event_id == xHMI_EVENT_NULL )
    452          		{
    453          			srv_parms = IRCmdHandler_UserEventHandle( *pNecProtocol );
    454          		}
    455          
    456          		if ( srv_parms.event_id == xHMI_EVENT_NULL )
    457          		{
    458          			srv_parms = IRCmdHandler_TriggerFactoryModeEventHandle( *pNecProtocol );
    459          		}
    460          
    461                  srv_parms.event = IRCmdHandler_VizioSpecialUserEvent(FALSE,srv_parms.event);
    462          	}
    463          	else if ( ir_payload.info.bits.repeat_type == IR_PROTOCOL_38K_NEC_REPEAT )
    464          	{
    465          		srv_parms = IRCmdHandler_ProgramCode_UserEventHandle( ir_payload );
    466          		if ( srv_parms.event_id == xHMI_EVENT_NULL )
    467          		{
    468          			srv_parms = IRCmdHandler_UserEventHandle( *pNecProtocol  );
    469          		}
    470                  srv_parms.event = IRCmdHandler_VizioSpecialUserEvent(TRUE,srv_parms.event);
    471          		srv_parms.event = IRCmdHandler_AdmitRepeatUserEvent( srv_parms.event );
    472          	}
    473          	
    474          	return (  srv_parms );
    475          		
    476          }
    477          
    478          static xHMISrvEventParams IRCmdHandler_Program_CmdEvent( IR_PROTOCOL_PAYLOAD ir_payload )
    479          {
    480          	xHMISrvEventParams srv_parms = {xHMI_EVENT_NULL, USER_EVENT_UNDEFINED };
    481          
    482          	if ( ir_payload.info.bits.repeat_type != IR_PROTOCOL_REPEAT_NULL )
    483          	{
    484          		srv_parms = IRCmdHandler_ProgramCode_UserEventHandle( ir_payload );
    485          		srv_parms.event = IRCmdHandler_AdmitRepeatUserEvent( srv_parms.event );
    486          	}
    487          	else
    488          	{
    489          		srv_parms = IRCmdHandler_ProgramCode_UserEventHandle( ir_payload );
    490          	}
    491          
    492          	return (  srv_parms );
    493          }
    494          
    495          static void IRCmdHandler_ReloadProgramRemoteEvent( void )
    496          {
    497          	uint8 i = 0;
    498          	IR_PRG_REMOTE_USER_EVENT event;
    499          
    500          	for( i = 0; i < 3; i++ )
    501          	{
    502          		switch( i )
    503          		{
    504          			case 0:
    505          			{
    506          #if ( configSTM32F411_PORTING == 1 )
    507          				pSDM_ObjCtrl->read( STORAGE_DEVICE_CELL_PROGRAM_KEY_VOLUME_UP, &event );
    508          #endif				
    509          			}
    510          				break;
    511          
    512          			case 1:
    513          			{
    514          #if ( configSTM32F411_PORTING == 1 )
    515          				pSDM_ObjCtrl->read( STORAGE_DEVICE_CELL_PROGRAM_KEY_VOLUME_DN, &event );
    516          #endif				
    517          			}
    518          				break;
    519          
    520          			case 2:
    521          			{
    522          #if ( configSTM32F411_PORTING == 1 )
    523          				pSDM_ObjCtrl->read( STORAGE_DEVICE_CELL_PROGRAM_KEY_VOLUME_MUTE, &event );
    524          #endif				
    525          			}
    526          				break;
    527          
    528          		}
    529          
    530          		if ( mIrPrgRemoteUserEvent[i].user_event == event.user_event )
    531          		{
    532          			mIrPrgRemoteUserEvent[i].ir_payload.info.byte = event.ir_payload.info.byte;
    533          			mIrPrgRemoteUserEvent[i].ir_payload.payload = event.ir_payload.payload;
    534          		}
    535          		
    536          	}
    537          }
    538          
    539          static void IRCmdHandler_ProgramRemoteEvent( xHMIUserEvents event )
    540          {
    541          	switch( event )
    542          	{
    543          		case USER_EVENT_PROGRAM_IR_VOL_UP:
    544          		{
    545          			mIrState.index = 0;
    546          			mIrState.ir_mode = IR_MODE_PROGRAM;
    547          			mIrState.ir_prg_state = IR_PRG_NULL;
    548                      //pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_PRG_REMOTE_LEARNING);
    549          
    550          			TRACE_DEBUG((0, "programe USER_EVENT_PROGRAM_IR_VOL_UP "));
    551          		}
    552          			break;
    553          			
    554          		case USER_EVENT_PROGRAM_IR_VOL_DN:
    555          		{
    556          			mIrState.index = 1;
    557          			mIrState.ir_mode = IR_MODE_PROGRAM;
    558          			mIrState.ir_prg_state = IR_PRG_NULL;
    559                      //pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_PRG_REMOTE_LEARNING);
    560          
    561          			TRACE_DEBUG((0, "programe USER_EVENT_PROGRAM_IR_VOL_DN "));
    562          		}
    563          			break;
    564          			
    565          		case USER_EVENT_PROGRAM_IR_MUTE:
    566          		{
    567          			mIrState.index = 2;
    568          			mIrState.ir_mode = IR_MODE_PROGRAM;
    569          			mIrState.ir_prg_state = IR_PRG_NULL;
    570                      //pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_PRG_REMOTE_LEARNING);
    571          
    572          			TRACE_DEBUG((0, "programe USER_EVENT_PROGRAM_IR_MUTE "));
    573          		}
    574          			break;
    575          
    576          		case USER_EVENT_DEVICE_RESET:
    577          		{
    578          			IRCmdHandler_Initialize( );
    579          		}
    580          			break;
    581          
    582          		default:
    583          		{
    584          			mIrState.index = 0;
    585          			mIrState.ir_mode = IR_MODE_OPERATION;
    586          			mIrState.ir_prg_state = IR_PRG_NULL;
    587          		}
    588          			break;
    589          	}
    590          }
    591          
    592          static void IRCmdHanlder_ProgramRemote_BuildingUserEvent( IR_PROTOCOL_PAYLOAD ir_payload )
    593          {
    594          	NEC_PROTOCOL_PAYLOAD *pNecProtocol;
    595          	uint16 ir_address = 0;
    596          
    597          #if IR_BUILD_DEBUG
    598          	uint8 i = 0;
    599          	uint8 *pBYTE;
    600          #endif 
    601          	
    602          	if ( ir_payload.info.bits.repeat_type == IR_PROTOCOL_38K_NEC_REPEAT )
    603          	{
    604          		mIrState.ir_prg_state = IR_PRG_FAILURE;
    605          		mIrState.ir_mode = IR_MODE_OPERATION;
    606          		TRACE_DEBUG((0, "1 program ir is failure!!"));
    607                  //pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_NORMAL);
    608          	}
    609          	else if ( ir_payload.info.bits.protocol_type == IR_PROTOCOL_38K_NEC )
    610          	{
    611          		pNecProtocol = (NEC_PROTOCOL_PAYLOAD*)&ir_payload.payload;
    612          		ir_address = ( ( pNecProtocol->address << 8 ) | pNecProtocol->int_address );
    613          
    614          #if IR_BUILD_DEBUG
    615          		TRACE_DEBUG((0, "ir address = 0x%X", ir_address ));
    616          #endif 
    617          
    618          		if ( ir_address == XRS351_ADDRESS )
    619          		{
    620          			mIrState.ir_prg_state = IR_PRG_FAILURE;
    621          			mIrState.ir_mode = IR_MODE_OPERATION;
    622          			TRACE_DEBUG((0, "2 program ir is failure!!"));
    623                      //pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_NORMAL);
    624          			return;
    625          		}
    626          	}
    627          
    628          	
    629          	mIrPrgRemoteUserEvent[mIrState.index].ir_payload.info.byte = ir_payload.info.byte;
    630          	mIrPrgRemoteUserEvent[mIrState.index].ir_payload.payload = ir_payload.payload;
    631          	mIrState.ir_prg_state = IR_PRG_SUCCESS;
    632          
    633          	switch( mIrPrgRemoteUserEvent[mIrState.index].user_event )
    634          	{
    635          		case USER_EVENT_VOL_UP:
    636          		{
    637          #if ( configSTM32F411_PORTING == 1 )
    638          			pSDM_ObjCtrl->write( STORAGE_DEVICE_CELL_PROGRAM_KEY_VOLUME_UP ,(uint8*)&mIrPrgRemoteUserEvent[mIrState.index] );
    639          #endif			
    640          			TRACE_DEBUG((0, "USER_EVENT_VOL_UP program success"));
    641                      //pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_PRG_REMOTE_LEARNED);
    642          		}
    643          			break;
    644          
    645          		case USER_EVENT_VOL_DN:
    646          		{
    647          #if ( configSTM32F411_PORTING == 1 )
    648          			pSDM_ObjCtrl->write( STORAGE_DEVICE_CELL_PROGRAM_KEY_VOLUME_DN ,(uint8*)&mIrPrgRemoteUserEvent[mIrState.index] );
    649          #endif			
    650          			TRACE_DEBUG((0, "USER_EVENT_VOL_DN program success"));
    651                      //pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_PRG_REMOTE_LEARNED);
    652          		}
    653          			break;
    654          			
    655          		case USER_EVENT_MUTE:
    656          		{
    657          #if ( configSTM32F411_PORTING == 1 )
    658          			pSDM_ObjCtrl->write( STORAGE_DEVICE_CELL_PROGRAM_KEY_VOLUME_MUTE,(uint8*)&mIrPrgRemoteUserEvent[mIrState.index] );
    659          #endif			
    660          			TRACE_DEBUG((0, "USER_EVENT_MUTE program success"));
    661                      //pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_PRG_REMOTE_LEARNED);
    662          		}
    663          			break;
    664          	}
    665          
    666          #if IR_BUILD_DEBUG 
    667          	pBYTE = (uint8*)&mIrPrgRemoteUserEvent[mIrState.index];
    668          
    669          	for ( i = 0; i < (sizeof(mIrPrgRemoteUserEvent[mIrState.index])/sizeof ( uint8 )); i ++ )
    670          	{
    671          		TRACE_DEBUG((0, "data[%d] = 0x%X", i, *(pBYTE+i)));
    672          	
    673          
    674          	}
    675          #endif 
    676          }
    677          
    678          static void IRCmdHandler_ServiceHandle(void *pvParameters)
    679          {
    680          	static IR_PROTOCOL_PAYLOAD ir_payload;
    681          	xHMISrvEventParams srv_parms = { xHMI_EVENT_NULL, USER_EVENT_UNDEFINED };
    682          	
    683          
    684          	for( ;; )
    685          	{
    686          		if ( IRCmdHandler_getQueueNumber() > 0 )
    687          		{
    688          			IRCmdHandler_getQueue( &ir_payload );
    689          
    690          			switch( mIrState.ir_mode )
    691          			{
    692          				case IR_MODE_PROGRAM:
    693          				{
    694          					IRCmdHanlder_ProgramRemote_BuildingUserEvent( ir_payload );
    695          					mIrState.ir_mode = IR_MODE_OPERATION;
    696          					mIrState.ir_prg_state = IR_PRG_NULL;
    697          				}
    698          					break;
    699          
    700          				case IR_MODE_OPERATION:
    701          				{
    702          					if ( ir_payload.info.bits.protocol_type == IR_PROTOCOL_38K_NEC )
    703          					{
    704          						srv_parms = IRCmdHandler_NEC_CmdEvent( ir_payload );
    705          					}
    706          					else
    707          					{
    708          						srv_parms = IRCmdHandler_Program_CmdEvent( ir_payload );
    709          					}
    710          
    711          #if ( configSTM32F411_PORTING == 0 )
    712          					pHS_ObjCtrl->SendEvent( &srv_parms ); 
    713          #endif					
    714          				}
    715          					break;
    716          
    717          			}
    718          			
    719          		}
    720          		else
    721          		{
    722          			if ( mIrState.ir_mode == IR_MODE_RELOAD_PRG_KEY )
    723          			{
    724          				IRCmdHandler_ReloadProgramRemoteEvent( );
    725          				mIrState.ir_mode = IR_MODE_OPERATION;
    726          			}
    727          		}
    728          
    729          		vTaskDelay( TASK_MSEC2TICKS(10) );
    730          	}
    731          
    732          }
    733          
    734          static void IRCmdHandler_Initialize( void )
    735          {
    736          	uint8 i = 0;
    737          	
    738          	for ( i = 0; i < 3; i++ )
    739          	{
    740          		mIrPrgRemoteUserEvent[i].ir_payload.info.byte = 0;
    741          		mIrPrgRemoteUserEvent[i].ir_payload.payload = 0xffffffff;
    742          
    743          		switch( mIrPrgRemoteUserEvent[i].user_event )
    744          		{
    745          			case USER_EVENT_VOL_UP:
    746          			{
    747          #if ( configSTM32F411_PORTING == 1 )
    748          				pSDM_ObjCtrl->write( STORAGE_DEVICE_CELL_PROGRAM_KEY_VOLUME_UP ,(uint8*)&mIrPrgRemoteUserEvent[i] );
    749          #endif				
    750          			}
    751          				break;
    752          
    753          			case USER_EVENT_VOL_DN:
    754          			{
    755          #if ( configSTM32F411_PORTING == 1 )
    756          				pSDM_ObjCtrl->write( STORAGE_DEVICE_CELL_PROGRAM_KEY_VOLUME_DN ,(uint8*)&mIrPrgRemoteUserEvent[i] );
    757          #endif				
    758          			}
    759          				break;
    760          				
    761          			case USER_EVENT_MUTE:
    762          			{
    763          #if ( configSTM32F411_PORTING == 1 )
    764          				pSDM_ObjCtrl->write( STORAGE_DEVICE_CELL_PROGRAM_KEY_VOLUME_MUTE,(uint8*)&mIrPrgRemoteUserEvent[i] );
    765          #endif				
    766          			}
    767          				break;
    768          		}
    769          		
    770          	}
    771          
    772          	mIrState.ir_mode = IR_MODE_RELOAD_PRG_KEY;
    773          	mIrState.ir_prg_state = IR_PRG_NULL;
    774          	mIrState.index = 0;
    775          }
    776          
    777          static void IRCmdHandler_CreateTask(void)
    778          {
    779          #if ( configAPP_IR_REMOTE == 1 )
    780              if ( xTaskCreate( IRCmdHandler_ServiceHandle,
    781                  ( portCHAR * ) "IRCmdHandler",
    782                   configMINIMAL_STACK_SIZE, NULL,
    783                   tskHMI_EVENT_PRIORITY, &xOS_IrCmd.IrCmdTaskHandle ) != pdPASS)
    784              {
    785          		vTaskDelete( xOS_IrCmd.IrCmdTaskHandle );
    786          		xOS_IrCmd.xOS_ErrId = xOS_TASK_CREATE_FAIL;
    787              }
    788          
    789          	xOS_IrCmd.queue.xQueue = xQueueCreate( 1, FRTOS_SIZE(IR_PROTOCOL_PAYLOAD) );
    790          	xOS_IrCmd.queue.xBlockTime = BLOCK_TIME(0);
    791              if( xOS_IrCmd.queue.xQueue == NULL )
    792              {
    793                 xOS_IrCmd.xOS_ErrId = xOS_TASK_QUEUE_CREATE_FAIL;
    794              }
    795          #endif 	
    796          }
    797          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  IRCmdHandler_AdmitRepeatUserEvent
       24  IRCmdHandler_CreateTask
             24 -> vTaskDelete
             24 -> xQueueGenericCreate
             24 -> xTaskGenericCreate
        0  IRCmdHandler_Initialize
       16  IRCmdHandler_InsertQueue
             16 -> xQueueGenericReset
             16 -> xQueueGenericSend
       24  IRCmdHandler_NEC_CmdEvent
             24 -> IRCmdHandler_AdmitRepeatUserEvent
             24 -> IRCmdHandler_ProgramCode_UserEventHandle
             24 -> IRCmdHandler_TriggerFactoryModeEventHandle
             24 -> IRCmdHandler_UserEventHandle
             24 -> IRCmdHandler_VizioSpecialUserEvent
       12  IRCmdHandler_ProgramCode_UserEventHandle
        0  IRCmdHandler_ProgramRemoteEvent
              0 -> Debug_printDebug
              0 -> IRCmdHandler_Initialize
       48  IRCmdHandler_ServiceHandle
             48 -- Indirect call
             48 -> Debug_printDebug
             48 -> IRCmdHandler_AdmitRepeatUserEvent
             48 -> IRCmdHandler_NEC_CmdEvent
             48 -> IRCmdHandler_ProgramCode_UserEventHandle
             48 -> IRCmdHandler_getQueue
             48 -> IRCmdHandler_getQueueNumber
             48 -> vTaskDelay
       16  IRCmdHandler_TriggerFactoryModeEventHandle
             16 -> xTaskGetTickCount
        8  IRCmdHandler_UserEventHandle
       16  IRCmdHandler_VizioSpecialUserEvent
             16 -> xTaskGetTickCount
       16  IRCmdHandler_getQueue
             16 -> xQueueGenericReceive
              0 -> xQueueGenericReset
        8  IRCmdHandler_getQueueNumber
              8 -> uxQueueMessagesWaiting


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      28  ?<Constant "1 program ir is failu...">
      28  ?<Constant "2 program ir is failu...">
      16  ?<Constant "IRCmdHandler">
      32  ?<Constant "USER_EVENT_MUTE progr...">
      36  ?<Constant "USER_EVENT_VOL_DN pro...">
      36  ?<Constant "USER_EVENT_VOL_UP pro...">
      40  ?<Constant "programe USER_EVENT_P...">
      40  ?<Constant "programe USER_EVENT_P...">_1
      40  ?<Constant "programe USER_EVENT_P...">_2
       4  ?<Constant {0, 100}>
       4  ?<Constant {0, 100}>_1
       4  ?<Constant {0, 100}>_2
       4  ?<Constant {0, 100}>_3
       4  ?<Constant {0, 100}>_4
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
       8  IRCMDPrgHandle
      16  IRCmdHandle
      74  IRCmdHandler_AdmitRepeatUserEvent
      72  IRCmdHandler_CreateTask
      40  IRCmdHandler_Initialize
      44  IRCmdHandler_InsertQueue
     130  IRCmdHandler_NEC_CmdEvent
      48  IRCmdHandler_ProgramCode_UserEventHandle
      90  IRCmdHandler_ProgramRemoteEvent
     328  IRCmdHandler_ServiceHandle
     172  IRCmdHandler_TriggerFactoryModeEventHandle
     112  IRCmdHandler_UserEventHandle
      62  IRCmdHandler_VizioSpecialUserEvent
      50  IRCmdHandler_getQueue
      20  IRCmdHandler_getQueueNumber
      92  IR_CMD_KEY_MAP
      52  VIZ_FAC_IR_CMD_KEY_MAP
       8  check_state
          xTimeTick
      12  ir_payload
          mIrState
      36  mIrPrgRemoteUserEvent
       4  pIRCmdHandle_ObjCtrl
       4  pIR_PrgRemote_ObjCtrl
       8  startTimer
          RepeatTick
      20  xOS_IrCmd

 
    36 bytes in section .bss
   108 bytes in section .data
    24 bytes in section .rodata
 1 682 bytes in section .text
 
 1 682 bytes of CODE  memory
    24 bytes of CONST memory
   144 bytes of DATA  memory

Errors: none
Warnings: 7

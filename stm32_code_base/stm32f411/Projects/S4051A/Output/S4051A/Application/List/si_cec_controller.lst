###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:24:22 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\sii953x\component\cec_manager\s #
#                    i_cec_controller.c                                       #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\sii953x\component\cec_manager\s #
#                    i_cec_controller.c -D S4051A -D DEBUG -D FREE_RTOS -D    #
#                    STM32F40_41xxx -D USE_STM324xG_EVAL -D                   #
#                    USE_STDPERIPH_DRIVER -D __ARM_CORTEX_MX__ -D             #
#                    IAR_ARM_CM4F -D USE_USB_OTG_FS -lcN                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\ #
#                    DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applica #
#                    tion\Obj\ --debug --endian=little --cpu=Cortex-M4 -e     #
#                    --fpu=VFPv4_sp --dlib_config "C:\Program Files           #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\si_cec_controller.lst                                 #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\si_cec_controller.o                                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Libraries\AMT_Drivers\sii953x\component\cec_manager\si_cec_controller.c
      1          //***************************************************************************
      2          //!file     si_api cec_controller.c
      3          //!brief    Silicon Image mid-level CEC handler
      4          //
      5          // No part of this work may be reproduced, modified, distributed,
      6          // transmitted, transcribed, or translated into any language or computer
      7          // format, in any form or by any means without written permission of
      8          // Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
      9          //
     10          // Copyright 2009-2012, Silicon Image, Inc.  All rights reserved.
     11          //***************************************************************************/
     12          
     13          #include <string.h>
     14          #include "si_cec_internal.h"
     15          
     16          #if ( configSII_DEV_953x_PORTING == 1 )
     17          #include "Debug.h"
     18          #endif 
     19          
     20          
     21          //------------------------------------------------------------------------------
     22          // Component data
     23          //------------------------------------------------------------------------------
     24          
     25          uint8_t l_devTypes [16] =
     26          {
     27              CEC_LOGADDR_TV,
     28              CEC_LOGADDR_RECDEV1,
     29              CEC_LOGADDR_RECDEV1,
     30              CEC_LOGADDR_TUNER1,
     31              CEC_LOGADDR_PLAYBACK1,
     32              CEC_LOGADDR_AUDSYS,
     33              CEC_LOGADDR_PURE_SWITCH,
     34              CEC_LOGADDR_VIDEO_PROCESSOR,
     35              CEC_LOGADDR_PLAYBACK1,
     36              CEC_LOGADDR_RECDEV1,
     37              CEC_LOGADDR_TUNER1,
     38              CEC_LOGADDR_PLAYBACK1,
     39              CEC_LOGADDR_RECDEV2,
     40              CEC_LOGADDR_RECDEV2,
     41              CEC_LOGADDR_TV,
     42              CEC_LOGADDR_TV
     43          };
     44          
     45          //------------------------------------------------------------------------------
     46          // Module data
     47          //------------------------------------------------------------------------------
     48          
     49          uint8_t CecVendorID[3] = {0x00,0x01,0x03}; //should be SIMG vendor ID
     50          
     51          static uint8_t cecValidate [128] =
     52          {
     53              1, 1, 1, 1,
     54              1, 1, 1, 1,
     55              1, 1, 1, 1,
     56              1, 1,
     57          
     58              //0x0E - 0x0F Reserved
     59              0, 0,
     60          
     61              1, 1,
     62          
     63              //0x12 - 0x1C Reserved
     64              0, 0,
     65              0, 0, 0, 0,
     66              0, 0, 0, 0,
     67              0,
     68          
     69              1, 1, 1,
     70              1, 1, 1, 1,
     71              1, 1, 1, 1,
     72              1, 1, 1, 1,
     73              1,
     74          
     75              //0x2D - 0x2E Reserved
     76              0, 0,
     77          
     78              1,
     79              1, 1, 1, 1,
     80              1, 1, 1, 1,
     81              1,
     82          
     83              //0x39 - 0x3F Reserved
     84              1, 1, 1,
     85              1, 0, 0, 0,
     86          
     87              1, 1, 1, 1,
     88              1, 1, 1, 1,
     89              1, 1, 1, 1,
     90              1,
     91          
     92              //0x4D - 0x4F Reserved
     93              0, 0, 0,
     94          
     95              1, 1, 1, 1,
     96              1, 1, 1, 1,
     97          
     98              //0x58 - 0x5F Reserved
     99              0, 0, 0, 0,
    100              0, 0, 0, 0,
    101          
    102              1, 1, 1, 1,
    103              1, 1, 1, 1,
    104              1, 1, 1, 1,
    105              1, 1,
    106          
    107              //0x6E - 0x70 Reserved
    108              0, 0,
    109              0,
    110          
    111              1, 1, 1,
    112              1, 1, 1,
    113          
    114              // 0x77 - 0x7F Reserved
    115              0,
    116              0, 0, 0, 0,
    117              0, 0, 0, 0
    118          };
    119          
    120          
    121          //------------------------------------------------------------------------------
    122          //! @brief  Check for valid CEC key code.
    123          //! @param[in]  CEC RC key
    124          //------------------------------------------------------------------------------
    125          bool_t SiiCecValidateKeyCode ( uint8_t keyData )
    126           {
    127              bool_t  validKey = false;
    128          
    129              // All keys 0x80 - 0xFF are invalid, use the table for the rest
    130              if (( cecValidate[ keyData & ~BIT7]) != 0 )
    131              {
    132                  validKey = true;
    133              }
    134          
    135              return( validKey );
    136           }
    137          
    138          //------------------------------------------------------------------------------
    139          // Function:
    140          // Description:
    141          //------------------------------------------------------------------------------
    142          
    143          void CecPrintLogAddr ( uint8_t bLogAddr )
    144          {
    145          
    146              //    DEBUG_PRINT( MSG_DBG, " [%X] %s\n", (int)bLogAddr, CpCecTranslateLA( bLogAddr ) );
    147              DEBUG_PRINT( MSG_DBG, " [%X] ", (int)bLogAddr );
    148          }
    149          
    150          //------------------------------------------------------------------------------
    151          //! @brief      Broadcast a REPORT PHYSICAL ADDRESS message.
    152          //!             Does not wait for a reply.
    153          //! @param[in]  srcLa     - source CEC logical address
    154          //! @param[in]  srcPa     - source CEC physical address
    155          //! @return     uint16_t    16 bit message ID or 0 if CEC not enabled
    156          //------------------------------------------------------------------------------
    157          uint16_t SiiCecSendReportPhysicalAddress ( SiiCecLogicalAddresses_t srcLa, uint16_t srcPa )
    158          {
    159              SiiCpiData_t cecFrame;
    160          
    161              cecFrame.opcode         = CECOP_REPORT_PHYSICAL_ADDRESS;
    162              cecFrame.srcDestAddr    = MAKE_SRCDEST( srcLa, CEC_LOGADDR_UNREGORBC );
    163              cecFrame.args[0]        = srcPa >> 8;           // [Physical Address] High
    164              cecFrame.args[1]        = srcPa & 0xFF;         // [Physical Address] Low
    165              cecFrame.args[2]        = l_devTypes[srcLa];    // [Device Type]
    166              cecFrame.argCount       = 3;
    167          
    168              return( SiiDrvCpiWrite( &cecFrame ));
    169          }
    170          
    171          uint16_t SiiCecSendMenuStatus(SiiCecLogicalAddresses_t srcLa, SiiCecLogicalAddresses_t destLa, uint8_t menuStatus )
    172          {
    173              SiiCpiData_t cecFrame;
    174          
    175              cecFrame.opcode        = CECOP_MENU_STATUS;
    176              cecFrame.srcDestAddr   = MAKE_SRCDEST( srcLa, destLa );
    177              cecFrame.args[0]       = menuStatus;
    178              cecFrame.argCount      = 1;
    179          
    180              return( SiiDrvCpiWrite( &cecFrame ));
    181          
    182          }
    183          
    184          
    185          uint16_t SiiCecSendDeckStatus( SiiCecLogicalAddresses_t srcLa, SiiCecLogicalAddresses_t destLa, uint8_t deckStatus  )
    186          {
    187              SiiCpiData_t cecFrame;
    188          
    189              cecFrame.opcode        = CECOP_DECK_STATUS;
    190              cecFrame.srcDestAddr   = MAKE_SRCDEST( srcLa, destLa );
    191              cecFrame.args[0]       = deckStatus;
    192              cecFrame.argCount      = 1;
    193          
    194              return( SiiDrvCpiWrite( &cecFrame ));
    195          
    196          }
    197          
    198          //------------------------------------------------------------------------------
    199          //! @brief      Broadcast a REPORT PHYSICAL ADDRESS message.
    200          //!             Does not wait for a reply.
    201          //! @param[in]  srcLa     - source CEC logical address
    202          //! @param[in]  srcPa     - source CEC physical address
    203          //! @return     uint16_t    16 bit message ID or 0 if CEC not enabled
    204          //------------------------------------------------------------------------------
    205          uint16_t SiiCecSendReportPowerStatus ( SiiCecLogicalAddresses_t srcLa, SiiCecLogicalAddresses_t destLa, uint8_t powerState )
    206          {
    207              SiiCpiData_t cecFrame;
    208          
    209              cecFrame.opcode        = CECOP_REPORT_POWER_STATUS;
    210              cecFrame.srcDestAddr   = MAKE_SRCDEST( srcLa, destLa );
    211              cecFrame.args[0]       = powerState;
    212              cecFrame.argCount      = 1;
    213          
    214              return( SiiDrvCpiWrite( &cecFrame ));
    215          }
    216          
    217          uint16_t SiiCecSendVendorId(  SiiCecLogicalAddresses_t srcLa, SiiCecLogicalAddresses_t destLa,uint8_t *vendorId )
    218          {
    219              SiiCpiData_t cecFrame;
    220          
    221              cecFrame.opcode        = CECOP_DEVICE_VENDOR_ID;
    222              cecFrame.srcDestAddr   = MAKE_SRCDEST( srcLa, destLa );
    223              cecFrame.args[0]       = vendorId[0];
    224              cecFrame.args[1]       = vendorId[1];
    225              cecFrame.args[2]       = vendorId[2];
    226              cecFrame.argCount      = 3;
    227          
    228              return( SiiDrvCpiWrite( &cecFrame ));
    229          
    230          }
    231          
    232          //------------------------------------------------------------------------------
    233          // Function:    CecSendSetStreamPath
    234          // Description: Broadcast a SET STREAM PATH message.  Does not wait for a reply.
    235          //------------------------------------------------------------------------------
    236          
    237          void CecSendSetStreamPath ( uint16_t destPhysAddr )
    238          {
    239              SiiCpiData_t cecFrame;
    240          
    241              cecFrame.opcode         = CECOP_SET_STREAM_PATH;
    242              cecFrame.srcDestAddr    = MAKE_SRCDEST( pCec->logicalAddr, CEC_LOGADDR_UNREGORBC );
    243              cecFrame.args[0]        = (uint8_t)(destPhysAddr >> 8);
    244              cecFrame.args[1]        = (uint8_t)destPhysAddr;
    245              cecFrame.argCount       = 2;
    246          
    247              SiiDrvCpiWrite( &cecFrame );
    248          }
    249          
    250          //------------------------------------------------------------------------------
    251          //! @brief  Send the device name string as the OSD name
    252          //------------------------------------------------------------------------------
    253          static void CecSendSetOsdName ( uint8_t destLogicalAddr )
    254          {
    255              SiiCpiData_t cecFrame;
    256          
    257              cecFrame.opcode         = CECOP_SET_OSD_NAME;
    258              cecFrame.srcDestAddr    = MAKE_SRCDEST( pCec->logicalAddr, destLogicalAddr );
    259              memcpy( &cecFrame.args, pCec->osdName, pCec->osdNameLen );
    260              cecFrame.argCount       = pCec->osdNameLen;
    261          
    262              SiiDrvCpiWrite( &cecFrame );
    263          }
    264          
    265          //------------------------------------------------------------------------------
    266          //! @brief  
    267          //------------------------------------------------------------------------------
    268          void CecSendTextViewOn ( uint8_t destLogicalAddr )
    269          {
    270              SiiCpiData_t cecFrame;
    271          
    272              cecFrame.opcode         = CECOP_TEXT_VIEW_ON;
    273              cecFrame.srcDestAddr    = MAKE_SRCDEST( pCec->logicalAddr, destLogicalAddr );
    274              cecFrame.argCount      = 0;
    275          
    276              SiiDrvCpiWrite( &cecFrame );
    277          }
    278          
    279          //------------------------------------------------------------------------------
    280          //! @brief  
    281          //------------------------------------------------------------------------------
    282          void CecSendUserControlPressed ( uint8_t destLogicalAddr, SiiCecUiCommand_t rcCode )
    283          {
    284              SiiCpiData_t cecFrame;
    285          
    286              cecFrame.opcode         = CECOP_USER_CONTROL_PRESSED;
    287              cecFrame.srcDestAddr    = MAKE_SRCDEST( pCec->logicalAddr, destLogicalAddr );
    288              cecFrame.args[0] = rcCode;
    289              cecFrame.argCount      = 1;
    290          
    291              SiiDrvCpiWrite( &cecFrame );
    292          }
    293          
    294          //------------------------------------------------------------------------------
    295          //! @brief  
    296          //------------------------------------------------------------------------------
    297          void CecSendUserControlReleased ( uint8_t destLogicalAddr, SiiCecUiCommand_t rcCode )
    298          {
    299              SiiCpiData_t cecFrame;
    300          
    301              cecFrame.opcode         = CECOP_USER_CONTROL_RELEASED;
    302              cecFrame.srcDestAddr    = MAKE_SRCDEST( pCec->logicalAddr, destLogicalAddr );
    303              cecFrame.argCount      = 0;
    304          
    305              SiiDrvCpiWrite( &cecFrame );
    306          }
    307          
    308          //------------------------------------------------------------------------------
    309          // Function:    CecHandleFeatureAbort
    310          // Description: Received a failure response to a previous message.  Print a
    311          //              message and notify the rest of the system
    312          //TODO: Enhancement - This function should also keep track of the opcode and the
    313          //              follower that does not recognize the opcode so that the opcode
    314          //              is not sent to that follower again.
    315          //------------------------------------------------------------------------------
    316          
    317          static void CecHandleFeatureAbort ( SiiCpiData_t *pMsg )
    318          {
    319              DEBUG_PRINT(
    320                   CEC_MSG_STAT,
    321                  "\nCEC Message %02X was Feature Aborted (%02X) by logical address %d\n",
    322                  (int)pMsg->args[0],
    323                  pMsg->args[1],
    324                  (int)(pMsg->srcDestAddr >> 4)
    325                  );
    326          }
    327          
    328          //------------------------------------------------------------------------------
    329          // Function:    CecValidateMessage
    330          // Description: Validate parameter count of passed CEC message
    331          //              Returns FALSE if not enough operands for the message
    332          //              Returns TRUE if the correct amount or more of operands (if more
    333          //              the message processor will just ignore them).
    334          //------------------------------------------------------------------------------
    335          
    336          static bool_t CecValidateMessage ( SiiCpiData_t *pMsg )
    337          {
    338              uint8_t parameterCount = 0;
    339              bool_t  countOK = true;
    340              bool_t  isFromUnregistered = false;
    341          
    342              // If message is from Broadcast address, we ignore it except for
    343              // some specific cases.
    344          
    345              if (( pMsg->srcDestAddr & 0xF0 ) == 0xF0 )
    346              {
    347                  switch ( pMsg->opcode )
    348                  {
    349                      case CECOP_STANDBY:
    350                      case CECOP_SYSTEM_AUDIO_MODE_REQUEST:
    351                      case CECOP_ROUTING_CHANGE:
    352                      case CECOP_ROUTING_INFORMATION:
    353                      case CECOP_ACTIVE_SOURCE:
    354                      case CECOP_GIVE_PHYSICAL_ADDRESS:
    355                      case CECOP_REPORT_PHYSICAL_ADDRESS:
    356                      case CECOP_REQUEST_ACTIVE_SOURCE:
    357                      case CECOP_GET_MENU_LANGUAGE:
    358                      case CECOP_SET_STREAM_PATH:
    359                      case CDCOP_HEADER:
    360                          break;
    361                      default:
    362                          isFromUnregistered = true;          // All others should be ignored
    363                          break;
    364                  }
    365              }
    366          
    367              /* Determine required parameter count   */
    368          
    369              switch ( pMsg->opcode )
    370              {
    371                  case CECOP_IMAGE_VIEW_ON:
    372                  case CECOP_TEXT_VIEW_ON:
    373                  case CECOP_STANDBY:
    374                  case CECOP_GIVE_PHYSICAL_ADDRESS:
    375                  case CECOP_GIVE_DEVICE_VENDOR_ID:
    376                  case CECOP_GIVE_DEVICE_POWER_STATUS:
    377                  case CECOP_GET_MENU_LANGUAGE:
    378                  case CECOP_GET_CEC_VERSION:
    379                  case CECOP_INITIATE_ARC:
    380                  case CECOP_REPORT_ARC_INITIATED:
    381                  case CECOP_REPORT_ARC_TERMINATED:
    382                  case CECOP_REQUEST_ARC_INITIATION:
    383                  case CECOP_REQUEST_ARC_TERMINATION:
    384                  case CECOP_TERMINATE_ARC:
    385                  case CECOP_ABORT:
    386          	case CECOP_GIVE_AUDIO_STATUS:
    387                      parameterCount = 0;
    388                      break;
    389                  case CECOP_REPORT_POWER_STATUS:         // power status
    390                  case CECOP_CEC_VERSION:                 // cec version
    391                      parameterCount = 1;
    392                      break;
    393          	case	CECOP_SET_STREAM_PATH:
    394                  case CECOP_INACTIVE_SOURCE:             // physical address
    395                  case CECOP_FEATURE_ABORT:               // feature opcode / abort reason
    396                  case CECOP_ACTIVE_SOURCE:               // physical address
    397                      parameterCount = 2;
    398                      break;
    399                  case CECOP_REPORT_PHYSICAL_ADDRESS:     // physical address / device type
    400                  case CECOP_DEVICE_VENDOR_ID:            // vendor id
    401                      parameterCount = 3;
    402                      break;
    403                  case CECOP_USER_CONTROL_PRESSED:        // UI command
    404                  case CECOP_SET_OSD_NAME:                // osd name (1-14 bytes)
    405                  case CECOP_SET_OSD_STRING:              // 1 + x   display control / osd string (1-13 bytes)
    406                      parameterCount = 1;                 // must have a minimum of 1 operands
    407                      break;
    408          
    409                  default:
    410                      break;
    411              }
    412          
    413              /* Test for correct parameter count.    */
    414          
    415              if (( pMsg->argCount < parameterCount ) || isFromUnregistered )
    416              {
    417                  countOK = false;
    418              }
    419          
    420              return( countOK );
    421          }
    422          
    423          //------------------------------------------------------------------------------
    424          // Function:    UpdateTaskQueueState
    425          // Description: If the current task is idle, clear the queue state and bump
    426          //              the task out index to the next task.
    427          // NOTE:        This function is to be called ONLY after the task server has
    428          //              run a task function.
    429          //------------------------------------------------------------------------------
    430          
    431          static void UpdateTaskQueueState ( void )
    432          {
    433              if ( pCec->currentTask == SiiCECTASK_IDLE )
    434              {
    435                  ACTIVE_TASK.queueState = SiiCecTaskQueueStateIdle;
    436                  pCec->taskQueueOut = (pCec->taskQueueOut + 1) % TASK_QUEUE_LENGTH;
    437              }
    438          }
    439          
    440          //------------------------------------------------------------------------------
    441          //! @brief  Return state of current enumeration task.
    442          //------------------------------------------------------------------------------
    443          bool_t SiiCecEnumerateIsComplete ( void )
    444          {
    445              return( pCec->enumerateComplete );
    446          }
    447          
    448          //------------------------------------------------------------------------------
    449          //! @brief  Return availability of passed logical address.
    450          //------------------------------------------------------------------------------
    451          bool_t SiiCecDeviceLaIsAvailable ( uint8_t deviceLa )
    452          {
    453              return( pCec->logicalDeviceInfo[ deviceLa].deviceType == CEC_DT_COUNT );
    454          }
    455          
    456          //------------------------------------------------------------------------------
    457          //! @brief      Ping every logical address on the CEC bus and log the attached
    458          //!             devices
    459          // cecTaskState.taskData1 == Not Used.
    460          // cecTaskState.taskData2 == Not used
    461          //------------------------------------------------------------------------------
    462          static uint8_t CecTaskEnumerateDevices ( SiiCpiStatus_t *pCecStatus )
    463          {
    464              uint8_t newTask = ACTIVE_TASK.task;
    465          
    466              switch ( ACTIVE_TASK.cpiState )
    467              {
    468              case CPI_IDLE:
    469          
    470                  // We're done if we've reached the unregistered address
    471                  if ( ACTIVE_TASK.pTaskData3[ ACTIVE_TASK.taskData1] >= CEC_LOGADDR_UNREGORBC )
    472                  {
    473                      pCec->enumerateComplete = true;
    474                      SiiCecCbEnumerateComplete( true );          // Let the app layer know.
    475                      //DEBUG_PRINT( CEC_MSG_DBG, "ENUM DONE\n" );
    476                      ACTIVE_TASK.cpiState = CPI_IDLE;
    477                      newTask = SiiCECTASK_IDLE;
    478                      break;
    479                  }
    480                  ACTIVE_TASK.destLA = ACTIVE_TASK.pTaskData3[ ACTIVE_TASK.taskData1++];
    481                  ACTIVE_TASK.msgId = SiiDrvCpiSendPing( ACTIVE_TASK.destLA );
    482                  ACTIVE_TASK.cpiState = CPI_WAIT_ACK;
    483                  break;
    484          
    485              case CPI_WAIT_ACK:
    486                  // Make sure this message status is associated with the message we sent.
    487                  if ( pCecStatus->msgId != ACTIVE_TASK.msgId )
    488                  {
    489                      break;
    490                  }
    491                  if ( pCecStatus->txState == SiiTX_SENDFAILED )
    492                  {
    493                      //DEBUG_PRINT( MSG_DBG, "Enum Task NoAck" );
    494                      CecPrintLogAddr( ACTIVE_TASK.destLA );
    495                     // DEBUG_PRINT( MSG_DBG, "\n" );
    496          
    497                      // Remove LA from active list unless it is a virtual device,
    498                      // which apparently do not respond to our ping even though
    499                      // they are enabled in the CAPTURE_ID register.
    500                      if ( !pCec->logicalDeviceInfo[ ACTIVE_TASK.destLA].isVirtual )
    501                      {
    502                          //DEBUG_PRINT( CEC_MSG_DBG, "Remove LA %X from CEC list\n", ACTIVE_TASK.destLA );
    503                          pCec->logicalDeviceInfo[ ACTIVE_TASK.destLA].cecPA = 0xFFFF;
    504                          pCec->logicalDeviceInfo[ ACTIVE_TASK.destLA].deviceType = CEC_DT_COUNT;
    505                          pCec->logicalDeviceInfo[ ACTIVE_TASK.destLA].selected = false;
    506                      }
    507          
    508                      // Restore Tx State to IDLE to try next address.
    509                      ACTIVE_TASK.cpiState = CPI_IDLE;
    510                  }
    511                  else if ( pCecStatus->txState == SiiTX_SENDACKED )
    512                  {
    513                      //DEBUG_PRINT( MSG_DBG, "Rx Enum Ack" );
    514                      CecPrintLogAddr( ACTIVE_TASK.destLA );
    515                     // DEBUG_PRINT( MSG_DBG, "\n" ); Remove LA
    516          
    517                      // Get the physical address from this source and add it to our
    518                      // list if it responds within 2 seconds, otherwise, ignore it.
    519                      //DEBUG_PRINT(MSG_ALWAYS,"PHYSICAL ADDRESS IS BEING REPORTED WITH DST LA:%d\n",ACTIVE_TASK.destLA);
    520                      ACTIVE_TASK.msgId = SiiCecSendMessage( CECOP_GIVE_PHYSICAL_ADDRESS, ACTIVE_TASK.destLA );
    521                      SiiOsTimerSet( &ACTIVE_TASK.taskTimer, 2000 );
    522                      ACTIVE_TASK.cpiState = CPI_WAIT_RESPONSE;
    523                  }
    524                  break;
    525          
    526              case CPI_WAIT_RESPONSE:
    527                  if ( SiiOsTimerExpired( ACTIVE_TASK.taskTimer ))
    528                  {
    529                      DEBUG_PRINT( CEC_MSG_DBG, "RX Enumerate: Timed out waiting for response\n" );
    530          
    531                      // Ignore this LA and move on to the next.
    532                      ACTIVE_TASK.cpiState = CPI_IDLE;
    533                  }
    534                  break;
    535          
    536              case CPI_RESPONSE:
    537                  // The CEC Rx Message Handler has updated the child port list,
    538                  // restore Tx State to IDLE to try next address.
    539                  ACTIVE_TASK.cpiState = CPI_IDLE;
    540                  break;
    541              }
    542          
    543              return( newTask );
    544          }
    545          
    546          //------------------------------------------------------------------------------
    547          //! @brief      Send a CEC message and wait for ACK.  Perform a callback
    548          //!             when ACK is received or a timeout occurs.
    549          //! @note       This task STARTS in CPI_WAIT_ACK state.
    550          // cecTaskState.taskData1 == Not Used.
    551          // cecTaskState.taskData2 == Not used
    552          //------------------------------------------------------------------------------
    553          static uint8_t CecTaskSendMsg ( SiiCpiStatus_t *pCecStatus )
    554          {
    555              uint8_t newTask = ACTIVE_TASK.task;
    556          
    557              switch ( ACTIVE_TASK.cpiState )
    558              {
    559                  case CPI_IDLE:
    560          
    561                      ACTIVE_TASK.cpiState = CPI_IDLE;
    562                      newTask = SiiCECTASK_IDLE;
    563                      break;
    564          
    565                  case CPI_WAIT_ACK:
    566                      // Make sure this message status is associated with the message we sent.
    567                      if ( pCecStatus->msgId != ACTIVE_TASK.msgId )
    568                      {
    569                          break;
    570                      }
    571                      if ( pCecStatus->txState == SiiTX_SENDFAILED )
    572                      {
    573                         // DEBUG_PRINT( MSG_DBG, "CEC Message Send NoAck" );
    574                          CecPrintLogAddr( ACTIVE_TASK.destLA );
    575                          DEBUG_PRINT( MSG_DBG, "\n" );
    576          
    577                          // Remove LA from active list
    578                          //DEBUG_PRINT( CEC_MSG_DBG, "Remove LA %X from CEC list\n", ACTIVE_TASK.destLA );
    579                          pCec->logicalDeviceInfo[ ACTIVE_TASK.destLA].cecPA      = 0xFFFF;
    580                          pCec->logicalDeviceInfo[ ACTIVE_TASK.destLA].deviceType = CEC_DT_COUNT;
    581                          pCec->logicalDeviceInfo[ ACTIVE_TASK.destLA].selected   = false;
    582                          pCec->logicalDeviceInfo[ ACTIVE_TASK.destLA].isVirtual  = false;
    583                          SiiCecCbSendMessage( ACTIVE_TASK.taskData1, false );
    584                      }
    585                      else if ( pCecStatus->txState == SiiTX_SENDACKED )
    586                      {
    587                          SiiCecCbSendMessage( ACTIVE_TASK.taskData1, true );
    588                      }
    589                      ACTIVE_TASK.cpiState = CPI_IDLE;
    590                      break;
    591                  default:
    592                      ACTIVE_TASK.cpiState = CPI_IDLE;
    593                      break;
    594              }
    595          
    596              return( newTask );
    597          }
    598          
    599          //------------------------------------------------------------------------------
    600          //! @brief      Returns an available logical address from the passed list of
    601          //!             devices.
    602          //! @param[in]  pDeviceList - list of logical addresses to check
    603          //! @return     Available logical address or CEC_LOGADDR_UNREGORBC.
    604          //------------------------------------------------------------------------------
    605          uint8_t SiiCecGetAvailableLa ( uint8_t *pDeviceLaList )
    606          {
    607              int     i;
    608              bool_t  laFound = false;
    609          
    610              // We must have already enumerated
    611              if ( pCec->enumerateComplete )
    612              {
    613                  for ( i = 0; pDeviceLaList[i] < CEC_LOGADDR_UNREGORBC; i++ )
    614                  {
    615                      CecPrintLogAddr( pDeviceLaList[i] );
    616                      if ( SiiCecDeviceLaIsAvailable( pDeviceLaList[i] ))
    617                      {
    618                          laFound = true;
    619                          break;
    620                      }
    621                  }
    622          
    623                  if ( !laFound )
    624                  {
    625                      DEBUG_PRINT( MSG_DBG, "No LA available from list\n" );
    626                  }
    627              }
    628              else
    629              {
    630                  DEBUG_PRINT( MSG_DBG, "Must be enumerated to set LA\n" );
    631              }
    632          
    633              return( laFound ? pDeviceLaList[i] : CEC_LOGADDR_UNREGORBC );
    634          }
    635          
    636          //------------------------------------------------------------------------------
    637          //! @brief  Send the device name string as the OSD name
    638          //------------------------------------------------------------------------------
    639          bool_t SiiCecSetOsdName ( char *pOsdName )
    640          {
    641              int nameLen = strlen( pOsdName );
    642          
    643              pCec->lastResultCode = RESULT_CEC_INVALID_PARAMETER;
    644              if ( nameLen < 14 )
    645              {
    646                  pCec->osdNameLen = nameLen;
    647                  memcpy( pCec->osdName, pOsdName, pCec->osdNameLen );
    648                  pCec->lastResultCode = RESULT_CEC_SUCCESS;
    649              }
    650          
    651              return( pCec->lastResultCode == RESULT_CEC_SUCCESS );
    652          }
    653          
    654          //------------------------------------------------------------------------------
    655          //! @brief  Set the device logical address based on the first available entry
    656          //!         in the passed list of device addresses.  Expects that an enumerate
    657          //!         function has been run.
    658          //------------------------------------------------------------------------------
    659          bool_t SiiCecEnumerateDeviceLa ( uint8_t *pDeviceList )
    660          {
    661              SiiCecTaskState_t  newTask;
    662          
    663              newTask.task        = SiiCECTASK_SETLA;
    664              newTask.taskState   = 0;
    665              newTask.destLA      = 0;
    666              newTask.cpiState    = CPI_IDLE;
    667              newTask.taskData1   = 0;
    668              newTask.taskData2   = 0;
    669              newTask.pTaskData3  = pDeviceList;
    670              return( CecAddTask( &newTask ));
    671          }
    672          
    673          //------------------------------------------------------------------------------
    674          //! @brief  Cancel enumeration task.
    675          //------------------------------------------------------------------------------
    676          void SiiCecEnumerateCancel ( void )
    677          {
    678              if ( pCec->currentTask == SiiCECTASK_ENUMERATE )
    679              {
    680                  pCec->currentTask = SiiCECTASK_CANCEL;
    681                  CecTaskServer( NULL );
    682                  pCec->enumerateComplete = false;
    683              }
    684          }
    685          
    686          //------------------------------------------------------------------------------
    687          //! @brief  Send the appropriate CEC commands to enumerate the passed list of
    688          //!         logical devices on the CEC bus.
    689          //! @return true if added to task queue, false if not
    690          //------------------------------------------------------------------------------
    691          bool_t SiiCecEnumerateDevices ( uint8_t *pDeviceList )
    692          {
    693              SiiCecTaskState_t  newTask;
    694          
    695              pCec->enumerateComplete = false;
    696              SiiCecCbEnumerateComplete( false );     // Let the app layer know.
    697          
    698              newTask.task        = SiiCECTASK_ENUMERATE;
    699              newTask.taskState   = 0;
    700              newTask.destLA      = 0;
    701              newTask.cpiState    = CPI_IDLE;
    702              newTask.taskData1   = 0;
    703              newTask.taskData2   = 0;
    704              newTask.pTaskData3  = pDeviceList;
    705              return( CecAddTask( &newTask ));
    706          }
    707          
    708          //------------------------------------------------------------------------------
    709          //! @brief      Send the appropriate CEC commands to enumerate the passed list
    710          //!             of logical devices on the CEC bus.
    711          //! @param[in]  opCode  - CEC opcode to send
    712          //! @param[in]  src     - source CEC logical address
    713          //! @param[in]  dest    - destination CEC logical address
    714          //! @return     bool_t  true if added to task queue, false if not
    715          //------------------------------------------------------------------------------
    716          bool_t SiiCecSendMessageTaskEx ( uint8_t opCode, uint8_t src, uint8_t dest )
    717          {
    718              SiiCecTaskState_t  newTask;
    719          
    720              if ( !CecIsRoomInTaskQueue())
    721              {
    722                  return( false );
    723              }
    724          
    725              // Add the message to the message queue, then the task will
    726              // wait for an ACK/NACK
    727              newTask.msgId       = SiiCecSendMessageEx( opCode, src, dest );
    728              if (( newTask.msgId == 0 ) || (SiiDrvCpiGetLastResult() != 0))
    729              {
    730                  return( false );
    731              }
    732          
    733              // Message sent successfully, add it to the task queue
    734              newTask.task        = SiiCECTASK_SENDMSG;
    735              newTask.taskState   = 0;
    736              newTask.destLA      = 0;
    737              newTask.cpiState    = CPI_WAIT_ACK; // Start already looking for ACK/NOACK
    738              newTask.taskData1   = opCode;
    739              newTask.taskData2   = 0;
    740              newTask.pTaskData3  = 0;
    741              return( CecAddTask( &newTask ));
    742          }
    743          
    744          //------------------------------------------------------------------------------
    745          //! @brief      Send the appropriate CEC commands to enumerate the passed list
    746          //!             of logical devices on the CEC bus.
    747          //! @param[in]  opCode  - CEC opcode to send
    748          //! @param[in]  dest    - destination CEC logical address
    749          //! @return     bool_t  true if added to task queue, false if not
    750          //!
    751          //! @note       This function is deprecated; please use SiiCecSendMessageTaskEx
    752          //------------------------------------------------------------------------------
    753          bool_t SiiCecSendMessageTask ( uint8_t opCode, uint8_t dest )
    754          {
    755              return( SiiCecSendMessageTaskEx ( opCode, pCec->logicalAddr, dest ));
    756          }
    757          
    758          //------------------------------------------------------------------------------
    759          // Function:    CecTaskServer
    760          // Description: Calls the current task handler.  A task is used to handle cases
    761          //              where we must send and receive a specific set of CEC commands.
    762          //
    763          // NOTE:        If the contents of the SiiCpiStatus_t structure are not new,
    764          //              they should be set to 0 before calling.
    765          //------------------------------------------------------------------------------
    766          
    767          void CecTaskServer ( SiiCpiStatus_t *pCecStatus )
    768          {
    769              uint8_t logicalAddr;
    770              int_t   regTaskIndex;
    771          
    772              switch ( pCec->currentTask )
    773              {
    774                  case SiiCECTASK_CANCEL:
    775          
    776                      // If a task is in progress, cancel it.
    777                      if ( pCec->taskQueue[ pCec->taskQueueOut].queueState == SiiCecTaskQueueStateRunning )
    778                      {
    779                          pCec->taskQueue[ pCec->taskQueueOut].queueState = SiiCecTaskQueueStateIdle;
    780                          pCec->currentTask = SiiCECTASK_IDLE;
    781                      }
    782                      break;
    783          
    784                  case SiiCECTASK_IDLE:
    785                      if ( pCec->taskQueue[ pCec->taskQueueOut].queueState == SiiCecTaskQueueStateQueued )
    786                      {
    787                          pCec->taskQueue[ pCec->taskQueueOut].queueState = SiiCecTaskQueueStateRunning;
    788                          pCec->currentTask = pCec->taskQueue[ pCec->taskQueueOut].task;
    789                      }
    790                      break;
    791          
    792                  case SiiCECTASK_ENUMERATE:
    793                      pCec->currentTask = CecTaskEnumerateDevices( pCecStatus );
    794                      UpdateTaskQueueState();
    795                      break;
    796          
    797                  case SiiCECTASK_SETLA:
    798                      logicalAddr = SiiCecGetAvailableLa( ACTIVE_TASK.pTaskData3 );
    799                      if ( logicalAddr < CEC_LOGADDR_UNREGORBC )
    800                      {
    801                          SiiCecSetDeviceLA( logicalAddr );
    802                      }
    803                      pCec->currentTask = SiiCECTASK_IDLE;
    804                      UpdateTaskQueueState();
    805                      break;
    806          
    807                  case SiiCECTASK_ONETOUCH:
    808                      pCec->currentTask = CecTaskOneTouchPlay( pCecStatus );
    809                      UpdateTaskQueueState();
    810                      break;
    811          
    812                  case SiiCECTASK_SENDMSG:
    813                      pCec->currentTask = CecTaskSendMsg( pCecStatus );
    814                      UpdateTaskQueueState();
    815                      break;
    816          
    817                  default:
    818          
    819                      // Check the registered task list.
    820                      regTaskIndex = pCec->currentTask - SiiCECTASK_COUNT;
    821                      if (( regTaskIndex < MAX_CEC_TASKS) && ( pCec->pTasks[ regTaskIndex ] != 0))
    822                      {
    823                          pCec->currentTask = (*pCec->pTasks[ regTaskIndex])( pCecStatus );
    824                      }
    825                      break;
    826              }
    827          }
    828          
    829          #if INC_CBUS
    830          extern bool_t SkAppCbusCecRxMsgFilter ( SiiCpiData_t *pMsg,  SiiCecLogicalAddresses_t virtualDevLA );
    831          #endif
    832          //------------------------------------------------------------------------------
    833          //! @brief      This is the first message handler called in the chain. It parses
    834          //!             messages that are handled the same way for every system type and
    835          //!             those that it needs to keep the internal component status
    836          //!             up to date.  Some message are left marked as unused so that the
    837          //!             application layer can also see them.
    838          //! @param[in]  pMsg - Pointer to CEC message received
    839          //! @return     true if message consumed, false if not used
    840          //------------------------------------------------------------------------------
    841          static bool_t CecMsgHandlerFirst ( SiiCpiData_t *pMsg )
    842          {
    843              bool_t  usedMessage         = true;
    844              bool_t  isDirectAddressed   = !((pMsg->srcDestAddr & 0x0F ) == CEC_LOGADDR_UNREGORBC );
    845          
    846              // Don't process unless it is intended for the local logical address (we must check
    847              // in case another device has been added for virtual device support).
    848              switch ( pMsg->opcode )
    849              {
    850                  case CECOP_STANDBY:                                             // Direct and Broadcast
    851          #if ( configSII_DEV_953x_PORTING == 0 )
    852                      if ( pCec->powerState != CEC_POWERSTATUS_STANDBY )
    853                      {
    854                          // Next time through the main loop, power will be cycled off
    855          
    856                          pCec->powerState    = CEC_POWERSTATUS_ON_TO_STANDBY;
    857                          pCec->statusFlags   |= SiiCEC_POWERSTATE_CHANGE;        // Signal upper layer
    858                          pCec->isActiveSource = false;                           // Only impacts TX
    859                          
    860          		AmTCecEventPassToHMI(USER_EVENT_CEC_POWER_OFF);
    861                      }
    862          #endif
    863                      AmTCecEventPassToHMI(USER_EVENT_CEC_POWER_OFF);
    864                      break;
    865          
    866                  case CECOP_GIVE_PHYSICAL_ADDRESS:
    867                      if ( isDirectAddressed)                    // Ignore as broadcast message
    868                      {
    869                      	DEBUG_PRINT(MSG_ALWAYS, "PHYSICAL ADDRESS BEING GIVE FROM FIRST HANFLER\n");
    870                          SiiCecSendReportPhysicalAddress( pCec->logicalAddr, pCec->physicalAddr );
    871                      }
    872                      else
    873                      	usedMessage = false;
    874                      break;
    875          
    876                  case CECOP_REPORT_PHYSICAL_ADDRESS:
    877                      if ( !isDirectAddressed )                   // Ignore as direct message
    878                      {
    879                      	if(pMsg->args[2] != 0)
    880                      		pMsg->srcDestAddr = (pMsg->srcDestAddr & 0x0F) | (pMsg->args[2] << 4) ;
    881                          SiiCecUpdateLogicalDeviceInfo((pMsg->srcDestAddr >> 4) & 0x0F,         // broadcast logical address
    882                              (((uint16_t)pMsg->args[0]) << 8) | pMsg->args[1],   // broadcast physical address
    883                              false
    884                              );
    885          
    886                          // Let Enumerate task know about it.
    887                          if ( ACTIVE_TASK.task == SiiCECTASK_ENUMERATE )
    888                          {
    889                              ACTIVE_TASK.cpiState = CPI_RESPONSE;
    890                          }
    891                      }
    892                      break;
    893          
    894                  case CECOP_GIVE_DEVICE_POWER_STATUS:
    895                      if ( isDirectAddressed )                // Ignore as broadcast message
    896                      {
    897          		POWER_STATE power_state;
    898          
    899          		power_state = AmTCecGetSystemPowerStatus();
    900                          SiiCecSendReportPowerStatus( pCec->logicalAddr, pMsg->srcDestAddr >> 4, (uint8_t)power_state );
    901                      }
    902                      else
    903                      	usedMessage = false;
    904                      break;
    905          
    906                  case CECOP_REPORT_POWER_STATUS:                 // Someone sent us their power state.
    907                      if ( isDirectAddressed )                    // Ignore as broadcast message
    908                      {
    909                          pCec->sourcePowerStatus = pMsg->args[0];
    910                      }
    911                      break;
    912          
    913                  case CECOP_USER_CONTROL_PRESSED:
    914                      if ( !isDirectAddressed )   break;  // Ignore as broadcast message
    915          
    916                      // If not a VALID CEC key, feature abort
    917                      if ( !SiiCecValidateKeyCode( pMsg->args[0] ))
    918                      {
    919                          SiiCecFeatureAbortSendEx( pMsg->opcode, CECAR_INVALID_OPERAND, pCec->logicalAddr, GET_CEC_SRC( pMsg->srcDestAddr ));
    920                          break;              // Used the message...
    921                      }
    922                      usedMessage = false;    // Didn't use the message, we just validated the key ID
    923                      break;
    924          
    925                  case CECOP_GIVE_OSD_NAME:
    926                  	SiiCecSetOsdName(pCec->osdName);
    927                  	usedMessage = false;
    928                  	break;
    929          
    930                  case CECOP_GIVE_DEVICE_VENDOR_ID:
    931                  	SiiCecSendVendorId(pCec->logicalAddr, CEC_LOGADDR_UNREGORBC, CecVendorID);
    932                  	break;
    933          
    934                  default:
    935                      usedMessage = false;                        // Didn't use the message
    936                      break;
    937              }
    938          
    939              return( usedMessage );
    940          }
    941          
    942          //------------------------------------------------------------------------------
    943          // Function:    CecMsgHandlerLast
    944          // Description: This is the last message handler called in the chain, and
    945          //              parses any messages left untouched by the previous handlers.
    946          //
    947          // NOTE:        Messages handled here should be common to all system types.
    948          //
    949          //------------------------------------------------------------------------------
    950          
    951          static void CecMsgHandlerLast ( SiiCpiData_t *pMsg )
    952          {
    953              uint8_t         srcAddr;
    954              bool_t          isDirectAddressed;
    955              SiiCpiData_t    cecFrame;
    956          
    957              isDirectAddressed   = !((pMsg->srcDestAddr & 0x0F ) == CEC_LOGADDR_UNREGORBC );
    958              srcAddr             = GET_CEC_SRC( pMsg->srcDestAddr );
    959          
    960              switch ( pMsg->opcode )
    961              {
    962                  case CECOP_FEATURE_ABORT:
    963                      if ( isDirectAddressed )                // Ignore as broadcast message
    964                      {
    965                          CecHandleFeatureAbort( pMsg );
    966                      }
    967                      break;
    968          
    969                      // These messages have already been handled for internal purposes
    970                      // by CecRxMsgHandler and passed to the application level
    971                      // and/or were ignored but not consumed by the application level.
    972                      // Ignore them here.
    973          
    974                  case CECOP_IMAGE_VIEW_ON:
    975                  case CECOP_TEXT_VIEW_ON:
    976                  case CECOP_GET_MENU_LANGUAGE:
    977                  case CECOP_USER_CONTROL_PRESSED:
    978                  case CECOP_USER_CONTROL_RELEASED:
    979          #if ( configSII_DEV_953x_PORTING == 1 )            
    980                  case CECOP_GIVE_AUDIO_STATUS:
    981                  case CECOP_SYSTEM_AUDIO_MODE_REQUEST:
    982          #endif            
    983                      break;
    984          
    985                      // Handle this here because the app level may have upgraded the version
    986                      // and handled it before it gets here.
    987          
    988                  case CECOP_GET_CEC_VERSION:
    989                      if ( isDirectAddressed )                    // Ignore as broadcast message
    990                      {
    991                          // Respond to this request with the CEC version support.
    992                          cecFrame.srcDestAddr   = MAKE_SRCDEST( pCec->logicalAddr, pMsg->srcDestAddr >> 4 );
    993                          cecFrame.opcode        = CECOP_CEC_VERSION;
    994                          cecFrame.args[0]       = 0x05;       // Report CEC1.4
    995                          cecFrame.argCount      = 1;
    996                          SiiDrvCpiWrite( &cecFrame );
    997                      }
    998                      break;
    999          
   1000                  case CECOP_GIVE_OSD_NAME:
   1001                      if ( isDirectAddressed )
   1002                      {
   1003                          CecSendSetOsdName( srcAddr );
   1004                      }
   1005                      break;
   1006          
   1007                      // Ignore these messages if unrecognized AND broadcast
   1008                      // but feature abort them if directly addressed
   1009                  case CECOP_GIVE_DEVICE_VENDOR_ID:
   1010                  case CDCOP_HEADER:
   1011                      if ( isDirectAddressed )
   1012                      {
   1013                          SiiCecFeatureAbortSendEx( pMsg->opcode, CECAR_UNRECOG_OPCODE, GET_CEC_DEST( pMsg->srcDestAddr), srcAddr );
   1014                      }
   1015                      break;
   1016          
   1017                      // Any directly addressed message that gets here is not supported by this
   1018                      // device, so feature abort it with unrecognized opcode.
   1019                      // This means that the app layer must be sure to properly handle any messages
   1020                      // that it should be able to handle.
   1021          
   1022                  case CECOP_ABORT:
   1023                  default:
   1024                      if((pMsg->opcode != CECOP_ABORT) &&
   1025                      		((pMsg->opcode == CECOP_ROUTING_CHANGE) || (pMsg->opcode == CECOP_ROUTING_INFORMATION) || (pMsg->opcode == CECOP_SET_STREAM_PATH)))
   1026                          break;
   1027                      if ( isDirectAddressed )                    // Ignore as broadcast message
   1028                      {
   1029                          SiiCecFeatureAbortSendEx( pMsg->opcode, CECAR_UNRECOG_OPCODE, GET_CEC_DEST( pMsg->srcDestAddr), srcAddr );
   1030                      }
   1031                      break;
   1032              }
   1033          }
   1034          
   1035          //------------------------------------------------------------------------------
   1036          // Function:    SiiCecHandler
   1037          // Description: Polls the send/receive state of the CPI hardware and runs the
   1038          //              current task, if any.
   1039          //
   1040          //              A task is used to handle cases where we must send and receive
   1041          //              a specific set of CEC commands.
   1042          //------------------------------------------------------------------------------
   1043          
   1044          void SiiCecHandler ( void )
   1045          {
   1046              bool_t          processedMsg;
   1047              int_t           callbackIndex, frameCount;
   1048              SiiCpiStatus_t  cecStatus;
   1049              SiiCpiData_t    cecFrame;
   1050              uint8_t			cecDevice;
   1051          	bool_t isVirtualDev = false;
   1052          
   1053              do
   1054              {
   1055                  if ( !pCec->enable ) break;
   1056          
   1057                  SiiDrvCpiServiceWriteQueue();               // Send any pending messages
   1058                  SiiDrvCpiHwStatusGet( &cecStatus );         // Get the CEC transceiver status
   1059          
   1060                  // Now look to see if any CEC commands were received.
   1061                  if ( cecStatus.rxState )
   1062                  {
   1063                      // Get CEC frames until no more are present.
   1064                      cecStatus.rxState = 0;      // Clear activity flag
   1065                      for ( ;; )
   1066                      {
   1067                          frameCount = SiiDrvCpiFrameCount();
   1068                          if ( frameCount == 0 )
   1069                          {
   1070                              break;
   1071                          }
   1072                          if ( !SiiDrvCpiRead( &cecFrame ))
   1073                          {
   1074                              DEBUG_PRINT( CEC_MSG_DBG, "Error in Rx Fifo\n" );
   1075                              break;
   1076                          }
   1077          
   1078                          processedMsg = false;
   1079                          if ( !CecValidateMessage( &cecFrame ))   // If invalid message, ignore it, but treat it as handled
   1080                          {
   1081                              processedMsg = true;
   1082                          }
   1083          
   1084          		//TRACE_DEBUG((0, "SiiCecHandler pMsg->opcode = 0x%X", cecFrame.opcode ));
   1085          		//TRACE_DEBUG((0, "Source and Destination = 0x%X", cecFrame.srcDestAddr));
   1086          		
   1087          #if INC_CBUS
   1088                          for(cecDevice = 0; cecDevice < (CHIP_MAX_VIRTUAL_CEC_DEVS + 1); cecDevice++)//should handle for all cec devices our device is handling
   1089                          {
   1090                          	switch(cecDevice)
   1091                          	{
   1092                          	case 0:
   1093                          		pCec->logicalAddr = pCec->devLogicalAddr; //get back the actual device logical address
   1094                          	    if ( (GET_CEC_DEST( cecFrame.srcDestAddr) != CEC_LOGADDR_UNREGORBC ) && (GET_CEC_DEST( cecFrame.srcDestAddr) != pCec->logicalAddr ))
   1095                          	    {
   1096                          	    	processedMsg = true;; // Don't handle the message
   1097                          	    }
   1098                           		break;
   1099                          	case 1:
   1100                          	case 2:
   1101                          		if(pCec->virtualDevLA[cecDevice-1] != CEC_LOGADDR_TV)
   1102                          		{
   1103                          			processedMsg = false;
   1104                          			pCec->logicalAddr = pCec->virtualDevLA[cecDevice-1]; // assign the virtual logical address with which we need to respond
   1105                          			isVirtualDev = true;
   1106                          			if((GET_CEC_DEST( cecFrame.srcDestAddr) == CEC_LOGADDR_UNREGORBC) || (GET_CEC_DEST( cecFrame.srcDestAddr) == pCec->logicalAddr ))
   1107                          			{
   1108                          				if(SkAppCbusCecRxMsgFilter(&cecFrame,  pCec->virtualDevLA[cecDevice-1]))
   1109                          				{
   1110                          					processedMsg = true;
   1111                          				}
   1112                          				else
   1113                          				{
   1114                          					processedMsg = false;
   1115                          				}
   1116                          			}
   1117                          			else
   1118                          			{
   1119                          				processedMsg = true;
   1120                          			}
   1121                          		}
   1122                          		else
   1123                          		{
   1124                          			processedMsg = true;
   1125                          		}
   1126                          		break;
   1127                          	default:
   1128                          		processedMsg = true;
   1129                          		break;
   1130                          	}
   1131          #endif
   1132                          	if ( !processedMsg && CecMsgHandlerFirst( &cecFrame ))   // Handle the common system messages
   1133                          	{
   1134                          		processedMsg = true;
   1135                          	}
   1136          
   1137                          	// Iterate through registered message handlers.
   1138                          	for ( callbackIndex = 0; callbackIndex < MAX_CEC_PARSERS; callbackIndex++ )
   1139                          	{
   1140                          		if ( pCec->messageHandlers[ callbackIndex].pMsgHandler != 0)
   1141                          		{
   1142                          			// Some handlers must be called every time through the handler.
   1143                          			if ( pCec->messageHandlers[ callbackIndex].callAlways )
   1144                          			{
   1145                          				if ( (*pCec->messageHandlers[ callbackIndex].pMsgHandler)( &cecFrame ) )
   1146                          				{
   1147                          					processedMsg = true;
   1148          							break;
   1149                          				}
   1150                          			}
   1151          
   1152                          			// Other handlers are called only if the message has not been used.
   1153                          			else if ( !processedMsg )
   1154                          			{
   1155                          				if ( (*pCec->messageHandlers[ callbackIndex].pMsgHandler)( &cecFrame ) )
   1156                          				{
   1157                          					processedMsg = true;
   1158          							break;
   1159                          				}
   1160                          			}
   1161                          		}
   1162          
   1163                          	}
   1164          
   1165          
   1166                          	if ( !processedMsg )
   1167                          	{
   1168                          		CecMsgHandlerLast( &cecFrame );   // Let the built-in handler take care of leftovers.
   1169                          	}
   1170          #if INC_CBUS
   1171                          }
   1172          #endif
   1173                      }
   1174                  }
   1175                  else
   1176                  {
   1177                      // No message, but iterate through registered message handlers in case
   1178                      // one or more has an 'always call' tag.  In this case, the handler
   1179                      // is called with a null pointer instead of a pointer to a CEC message
   1180                      for ( callbackIndex = 0; callbackIndex < MAX_CEC_PARSERS; callbackIndex++ )
   1181                      {
   1182                          if ( pCec->messageHandlers[ callbackIndex].pMsgHandler != 0)
   1183                          {
   1184                              if ( pCec->messageHandlers[ callbackIndex].callAlways )
   1185                              {
   1186                                  (*pCec->messageHandlers[ callbackIndex].pMsgHandler)( NULL );
   1187                              }
   1188                          }
   1189                      }
   1190                  }
   1191          
   1192                  // After the current message (if any) has been processed, cecStatus.msgId is
   1193                  // still valid, so we pass that information to the task server in case the message
   1194                  // was one that a task was waiting for.
   1195                  CecTaskServer( &cecStatus );                // Process task even if no new status
   1196          
   1197              } while ( 0 );
   1198          }
   1199          
   1200          //------------------------------------------------------------------------------
   1201          //! @brief  Determine if there is a slot available in the CEC task queue
   1202          //------------------------------------------------------------------------------
   1203          bool_t CecIsRoomInTaskQueue ( void )
   1204          {
   1205          
   1206              if ( pCec->taskQueue[ pCec->taskQueueIn ].queueState == SiiCecTaskQueueStateIdle )
   1207              {
   1208                  return( true );
   1209              }
   1210          
   1211              return( false );
   1212          }
   1213          
   1214          //------------------------------------------------------------------------------
   1215          //! @brief  Add the passed task to the CEC task queue if room.
   1216          //------------------------------------------------------------------------------
   1217          bool_t CecAddTask ( SiiCecTaskState_t *pNewTask )
   1218          {
   1219              bool_t      success = true;
   1220          
   1221              // Store the message in the task queue
   1222              if ( pCec->taskQueue[ pCec->taskQueueIn ].queueState == SiiCecTaskQueueStateIdle )
   1223              {
   1224                  memcpy( &pCec->taskQueue[ pCec->taskQueueIn ], pNewTask, sizeof( SiiCecTaskState_t ));
   1225                  pCec->taskQueue[ pCec->taskQueueIn ].queueState = SiiCecTaskQueueStateQueued;
   1226          
   1227                  pCec->taskQueueIn = (pCec->taskQueueIn + 1) % TASK_QUEUE_LENGTH;
   1228              }
   1229              else
   1230              {
   1231                  //DEBUG_PRINT( MSG_DBG, "CEC Task Queue full\n" );
   1232                  success = false;
   1233              }
   1234          
   1235              pCec->lastResultCode = (success) ? RESULT_CEC_SUCCESS : RESULT_CEC_TASK_QUEUE_FULL;
   1236              return( success );
   1237          }
   1238          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  CecAddTask
             16 -> __aeabi_memcpy
        0  CecIsRoomInTaskQueue
       24  CecMsgHandlerFirst
             24 -> AmTCecEventPassToHMI
             24 -> AmTCecGetSystemPowerStatus
             24 -> SiiCecFeatureAbortSendEx
             24 -> SiiCecSendReportPhysicalAddress
             24 -> SiiCecSendReportPowerStatus
             24 -> SiiCecSendVendorId
             24 -> SiiCecSetOsdName
             24 -> SiiCecUpdateLogicalDeviceInfo
             24 -> SiiCecValidateKeyCode
       32  CecMsgHandlerLast
             32 -> CecSendSetOsdName
             32 -> SiiCecFeatureAbortSendEx
             32 -> SiiDrvCpiWrite
        0  CecPrintLogAddr
       32  CecSendSetOsdName
             32 -> SiiDrvCpiWrite
             32 -> __aeabi_memcpy
       32  CecSendSetStreamPath
             32 -> SiiDrvCpiWrite
       32  CecSendTextViewOn
             32 -> SiiDrvCpiWrite
       32  CecSendUserControlPressed
             32 -> SiiDrvCpiWrite
       32  CecSendUserControlReleased
             32 -> SiiDrvCpiWrite
       24  CecTaskEnumerateDevices
             24 -> SiiCecCbEnumerateComplete
             24 -> SiiCecSendMessage
             24 -> SiiDrvCpiSendPing
             24 -> SiiOsTimerExpired
             24 -> SiiOsTimerSet
       16  CecTaskSendMsg
             16 -> SiiCecCbSendMessage
       16  CecTaskServer
             16 -- Indirect call
             16 -> CecTaskEnumerateDevices
             16 -> CecTaskOneTouchPlay
             16 -> CecTaskSendMsg
             16 -> SiiCecGetAvailableLa
             16 -> SiiCecSetDeviceLA
              0 -> UpdateTaskQueueState
        0  SiiCecDeviceLaIsAvailable
        8  SiiCecEnumerateCancel
              8 -> CecTaskServer
       32  SiiCecEnumerateDeviceLa
             32 -> CecAddTask
       40  SiiCecEnumerateDevices
             40 -> CecAddTask
             40 -> SiiCecCbEnumerateComplete
        0  SiiCecEnumerateIsComplete
       16  SiiCecGetAvailableLa
             16 -> SiiCecDeviceLaIsAvailable
       56  SiiCecHandler
             56 -- Indirect call
             56 -> CecMsgHandlerFirst
             56 -> CecMsgHandlerLast
             56 -> CecTaskServer
             56 -> SiiDrvCpiFrameCount
             56 -> SiiDrvCpiHwStatusGet
             56 -> SiiDrvCpiRead
             56 -> SiiDrvCpiServiceWriteQueue
             56 -> SkAppCbusCecRxMsgFilter
       32  SiiCecSendDeckStatus
             32 -> SiiDrvCpiWrite
       32  SiiCecSendMenuStatus
             32 -> SiiDrvCpiWrite
        0  SiiCecSendMessageTask
              0 -> SiiCecSendMessageTaskEx
       48  SiiCecSendMessageTaskEx
             48 -> CecAddTask
             48 -> CecIsRoomInTaskQueue
             48 -> SiiCecSendMessageEx
             48 -> SiiDrvCpiGetLastResult
       32  SiiCecSendReportPhysicalAddress
             32 -> SiiDrvCpiWrite
       32  SiiCecSendReportPowerStatus
             32 -> SiiDrvCpiWrite
       32  SiiCecSendVendorId
             32 -> SiiDrvCpiWrite
       16  SiiCecSetOsdName
             16 -> __aeabi_memcpy
             16 -> strlen
        0  SiiCecValidateKeyCode
        0  UpdateTaskQueueState


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
      14  ??Subroutine6_0
      26  ?Subroutine0
      14  ?Subroutine1
      12  ?Subroutine2
      10  ?Subroutine3
      14  ?Subroutine4
      10  ?Subroutine5
      86  CecAddTask
      26  CecIsRoomInTaskQueue
     234  CecMsgHandlerFirst
     150  CecMsgHandlerLast
       2  CecPrintLogAddr
      52  CecSendSetOsdName
      46  CecSendSetStreamPath
       8  CecSendTextViewOn
      38  CecSendUserControlPressed
       6  CecSendUserControlReleased
     324  CecTaskEnumerateDevices
     164  CecTaskSendMsg
     184  CecTaskServer
       4  CecVendorID
      24  SiiCecDeviceLaIsAvailable
      38  SiiCecEnumerateCancel
      30  SiiCecEnumerateDeviceLa
      50  SiiCecEnumerateDevices
      12  SiiCecEnumerateIsComplete
      44  SiiCecGetAvailableLa
     382  SiiCecHandler
      20  SiiCecSendDeckStatus
      20  SiiCecSendMenuStatus
      12  SiiCecSendMessageTask
      86  SiiCecSendMessageTaskEx
      44  SiiCecSendReportPhysicalAddress
      20  SiiCecSendReportPowerStatus
      44  SiiCecSendVendorId
      54  SiiCecSetOsdName
      20  SiiCecValidateKeyCode
      50  UpdateTaskQueueState
     128  cecValidate
      16  l_devTypes

 
   148 bytes in section .data
 2 386 bytes in section .text
 
 2 386 bytes of CODE memory
   148 bytes of DATA memory

Errors: none
Warnings: 15

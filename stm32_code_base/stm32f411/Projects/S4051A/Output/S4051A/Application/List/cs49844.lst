###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     12/Nov/2014  09:46:48 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\CS49844\cs49844.c               #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\CS49844\cs49844.c -D S4051A -D  #
#                    DEBUG -D FREE_RTOS -D STM32F40_41xxx -D                  #
#                    USE_STM324xG_EVAL -D USE_STDPERIPH_DRIVER -D             #
#                    __ARM_CORTEX_MX__ -D IAR_ARM_CM4F -D USE_USB_OTG_FS      #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applicati #
#                    on\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Ap #
#                    plication\Obj\ --debug --endian=little --cpu=Cortex-M4   #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\cs49844.lst                                           #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\cs49844.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Libraries\AMT_Drivers\CS49844\cs49844.c
      1          #include "Defs.h"
      2          #include "Debug.h"
      3          #include "freertos_conf.h"
      4          #include "freertos_task.h"
      5          #include "freertos_typedef.h"
      6          #include "api_typedef.h"
      7          #include "AudioDeviceManager.h"
      8          
      9          #include "audio_dsp_uld.h"
     10          #include "audio_gain_parameters.h"
     11          
     12          #include "GPIOMiddleLevel.h"
     13          #include "cs49844_spi.h"
     14          #include "cs49844.h"
     15          #include "UIDeviceManager.h"
     16          #include "ext_flash_driver.h"
     17          
     18          //___________________________________________________________________________________
     19          extern AUDIO_LOWLEVEL_DRIVER_OBJECT *pAudLowLevel_ObjCtrl;
     20          
     21          //___________________________________________________________________________________
     22          typedef enum
     23          {
     24              LOADER_IDLE = 0,
     25              LOADER_HANDLE_Q,
     26              LOADER_RESET_DSP,
     27              LOADER_BOOT_ASSIST,
     28              LOADER_SOFT_RESET_DSP_A,
     29              LOADER_SLAVE_BOOT,  
     30              LOADER_DECODER_ULD,
     31              LOADER_CROSSBAR_ULD,
     32              LOADER_GAIN_ULD,
     33              LOADER_SOFTBOOT,
     34              LOADER_SOFT_RESET,
     35              LOADER_CONIGURATION,
     36              LOADER_KICK_START,
     37              LOADER_CONFIG_USER_SETTING,
     38              LOADER_ERROR
     39          }CS49844_LoaderState;
     40          
     41          typedef struct CS49844_LOADER_PARAMETERS
     42          {
     43              xTaskHandle loaderTaskHandle;
     44              xTaskHandle fmtTaskHandle;
     45              xTaskHandle lowlevelTaskHandle;
     46              xOS_TaskErrIndicator xOS_ErrId;
     47              TaskHandleState fch_detecter_state;
     48              TaskHandleState lowlevel_state;
     49              xSemaphoreParameters spi_sema;
     50              xQueueParameters loaderQueue;
     51          } xOS_CS49844Params;
     52          
     53          typedef struct _CS49844_AUTODETECT_RESPONSE
     54          {
     55              uint8 non_iec61937;
     56              uint8 stream_descriptor;
     57          }CS49844_ADECT_MSG;
     58          
     59          typedef enum{
     60              OS_ULD = 0,
     61              DECODER_ULD,    
     62              CROSSBAR_ULD,
     63              GAIN_ULD,
     64          }cs49844_ULD_Type;
     65          
     66          //___________________________________________________________________________
     67          /*DAO channel remap parameters; AN288 pg.24 */
     68          #define DAO_CHAN_0_REMAP  0x83000012 
     69          #define DAO_CHAN_1_REMAP  0x83000013
     70          #define DAO_CHAN_2_REMAP  0x83000014
     71          #define DAO_CHAN_3_REMAP  0x83000015
     72          #define DAO_CHAN_4_REMAP  0x83000016
     73          #define DAO_CHAN_5_REMAP  0x83000017
     74          #define DAO_CHAN_6_REMAP  0x83000018
     75          #define DAO_CHAN_7_REMAP  0x83000019
     76          
     77          #define DAO_LEFT    0x00000000
     78          #define DAO_RIGHT   0x00000002
     79          #define DAO_LEFT_SURROUND   0x00000003
     80          #define DAO_RIGHT_SURROUND  0x00000004
     81          #define DAO_CENTER  0x00000001
     82          #define DAO_LFE0 0x00000007
     83          #define DAO_RESERVED 0x0000000b
     84          
     85          /*BOOT READ MESSAGE */
     86          #define BOOT_START              0x00000001
     87          #define BOOT_SUCCESS            0x00000002
     88          #define APP_START               0x00000004
     89          #define BOOT_ERROR_CHECKSUM     0x000000FF
     90          #define INVAILD_BOOOT_TYPE      0x000000FE
     91          #define BOOT_FAILURE            0x000000F8
     92          
     93          /*SOFT RESET MESSAGE*/
     94          #define SOFT_RESET              0x40000000
     95          #define SOFT_RESET_DSP_A        0x50000000
     96          
     97          /*SLAVE BOOT MESSAGE*/
     98          #define SLAVE_BOOT              0x80000000
     99          #define CMD_SOFT_BOOT		0x81000009
    100          #define SOFTBOOT_ACK            0x00000005
    101          
    102          #define CS49844_CMD_BASE 0xf0000000
    103          
    104          //! gain_multi_channel_friendly_plus24 (Ls-Rs Gain2) @{
    105          #define RS_G2 	( CS49844_CMD_BASE + _g_0_Ls_Rs_Gain2151 )
    106          #define LS_G2	( CS49844_CMD_BASE + _g_1_Ls_Rs_Gain2151 )
    107          
    108          // gain_multi_channel_plus24 (Center Gain 1)
    109          #define CENTER_G1  ( CS49844_CMD_BASE +  _g_0_Center_Gain_1118 )
    110          
    111          // gain_multi_channel_plus24 (Center Gain 2) 
    112          #define CENTER_G2  ( CS49844_CMD_BASE + _g_0_Center_Gain_2152 )
    113          
    114          // gain_multi_channel_friendly_plus24 (Subwoofer Gain 1)
    115          #define SUBWOOFER_G1 ( CS49844_CMD_BASE + _g_0_Subwoofer_Gain_1120 )  
    116          
    117          // gain_multi_channel_friendly_plus24 (Subwoofer Gain 2)
    118          #define SUBWOOFER_G2 ( CS49844_CMD_BASE + _g_0_Subwoofer_Gain_2132 )
    119          
    120          // gain_multi_channel_plus24 (Master Volume)
    121          // g_1 : signed : 5.27 format
    122          #define MASTER_GAIN1  ( CS49844_CMD_BASE + _g_0_Master_Volume131 ) 
    123          // g_2 : signed : 5.27 format
    124          #define MASTER_GAIN2  ( CS49844_CMD_BASE + _g_1_Master_Volume131 )
    125          // g_3 : signed : 5.27 format
    126          #define MASTER_GAIN3  ( CS49844_CMD_BASE + _g_2_Master_Volume131 )
    127          // g_4 : signed : 5.27 format
    128          #define MASTER_GAIN4  ( CS49844_CMD_BASE + _g_3_Master_Volume131 )
    129          // g_5 : signed : 5.27 format
    130          #define MASTER_GAIN5  ( CS49844_CMD_BASE + _g_4_Master_Volume131 )
    131          // g_6 : signed : 5.27 format
    132          #define MASTER_GAIN6  ( CS49844_CMD_BASE + _g_5_Master_Volume131 )
    133          
    134          #if defined ( S4051A )
    135          //gain_multi_channel_friendly_plus24 (Ls-Rs Gain 1)
    136          // g_1 : signed : 5.27 format
    137          #define BALANCE_LS  ( CS49844_CMD_BASE + _g_0_Ls_Rs_Gain_1_1160 )
    138          // g_2 : signed : 5.27 format
    139          #define BALANCE_RS  ( CS49844_CMD_BASE + _g_1_Ls_Rs_Gain_1_1160 )
    140          
    141          #else
    142          //gain_multi_channel_friendly_plus24 (Ls-Rs Gain 1)
    143          // g_1 : signed : 5.27 format
    144          #define BALANCE_LS  ( CS49844_CMD_BASE + _g_0_Ls_Rs_Gain_1119 )
    145          // g_2 : signed : 5.27 format
    146          #define BALANCE_RS  ( CS49844_CMD_BASE + _g_1_Ls_Rs_Gain_1119 )
    147          #endif
    148          
    149          // tone_control_proc (Tone Control)
    150          #define _treble_level_left 0xd4000001 
    151          #define _treble_level_center   0xd4000002 
    152          #define _treble_level_right 0xd4000003 
    153          #define _treble_level_ls   0xd4000004
    154          #define _treble_level_rs 0xd4000005 
    155          
    156          #define _bass_level_left   0xd4000008
    157          #define _bass_level_center   0xd4000009
    158          #define _bass_level_right   0xd400000a
    159          #define _bass_level_ls   0xd400000b
    160          #define _bass_level_rs   0xd400000c
    161          // _bass_level_left : signed : 32.0 format
    162          #define BASS_LEFT  0xd4000008 
    163          // _bass_level_right : signed : 32.0 format
    164          #define BASS_RIGHT  0xd400000a 
    165          
    166          #define DELAY_VALUE_LEFT   0xd9000002
    167          #define DELAY_VALUE_CENTER 0xd9000003
    168          #define DELAY_VALUE_RIGHT  0xd9000004
    169          #define DELAY_VALUE_LS     0xd9000005
    170          #define DELAY_VALUE_RS     0xd9000006
    171          #define DELAY_VALUE_LFE    0xd9000009
    172          
    173          #define DELAY_TIME_LEFT   0x00333333
    174          #define DELAY_TIME_CENTER 0x00339999
    175          #define DELAY_TIME_RIGHT  0x00333333
    176          #define DELAY_TIME_LS     0x00146666
    177          #define DELAY_TIME_RS     0x00146666
    178          #define DELAY_TIME_LFE    0x00000000
    179          
    180          #define CS49844_READ_BASE 0xf0C00000
    181          #define CS49844_CMD_READ_PRESENCE_LEFT	( CS49844_READ_BASE + _presence_Presence122 )
    182          #define CS49844_CMD_READ_PRESENCE_RIGHT ( CS49844_READ_BASE + _presence_Presence73 )	
    183          
    184          #define CS49844_RESPONSE_BASE 0x70C00000
    185          #define PRESENCE_RESPONSE_LEFT ( CS49844_RESPONSE_BASE + _presence_Presence122 )
    186          #define PRESENCE_RESPONSE_RIGHT	( CS49844_RESPONSE_BASE + _presence_Presence73 )
    187          
    188          #define READ_RESPONSE_MESSAGE 0x6fc00000
    189          #define DSP_CFG_STREAM_TYPE READ_RESPONSE_MESSAGE+0x00000002
    190          //___________________________________________________________________________
    191          #define LOADER_QUEUE_LENGTH 2
    192          #define AUTO_DETECTION_RESPONSE (0x81000000)
    193          #define FCH_DETECTOR_TIME_TICK  TASK_MSEC2TICKS(10)
    194          #define LOADER_TIME_TICK TASK_MSEC2TICKS(10)
    195          #define LOWLEVEL_TIME_TICK TASK_MSEC2TICKS(500)
    196          #define SOFTRESET_TIMEOUT TASK_MSEC2TICKS(1000)
    197          //___________________________________________________________________________
    198          CS49844_ADECT_MSG mAdtectMsg;
    199          
    200          //___________________________________________________________________________
    201          static CS49844_LoaderState mLoaderState = LOADER_IDLE;
    202          static xOS_CS49844Params xOS_CS49844;  
    203          static CS49844LoadAudioStreamType gCurDSP_ULD_type = CS49844_LOAD_PCM;
    204          static const CS49844LoadAudioStreamType *pCurtDSP_ULD_TYPE = &gCurDSP_ULD_type;
    205          static uint8 signal_overthreshold = 1;
    206          static xSemaphoreHandle _IRQ_SEMA = NULL;
    207          
    208          /* PCM load procedure: OS -> tv_cs-> pcm_black_b */
    209          #if ( configAPP_SPI_FLASH_DSP_ULD == 1 )
    210          unsigned int PCM_ULD_LOCATION[4][2] = 
    211          {
    212              {PCM_INIT_ULD_START_LOCATION,PCM_INIT_ULD_LENGTH}, /* OS */
    213              {0,0}, /* PCM don't need decoder*/
    214              {PCM_CROSSBAR_ULD_START_LOCATION,PCM_CROSSBAR_ULD_LENGTH},    
    215              {PCM_GAIN_ULD_START_LOCATION,PCM_GAIN_ULD_LENGTH},
    216          };
    217          
    218          /* AC3 load procedure: OS-> AC3 -> Crossbar-> ac3_black_b */
    219          unsigned int AC3_ULD_LOCATION[4][2] = 
    220          {
    221              {PCM_INIT_ULD_START_LOCATION,PCM_INIT_ULD_LENGTH}, /* OS */
    222              {AC3_INIT_ULD_START_LOCATION,AC3_INIT_ULD_LENGTH}, /* Decoder */     
    223              {AC3_CROSSBAR_ULD_START_LOCATION,AC3_CROSSBAR_ULD_LENGTH},    
    224              {AC3_GAIN_ULD_START_LOCATION,AC3_GAIN_ULD_LENGTH},
    225          };
    226          /* DTS load procedure: OS-> DTS -> Crossbar-> dts_black_b */
    227          unsigned int DTS_ULD_LOCATION[4][2] = 
    228          {
    229              {PCM_INIT_ULD_START_LOCATION,PCM_INIT_ULD_LENGTH}, /* OS */   
    230              {DTS_INIT_ULD_START_LOCATION,DTS_INIT_ULD_LENGTH}, /* Decoder */      
    231              {DTS_CROSSBAR_ULD_START_LOCATION,DTS_CROSSBAR_ULD_LENGTH},
    232              {DTS_GAIN_ULD_START_LOCATION,DTS_GAIN_ULD_LENGTH},
    233          };
    234          
    235          static unsigned char* ULDLoaderbuf = NULL;
    236          #endif 
    237          
    238          //___________________________________________________________________________
    239          static void cs49844_RowDataLoader_CreateTask( void );
    240          
    241          static bool cs49844_RowDataLoader_InstrReceiver( CS49844_QUEUE_TYPE *pType ) ;
    242          
    243          static uint8 cs49844_RowDataLoader_GetQueueNumber( void );
    244          
    245          static void cs49844_HardReset( void );
    246          
    247          static void cs49844_FchDetector_CreateTask( void );
    248          
    249          static void cs49844_FchDetector_TaskCtrl( xOS_TaskCtrl val );
    250          
    251          static void cs49844_RowDataLoader_TaskCtrl( xOS_TaskCtrl val );
    252          
    253          static bool cs49844_RowDataLoader_InstrSender( void *parms ) ;
    254          
    255          static void cs49844_LowLevelDetector_CreateTask( void );
    256          
    257          static void cs49844_LowLevelDetector_TaskCtrl( xOS_TaskCtrl val );
    258          
    259          static void cs49844_setMute( bool val );
    260          
    261          static bool cs49844_spi_mutex_take( void );
    262          
    263          static bool cs49844_spi_mutex_give( void );
    264          
    265          static bool cs49844_irq_mutex_take( void );
    266          
    267          static bool cs49844_irq_mutex_give( void );
    268          
    269          static void cs49844_setMasterGain( uint32 value );
    270          
    271          static void cs49844_setBassGain( uint32 value );
    272          
    273          static void cs49844_setTrebleGain( uint32 value );
    274          
    275          static void cs49844_setSubGain( uint32 value );
    276          
    277          static void cs49844_setCenterGain( uint32 value );
    278          
    279          static void cs49844_setLsRsGain( uint32 value );
    280          
    281          static void cs49844_setBalanceLs( uint32 value );
    282          
    283          static void cs49844_setBalanceRs( uint32 value );
    284          
    285          static void cs49844_SetTVHDMC_Ctrl( byte* data, uint16 length );
    286          
    287          static void cs49844_setNightMode( uint32 value );
    288          
    289          static void cs49844_setAVDelay( uint32 value );
    290          
    291          static void cs49844_setAudioRoute(CS49844AudioRoute val);
    292          
    293          static void cs49844_setSilenceThreshold( bool value );
    294          
    295          static CS49844LoadAudioStreamType cs49844_GetAudioStreamType( void );
    296          
    297          static uint8 cs49844_GetLoadrState( void );
    298          
    299          #if ( configAPP_SPI_FLASH_DSP_ULD == 1 )
    300          static int cs49844_LoadDSP_ULD(unsigned char* buf,CS49844LoadAudioStreamType Stype ,cs49844_ULD_Type Utype );
    301          #endif 
    302          
    303          uint8 cs49844_getSignalLevel( void );
    304          
    305          static void cs49844_lowlevel_task_setState( TaskHandleState set_state );
    306          
    307          #if (configAPP_INTERNAL_DSP_ULD == 1 )
    308          static int8 cs49844_Load_DSP_ULD_InternalFlash( CS49844LoadAudioStreamType type, cs49844_ULD_Type module );
    309          #endif 
    310          
    311          const DSP_CTRL_OBJECT DSP_ObjCtrl = 
    312          {
    313              cs49844_RowDataLoader_CreateTask,
    314              cs49844_RowDataLoader_TaskCtrl,
    315              cs49844_FchDetector_CreateTask,
    316              cs49844_FchDetector_TaskCtrl,
    317              cs49844_RowDataLoader_InstrSender,
    318              cs49844_LowLevelDetector_CreateTask,
    319              cs49844_LowLevelDetector_TaskCtrl,
    320              cs49844_lowlevel_task_setState,
    321              cs49844_setMute,
    322              cs49844_setMasterGain,
    323              cs49844_setBassGain,
    324              cs49844_setTrebleGain,
    325              cs49844_setSubGain,
    326              cs49844_setCenterGain,
    327              cs49844_setLsRsGain,
    328              cs49844_setBalanceLs,
    329              cs49844_setBalanceRs,
    330              cs49844_SetTVHDMC_Ctrl,
    331              cs49844_setNightMode,
    332              cs49844_setAVDelay,
    333              cs49844_setAudioRoute,
    334              cs49844_setSilenceThreshold,
    335              cs49844_GetAudioStreamType,
    336              cs49844_GetLoadrState,
    337              cs49844_getSignalLevel,
    338              cs49844_spi_mutex_take,
    339              cs49844_spi_mutex_give
    340          };
    341          
    342          const DSP_CTRL_OBJECT *pDSP_ObjCtrl = &DSP_ObjCtrl;
    343          
    344          //___________________________________________________________________________
    345          static void cs49844_setMute( bool val )
    346          {
    347              if (cs49844_spi_mutex_take() == TRUE )
    348              {
    349                  if ( val == TRUE ) /*mute*/
    350                  {
    351                      //CS49844SPI_CommandWrite( 0x83000001, 0x00000001 );
    352                      //TRACE_DEBUG((0, "cs49844_setMute CS49844SPI_CommandWrite mute"));
    353                  }
    354                  else
    355                  {
    356                      //CS49844SPI_CommandWrite( 0x83000001, 0x00000000 );
    357                      //TRACE_DEBUG((0, "cs49844_setMute CS49844SPI_CommandWrite unmute"));
    358                  }
    359          
    360                  cs49844_spi_mutex_give();
    361              }
    362          }
    363          
    364          static void cs49844_setMasterGain( uint32 value )
    365          {
    366              if ( value > 0x08000000 )
    367                  return;        
    368              
    369              if (cs49844_spi_mutex_take() == TRUE )
    370              {
    371                  //CS49844SPI_CommandWrite(MASTER_GAIN1, value );
    372                  //CS49844SPI_CommandWrite(MASTER_GAIN2, value );
    373                  //CS49844SPI_CommandWrite(MASTER_GAIN3, value );
    374                  //CS49844SPI_CommandWrite(MASTER_GAIN4, value );
    375                  //CS49844SPI_CommandWrite(MASTER_GAIN5, value );
    376                  //CS49844SPI_CommandWrite(MASTER_GAIN6, value );
    377          
    378                  cs49844_spi_mutex_give();
    379              }
    380          }
    381          
    382          static void cs49844_setBassGain( uint32 value )
    383          {
    384              if (cs49844_spi_mutex_take() == TRUE )
    385              {
    386                  //CS49844SPI_CommandWrite(_bass_level_left, value);
    387                  //CS49844SPI_CommandWrite(_bass_level_center, value);
    388                  //CS49844SPI_CommandWrite(_bass_level_right, value);
    389                  //CS49844SPI_CommandWrite(_bass_level_ls, value);
    390                  //CS49844SPI_CommandWrite(_bass_level_rs, value); 
    391          
    392                  cs49844_spi_mutex_give();
    393              }
    394          }
    395          
    396          static void cs49844_setTrebleGain( uint32 value )
    397          {
    398              if (cs49844_spi_mutex_take() == TRUE )
    399              {
    400                  //CS49844SPI_CommandWrite(_treble_level_left, value);
    401                  //CS49844SPI_CommandWrite(_treble_level_center, value);
    402                  //CS49844SPI_CommandWrite(_treble_level_right, value);
    403                  //CS49844SPI_CommandWrite(_treble_level_ls, value);
    404                  //CS49844SPI_CommandWrite(_treble_level_rs, value); 
    405          
    406                  cs49844_spi_mutex_give();
    407              }
    408          }
    409          
    410          static void cs49844_setSubGain( uint32 value )
    411          {
    412              if (cs49844_spi_mutex_take() == TRUE )
    413              {
    414                 // CS49844SPI_CommandWrite(SUBWOOFER_G2, value );
    415          
    416                  cs49844_spi_mutex_give();
    417              }
    418          }
    419          
    420          static void cs49844_setCenterGain( uint32 value )
    421          {
    422              if (cs49844_spi_mutex_take() == TRUE )
    423              {
    424                 // CS49844SPI_CommandWrite(CENTER_G2, value);  
    425          
    426                  cs49844_spi_mutex_give();
    427              }
    428          }
    429          
    430          static void cs49844_setLsRsGain( uint32 value )
    431          {
    432              if (cs49844_spi_mutex_take() == TRUE )
    433              {
    434                 // CS49844SPI_CommandWrite(RS_G2, value);  
    435                 // CS49844SPI_CommandWrite(LS_G2, value);  
    436          
    437                  cs49844_spi_mutex_give();
    438              }
    439          }
    440          
    441          static void cs49844_setBalanceLs( uint32 value )
    442          {
    443              if (cs49844_spi_mutex_take() == TRUE )
    444              {
    445                  //CS49844SPI_CommandWrite(BALANCE_LS, value);     
    446          
    447                  cs49844_spi_mutex_give();
    448              }
    449          }
    450          
    451          static void cs49844_setBalanceRs( uint32 value )
    452          {
    453              if (cs49844_spi_mutex_take() == TRUE )
    454              {
    455                  //CS49844SPI_CommandWrite(BALANCE_RS, value);     
    456          
    457                  cs49844_spi_mutex_give();
    458              }
    459          }
    460          
    461          static void cs49844_SetTVHDMC_Ctrl( byte* data, uint16 length )
    462          {
    463              if ( mLoaderState == LOADER_IDLE )
    464              {
    465                  if (cs49844_spi_mutex_take() == TRUE )
    466                  {
    467                  //    CS49844SPI_write_buffer(data, length);
    468                  
    469                      cs49844_spi_mutex_give();
    470                  }
    471              }
    472          }
    473          
    474          static void cs49844_setNightMode( uint32 value )
    475          {
    476              if (cs49844_spi_mutex_take() == TRUE )
    477              {
    478                  //CS49844SPI_CommandWrite(SUBWOOFER_G1, value );
    479              
    480                  cs49844_spi_mutex_give();
    481              }
    482          }
    483          
    484          static void cs49844_setAVDelay( uint32 value )
    485          {
    486              if (cs49844_spi_mutex_take() == TRUE )
    487              {
    488                 // CS49844SPI_CommandWrite(DELAY_VALUE_LEFT, DELAY_TIME_LEFT + 0x140000 * value );
    489                  
    490                  //CS49844SPI_CommandWrite(DELAY_VALUE_CENTER, DELAY_TIME_CENTER +  0x140000 * value );
    491                  //CS49844SPI_CommandWrite(DELAY_VALUE_RIGHT, DELAY_TIME_RIGHT +  0x140000 * value ); 
    492                  //CS49844SPI_CommandWrite(DELAY_VALUE_LS, DELAY_TIME_LS +  0x140000 * value );
    493                  //CS49844SPI_CommandWrite(DELAY_VALUE_RS, DELAY_TIME_RS +  0x140000 * value );
    494                  //CS49844SPI_CommandWrite(DELAY_VALUE_LFE, DELAY_TIME_LFE +  0x140000 * value );
    495              
    496                  cs49844_spi_mutex_give();
    497              }
    498          }
    499          
    500          static void cs49844_setAudioRoute(CS49844AudioRoute val)
    501          {
    502              if (cs49844_spi_mutex_take() == TRUE )
    503              {
    504                  if ( val == ROUTE_INITIAL )
    505                  {
    506                      CS49844SPI_write_buffer((byte*)&DSP_DAO_ROUTER_INITIAL, (sizeof(DSP_DAO_ROUTER_INITIAL)/sizeof(uint8)));
    507                  }
    508          
    509                  /*Clean internal channel map*/
    510                  //CS49844SPI_CommandWrite(DAO_CHAN_0_REMAP, DAO_RESERVED );
    511                  //CS49844SPI_CommandWrite(DAO_CHAN_1_REMAP, DAO_RESERVED );
    512                  //CS49844SPI_CommandWrite(DAO_CHAN_2_REMAP, DAO_RESERVED );
    513                  //CS49844SPI_CommandWrite(DAO_CHAN_3_REMAP, DAO_RESERVED );
    514                  //CS49844SPI_CommandWrite(DAO_CHAN_4_REMAP, DAO_RESERVED );
    515                  //CS49844SPI_CommandWrite(DAO_CHAN_5_REMAP, DAO_RESERVED );
    516                  //CS49844SPI_CommandWrite(DAO_CHAN_6_REMAP, DAO_RESERVED );
    517                  //CS49844SPI_CommandWrite(DAO_CHAN_7_REMAP, DAO_RESERVED );
    518             
    519                  
    520                  switch( val )
    521                  {
    522                      case ROUTE_FL_FR:
    523                      {
    524                         // CS49844SPI_CommandWrite( DAO_CHAN_0_REMAP, DAO_LEFT ); /*FL*/
    525                         // CS49844SPI_CommandWrite( DAO_CHAN_1_REMAP, DAO_RIGHT ); /*FR*/
    526                      }
    527                          break;
    528                  
    529                      case ROUTE_RR_RL:
    530                      {
    531                        //  CS49844SPI_CommandWrite( DAO_CHAN_6_REMAP, DAO_LEFT ); /*RL*/
    532                        //  CS49844SPI_CommandWrite( DAO_CHAN_7_REMAP, DAO_RIGHT ); /*RR*/
    533                      }
    534                          break;
    535                      
    536                      case ROUTE_FL:
    537                      {
    538                          /*channel 0 outputs left sound*/
    539                         // CS49844SPI_CommandWrite( DAO_CHAN_0_REMAP, DAO_LEFT ); /*FL*/           
    540                      }
    541                          break;
    542                  
    543                      case ROUTE_FR:
    544                      {
    545                         // CS49844SPI_CommandWrite( DAO_CHAN_1_REMAP, DAO_RIGHT ); /*FR*/
    546                      }
    547                          break;
    548                  
    549                      case ROUTE_RL:
    550                      {
    551                        //  CS49844SPI_CommandWrite( DAO_CHAN_6_REMAP, DAO_LEFT ); /*RL*/
    552                      }
    553                          break;
    554                  
    555                      case ROUTE_RR:
    556                      {
    557                          //CS49844SPI_CommandWrite( DAO_CHAN_7_REMAP, DAO_RIGHT ); /*RR*/
    558                      }
    559                          break;
    560                  
    561                      case ROUTE_CENTER:
    562                      {
    563                          /*Smith: Fix center outputs too huge, when mode was in factory mode */
    564                         // CS49844SPI_CommandWrite( DAO_CHAN_3_REMAP, DAO_CENTER );
    565                        //  CS49844SPI_CommandWrite( DAO_CHAN_2_REMAP, DAO_CENTER ); /*CENTER*/        
    566                      }
    567                          break;
    568                  
    569                      case ROUTE_LFE0:
    570                      {
    571                         // CS49844SPI_CommandWrite( DAO_CHAN_4_REMAP, DAO_RIGHT ); /*LFE0*/  
    572                        //  CS49844SPI_CommandWrite( DAO_CHAN_5_REMAP, DAO_LEFT ); /*LFE0*/                
    573                      }
    574                          break;
    575                  
    576                      case ROUTE_FL_FR_CENTER:
    577                      {
    578                        //  CS49844SPI_CommandWrite( DAO_CHAN_0_REMAP, DAO_LEFT ); /*FL*/   
    579                         // CS49844SPI_CommandWrite( DAO_CHAN_1_REMAP, DAO_RIGHT ); /*FR*/
    580                          
    581                          /*Smith: Fix center outputs too huge, when mode was in factory mode */  
    582                        //  CS49844SPI_CommandWrite( DAO_CHAN_3_REMAP, DAO_CENTER );
    583                        //  CS49844SPI_CommandWrite( DAO_CHAN_2_REMAP, DAO_CENTER ); /*CENTER*/
    584                      }
    585                      break;
    586                      
    587                      case ROUTE_RR_RL_WOOFER:
    588                      {
    589                       //   CS49844SPI_CommandWrite( DAO_CHAN_6_REMAP, DAO_LEFT ); /*RL*/
    590                       //   CS49844SPI_CommandWrite( DAO_CHAN_7_REMAP, DAO_RIGHT ); /*RR*/
    591                          
    592                       //   CS49844SPI_CommandWrite( DAO_CHAN_4_REMAP, DAO_RIGHT ); /*LFE0*/  
    593                       //   CS49844SPI_CommandWrite( DAO_CHAN_5_REMAP, DAO_LEFT ); /*LFE0*/ 
    594                      }
    595                      break;
    596          
    597          			case ROUTE_DISABLE:
    598                      default:
    599                      {
    600                       //   CS49844SPI_write_buffer((byte*)&DSP_DAO_ROUTER_INITIAL, (sizeof(DSP_DAO_ROUTER_INITIAL)/sizeof(uint8)));
    601                      }
    602                          break;
    603                  }
    604          
    605                  cs49844_spi_mutex_give();
    606              }
    607          }
    608          
    609          static void cs49844_setSilenceThreshold( bool value )
    610          {
    611              if (cs49844_spi_mutex_take() == TRUE )
    612              {
    613                  if (value)
    614                  {
    615                   //   CS49844SPI_CommandWrite(0x81000008, 0x0083d600);/* Silence threshold 90s */
    616                  }
    617                  else
    618                  {
    619                    //  CS49844SPI_CommandWrite(0x81000008, 0x00005dc0);/* Silence_threshold 0.25 second */
    620                  }
    621          
    622                  cs49844_spi_mutex_give();
    623              }
    624          }
    625          
    626          static CS49844LoadAudioStreamType cs49844_GetAudioStreamType( void )
    627          {
    628              return gCurDSP_ULD_type;
    629          }
    630          
    631          static uint8 cs49844_GetLoadrState( void )
    632          {
    633              return mLoaderState;
    634          }
    635          
    636          static int CS49844_readPresence( uint8 *pValue )
    637          {
    638              int8 spi_rError1 = 0;
    639              int8 spi_rError2 = 0;
    640              int ret = 0;
    641              uint32 LeftChannelSignal;
    642              uint32 RightChannelSignal;
    643              uint32 command = 0;
    644              uint32 value;
    645              uint8 cnt;
    646              if ( pValue == NULL )
    647                  return -1;
    648          
    649              if (cs49844_spi_mutex_take() == TRUE )
    650              {
    651          #if 0
    652                  /*AN288 2.1.2 Solicited Read*/
    653                  cnt = 0;
    654                  do 
    655                  {
    656                      /*Read Command Word(left)*/
    657                      command = CS49844_CMD_READ_PRESENCE_LEFT;
    658                      if (CS49844SPI_write_buffer((byte*)&command,(sizeof(command)/sizeof(uint8))) != SCP1_PASS )
    659                      {
    660                          ret = -2;
    661                      }
    662                      /*Read response command word*/
    663                      spi_rError1 = CS49844SPI_read_buffer((byte*)&value,(sizeof(command)/sizeof(uint8))); 
    664          
    665                      /*Read response Data word*/ 
    666                      spi_rError2 = CS49844SPI_read_buffer((byte*)&value, (sizeof(command)/sizeof(uint8)));
    667                      
    668                      if ( spi_rError1 == SCP1_PASS && spi_rError2== SCP1_PASS)
    669                      {   
    670                          LeftChannelSignal = value;
    671                          break;
    672                      }
    673                      
    674                      cnt++;
    675                      if (cnt>2)
    676                      {
    677                          ret = -3;
    678                          break;
    679                      }
    680                  }while((spi_rError1!= SCP1_PASS)||(spi_rError2!= SCP1_PASS));        
    681                  cnt=0;
    682                  do 
    683                  {
    684                      /*Read Command Word(right)*/
    685                      command = CS49844_CMD_READ_PRESENCE_RIGHT;
    686                      if (CS49844SPI_write_buffer((byte*)&command,(sizeof(command)/sizeof(uint8))) != SCP1_PASS )
    687                      {
    688                          ret = -4;
    689                      }
    690                            
    691                      /*Read response command word*/
    692                      spi_rError1 = CS49844SPI_read_buffer((byte*)&value, (sizeof(command)/sizeof(uint8)));
    693          
    694                      /*Read response Data word*/ 
    695                      spi_rError2 = CS49844SPI_read_buffer((byte*)&value, (sizeof(command)/sizeof(uint8)));
    696          
    697                      if ( spi_rError1 == SCP1_PASS && spi_rError2 == SCP1_PASS)
    698                      {   
    699                          RightChannelSignal = value;
    700                          break;
    701                      }
    702          
    703                      cnt++;
    704                      if (cnt>2)
    705                      {
    706                          ret = -5;
    707                          break;
    708                      }
    709                  }while((spi_rError1!= SCP1_PASS)||(spi_rError2!= SCP1_PASS));
    710                  
    711                  if ( ret == 0 )
    712                  {
    713                      if( ( LeftChannelSignal | RightChannelSignal ) )
    714                      {
    715                          *pValue = 1;
    716                      }
    717                      else
    718                      {
    719                          *pValue = 0;
    720                      }
    721                  }
    722                  else
    723                  {
    724                      *pValue = 1;
    725                  }
    726          #endif
    727          
    728                  cs49844_spi_mutex_give();
    729              }
    730              return ret;
    731          }
    732          
    733          uint8 cs49844_getSignalLevel( void )
    734          {
    735              return signal_overthreshold;
    736          }
    737          
    738          static bool cs49844_spi_mutex_take( void )
    739          {
    740              if ( SPILowLevel_isEnable() != TRUE )
    741              {
    742                  //TRACE_DEBUG((0, "SPI TAKE BUSY 1111 !! "));
    743                  return FALSE;
    744              }   
    745          
    746              if ( xOS_CS49844.spi_sema.xSemaphore == NULL )
    747              {
    748                  //TRACE_DEBUG((0, "SPI TAKE BUSY 2222 !! "));
    749                  return FALSE;
    750              }
    751          
    752              xOS_CS49844.spi_sema.xBlockTime = portMAX_DELAY;
    753              if ( xSemaphoreTake( xOS_CS49844.spi_sema.xSemaphore, xOS_CS49844.spi_sema.xBlockTime ) != pdTRUE )
    754              {
    755                  //TRACE_DEBUG((0, "SPI TAKE BUSY 3333 !! "));
    756                  return FALSE;
    757              }
    758          
    759              return TRUE;
    760          }
    761          
    762          static bool cs49844_spi_mutex_give( void )
    763          {
    764              if ( SPILowLevel_isEnable() != TRUE )
    765                  return FALSE;
    766          
    767              if ( xOS_CS49844.spi_sema.xSemaphore == NULL )
    768                  return FALSE;
    769          
    770              if ( xSemaphoreGive( xOS_CS49844.spi_sema.xSemaphore ) != pdTRUE )
    771              {
    772                  //TRACE_DEBUG((0, "SPI GIVE BUSY !! "));
    773                  return FALSE;	
    774              }
    775          
    776              return TRUE;
    777          }
    778          
    779          static bool cs49844_irq_mutex_take( void )
    780          {
    781              if ( _IRQ_SEMA == NULL )
    782              {
    783                  //TRACE_DEBUG((0, "IRQ TAKE BUSY 2222 !! "));
    784                  return FALSE;
    785              }
    786          
    787              if ( xSemaphoreTake( _IRQ_SEMA, 0 ) != pdTRUE )
    788              //if ( xSemaphoreTake( xOS_CS49844.spi_sema.xSemaphore, 0xff ) != pdTRUE )
    789              {
    790                  //TRACE_DEBUG((0, "IRQ TAKE BUSY 3333 !! "));
    791                  return FALSE;
    792              }
    793          
    794              return TRUE;    
    795          }
    796          
    797          static bool cs49844_irq_mutex_give( void )
    798          {
    799          #if 1
    800              if ( _IRQ_SEMA == NULL )
    801                  return FALSE;
    802          
    803              if ( xSemaphoreGive( _IRQ_SEMA ) != pdTRUE )
    804              {
    805                  //TRACE_DEBUG((0, "IRQ GIVE BUSY 111 !! "));
    806                  return FALSE;   
    807              }
    808          
    809              //TRACE_DEBUG((0, "IRQ GIVE OK !! "));
    810          #endif    
    811              return TRUE;
    812          }
    813          
    814          static void cs49844_lowlevel_task_setState( TaskHandleState set_state )
    815          {
    816              if ( set_state == TASK_SUSPENDED )
    817              {
    818                  if ( xOS_CS49844.lowlevel_state == TASK_RUNING )
    819                  {
    820                      xOS_CS49844.lowlevel_state = TASK_SUSPENDED;
    821                  }
    822              }
    823              else if ( set_state == TASK_RUNING )
    824              {
    825                  if ( xOS_CS49844.lowlevel_state == TASK_SUSPENDED )
    826                  {
    827                      xOS_CS49844.lowlevel_state = TASK_RUNING;
    828                  }
    829              }
    830          }
    831          
    832          void cs49844_lowlevel_task( void *pvParameters )
    833          {
    834              int ret = 0;
    835          
    836              for( ;; )
    837              {
    838                  switch( xOS_CS49844.lowlevel_state )
    839                  {
    840                      case TASK_SUSPENDED:
    841                      {
    842                      }
    843                          break;
    844          
    845                      case TASK_RUNING:
    846                      {
    847                          if( (*pCurtDSP_ULD_TYPE == CS49844_LOAD_PCM ) && ( mLoaderState == LOADER_IDLE ) )
    848                          {
    849                              //ret = CS49844_readPresence( &signal_overthreshold );
    850                              if ( ret != 0 )
    851                              {
    852                                  TRACE_ERROR((0, "presence error =%X signal_overthreshold=%X",ret,signal_overthreshold));
    853                              }
    854                          }
    855                      }
    856                          break;
    857          
    858                  }
    859          
    860                  vTaskDelay(LOWLEVEL_TIME_TICK);
    861              }
    862          }
    863          
    864          static void cs49844_LowLevelDetector_TaskCtrl( xOS_TaskCtrl val )
    865          {
    866              signal_overthreshold = 1;
    867          
    868              if ( val == xOS_setTASK_SUSPENDED )
    869              {
    870                  cs49844_lowlevel_task_setState( TASK_SUSPENDED );
    871                  if ( xTaskIsTaskSuspended( xOS_CS49844.lowlevelTaskHandle ) != pdPASS ) /*task is working*/
    872                  {
    873                      vTaskSuspend( xOS_CS49844.lowlevelTaskHandle );
    874                  }
    875              }
    876              else if ( val == xOS_setTASK_RESUME )
    877              {
    878                  cs49844_lowlevel_task_setState( TASK_RUNING );
    879                  if ( xTaskIsTaskSuspended( xOS_CS49844.lowlevelTaskHandle ) == pdPASS ) /*task is not working*/
    880                  {
    881                      vTaskResume( xOS_CS49844.lowlevelTaskHandle );
    882                      //TRACE_DEBUG((0, "RESUME: CS49844_lowlevel"));
    883                  }
    884              }
    885          }
    886          
    887          static void cs49844_LowLevelDetector_CreateTask( void )
    888          {
    889              signal_overthreshold = 0;
    890              if ( xTaskCreate( 
    891                      cs49844_lowlevel_task, 
    892                      ( portCHAR * ) "CS49844_lowlevel", 
    893                      (STACK_SIZE), 
    894                      NULL, 
    895                      tskCS49844_LowLevelDetection_PRIORITY, 
    896                      &xOS_CS49844.lowlevelTaskHandle ) != pdPASS )
    897              {
    898                  vTaskDelete( xOS_CS49844.lowlevelTaskHandle );
    899              }
    900              else
    901              {
    902                  vTaskSuspend( xOS_CS49844.lowlevelTaskHandle );
    903              }
    904          }   
    905          
    906          static CS49844_ADECT_MSG cs49844_getAutoDectMsg( uint32 data )
    907          {
    908              CS49844_ADECT_MSG msg;
    909          
    910              if ( NON_IEC61937_STREAM_FLAG(data) > 0 ) 
    911              {
    912                  msg.non_iec61937 = 0x01;
    913              }
    914              else if ( NON_IEC61937_STREAM_FLAG(data) == 0 )
    915              {
    916                  msg.non_iec61937 = 0x00;
    917              }
    918          
    919              msg.stream_descriptor = (uint8)NON_IEC61937_STREAM_DESCRIPTOR(data);
    920          
    921              return msg;
    922          }
    923          
    924          static void cs49844_parseAudioFMT(CS49844_QUEUE_TYPE *tmp_queue_data, CS49844_ADECT_MSG msg)
    925          {
    926              tmp_queue_data->audio_type = CS49844_LOAD_NULL;
    927              
    928              if ( msg.non_iec61937 == 0x01)/*PCM*/
    929              {
    930                  switch( msg.stream_descriptor)
    931                  {
    932                      case NON_IEC61937_DTS_FORMAT_16:
    933                      case NON_IEC61937_DTS_FORMAT_14:
    934                      {
    935                          tmp_queue_data->audio_type = CS49844_LOAD_DTS;
    936                      }
    937                          break;
    938          
    939                      case NON_IEC61937_SILENT_INPUT_DATA:{}break;
    940                      
    941                      default:
    942                      {
    943                          tmp_queue_data->audio_type = CS49844_LOAD_PCM;
    944                          TRACE_DEBUG((0, "tmp_queue_data->audio_type = CS49844_LOAD_PCM !! "));
    945                      }
    946                          break;
    947                  }
    948              }
    949              else /*NON PCM*/
    950              {
    951                  switch( msg.stream_descriptor)
    952                  {
    953                      case IEC61937_STREAM_AC3:
    954                      {
    955                          tmp_queue_data->audio_type = CS49844_LOAD_AC3;
    956                      }
    957                          break;
    958          
    959                      case IEC61937_STREAM_DTS_1:
    960                      case IEC61937_STREAM_DTS_2:
    961                      case IEC61937_STREAM_DTS_3:
    962                      {
    963                          tmp_queue_data->audio_type = CS49844_LOAD_DTS;
    964                      }
    965                          break;
    966                      
    967                      default:
    968                      {
    969                          tmp_queue_data->audio_type = CS49844_LOAD_PCM;
    970                      }
    971                          break;
    972                  }
    973              }
    974          }
    975          
    976          static void cs49844_SendEventToLoader( CS49844_ADECT_MSG msg )
    977          {
    978              CS49844_QUEUE_TYPE QUEUE_TYPE;
    979          
    980              cs49844_parseAudioFMT(&QUEUE_TYPE, msg);
    981                      
    982              if (QUEUE_TYPE.audio_type != CS49844_LOAD_NULL)
    983              {
    984          #if 1
    985                  //TRACE_DEBUG((0, "cs49844_SendEventToLoader !! "));
    986          
    987                  if (cs49844_spi_mutex_take( ) == TRUE)
    988                  //if ( cs49844_irq_mutex_take() == TRUE )
    989                  {
    990                      //TRACE_ERROR((0, "send message to data loader ----- !! "));
    991                      QUEUE_TYPE.source_ctrl = CS49844_SOURCE_DSP;
    992                      cs49844_RowDataLoader_InstrSender(&QUEUE_TYPE);
    993                  }
    994                  else
    995                  {
    996                      //TRACE_ERROR((0, "Can't send message to data loader ----- !! "));
    997                      cs49844_irq_mutex_give();
    998          
    999                  }    
   1000          #else
   1001                  //TRACE_ERROR((0, "send message to data loader ----- !! "));
   1002                  cs49844_RowDataLoader_InstrSender(&QUEUE_TYPE);
   1003          #endif
   1004              }
   1005              else
   1006              {
   1007                  cs49844_irq_mutex_give();
   1008                  //TRACE_ERROR((0, "send message CS49844_LOAD_NULL ----- !! "));
   1009              }
   1010          }
   1011          
   1012          void cs49844_FchDetector( void *pvParameters )
   1013          {
   1014              uint32 u32ReadCommand = 0;
   1015              uint32 u32ReadData;    // 4-byte Unsolicited Read Data
   1016              
   1017              for( ;; )
   1018              {
   1019                  switch (xOS_CS49844.fch_detecter_state )
   1020                  {
   1021                      case TASK_SUSPENDED:
   1022                      {
   1023                          xOS_CS49844.fch_detecter_state = TASK_RUNING;
   1024                      }
   1025                          break;
   1026                    
   1027                      case TASK_RUNING:
   1028                      {
   1029          
   1030                          break;
   1031                      
   1032                          if( GPIOMiddleLevel_Read_InBit( __I_SCP1_IRQ ) == 0 )
   1033                          {
   1034                              //if ( cs49844_spi_mutex_give() == TRUE )
   1035                              //TRACE_DEBUG((0, "cs49844_FchDetector IRQ enter !! "));
   1036                              if (cs49844_irq_mutex_take() == TRUE)
   1037                              {
   1038                                  if ( cs49844_spi_mutex_take() == TRUE )
   1039                                  //if ( cs49844_irq_mutex_take() == TRUE )
   1040                                  {
   1041                                      //TRACE_DEBUG((0, "take spi mutex------- !! "));
   1042                                      if (CS49844SPI_nIrq_read_buffer((byte *)&u32ReadCommand, (sizeof(u32ReadCommand) / sizeof(uint8))) != SCP1_PASS)
   1043                                      {
   1044                                          //pAudLowLevel_ObjCtrl->RstSRC();
   1045                                          //TRACE_DEBUG((0, "break out------- !! "));
   1046                                          cs49844_spi_mutex_give();
   1047                                          cs49844_irq_mutex_give();
   1048                                          
   1049                                          break;
   1050                                      }
   1051                                      
   1052                                      if (u32ReadCommand == AUTO_DETECTION_RESPONSE)
   1053                                      {
   1054                                          //TRACE_DEBUG((0, "audio type change------- !! "));
   1055                                          CS49844SPI_nIrq_read_buffer((byte *)&u32ReadData, (sizeof(u32ReadData) / sizeof(uint8)));
   1056                                          mAdtectMsg = cs49844_getAutoDectMsg( u32ReadData );
   1057                                          //TRACE_DEBUG((0, "-Audio stream changes = 0x%X, 0x%X", mAdtectMsg.non_iec61937, mAdtectMsg.stream_descriptor ));
   1058                                          cs49844_spi_mutex_give();
   1059                                          //TRACE_DEBUG((0,"cs49844_FchDetector SPI enter"));
   1060                                          cs49844_SendEventToLoader( mAdtectMsg );
   1061                                      }
   1062                                      else
   1063                                      {
   1064                                          //TRACE_DEBUG((0,"cs49844_FchDetector no change----------------"));
   1065                                          cs49844_spi_mutex_give();
   1066                                          cs49844_irq_mutex_give();
   1067                                      }
   1068                                      //TRACE_DEBUG((0, "111111111111break out------- !! "));
   1069                                  }
   1070                              }
   1071                          }
   1072                      }
   1073                          break;
   1074                  }
   1075          
   1076                  vTaskDelay( FCH_DETECTOR_TIME_TICK );
   1077              }
   1078          
   1079          }
   1080          
   1081          static void cs49844_HardReset( void )
   1082          {
   1083              GPIOMiddleLevel_Set(__O_DSP_RES);
   1084              vTaskDelay(TASK_MSEC2TICKS(1));
   1085              GPIOMiddleLevel_Clr(__O_DSP_RES);
   1086              vTaskDelay(TASK_MSEC2TICKS(1));
   1087              GPIOMiddleLevel_Set(__O_DSP_RES);
   1088              vTaskDelay(TASK_MSEC2TICKS(1));
   1089          
   1090              //TRACE_DEBUG((0, "DSP HARDWARE RESET !! "));
   1091          }
   1092          
   1093          static uint8 cs49844_RowDataLoader_GetQueueNumber( void )
   1094          {
   1095              uint8 i_qnumber = (uint8)uxQueueMessagesWaiting( xOS_CS49844.loaderQueue.xQueue );
   1096              //TRACE_DEBUG((0, "Q total size -----------%d !! ",i_qnumber));
   1097              return i_qnumber;
   1098          }
   1099          
   1100          static bool cs49844_RowDataLoader_InstrReceiver( CS49844_QUEUE_TYPE *pType ) 
   1101          {
   1102              if ( pType == NULL )
   1103              {
   1104                  return FALSE;
   1105              }
   1106              
   1107              if ( xOS_CS49844.loaderQueue.xQueue == NULL )
   1108              {
   1109                  xOS_CS49844.xOS_ErrId = xOS_TASK_QUEUE_IS_NULL;
   1110                  return FALSE;
   1111              }
   1112          
   1113              if ( xQueueReceive( xOS_CS49844.loaderQueue.xQueue, pType, xOS_CS49844.loaderQueue.xBlockTime ) != pdPASS )
   1114              {
   1115                  xOS_CS49844.xOS_ErrId = xOS_TASK_QUEUE_GET_FAIL;
   1116                  return FALSE;
   1117              }
   1118          
   1119              return TRUE;
   1120          }
   1121          
   1122          bool cs49844_RowDataLoader_InstrSender( void *parms ) 
   1123          {
   1124              const CS49844_QUEUE_TYPE* pQueueType = ( CS49844_QUEUE_TYPE *)parms;
   1125          
   1126              if ( pQueueType == NULL )
   1127              {
   1128                  return FALSE;
   1129              }
   1130              
   1131              if ( xOS_CS49844.loaderQueue.xQueue == NULL )
   1132              {
   1133                  return FALSE;
   1134              }
   1135          
   1136              //if( pQueueType->audio_type == CS49844_LOAD_NULL || pQueueType->source_ctrl == CS49844_SOURCE_NONE)
   1137              if( pQueueType->audio_type == CS49844_LOAD_NULL)
   1138              {
   1139                  return FALSE;
   1140              }
   1141          
   1142              if ( SPILowLevel_isEnable () == FALSE )
   1143              {
   1144                  return FALSE;
   1145              }
   1146          
   1147          #if 0 //repeat type handle 
   1148              if ( gCurDSP_ULD_type == *pType )
   1149                  return FALSE;
   1150          #endif
   1151          
   1152              xQueueReset(xOS_CS49844.loaderQueue.xQueue);
   1153              if ( xQueueSend( xOS_CS49844.loaderQueue.xQueue, pQueueType, xOS_CS49844.loaderQueue.xBlockTime ) != pdPASS )
   1154              {
   1155                  xOS_CS49844.xOS_ErrId = xOS_TASK_QUEUE_SET_FAIL;
   1156                  return FALSE;
   1157              }
   1158          
   1159              return TRUE;
   1160          
   1161          }
   1162          
   1163          void cs49844_RowDataLoader_Task( void *pvParameters )
   1164          {
   1165              static CS49844_QUEUE_TYPE QueueType;
   1166              uint32 value = SLAVE_BOOT;
   1167              CS49844_QUEUE_TYPE tmp_QueueType;
   1168              
   1169              for( ;; )
   1170              {
   1171                  switch( mLoaderState )
   1172                  {
   1173                      case LOADER_IDLE:
   1174                      {
   1175                          if( cs49844_RowDataLoader_GetQueueNumber( ) > 0 ) 
   1176                          {
   1177                              mLoaderState = LOADER_HANDLE_Q;
   1178                          }
   1179                          else
   1180                          {
   1181                              //pADM_ObjCtrl->SetBackCtrlStatus(BACKCTRL_FCH_NOCHANGE);
   1182                              cs49844_spi_mutex_give( );
   1183                              cs49844_irq_mutex_give();
   1184                          }
   1185                      }
   1186                          break;
   1187          
   1188                      case LOADER_HANDLE_Q:
   1189                      {
   1190                          if ( cs49844_RowDataLoader_GetQueueNumber( ) > 0 )
   1191                          {
   1192                              cs49844_RowDataLoader_InstrReceiver( &QueueType );
   1193                          }
   1194          
   1195                          if ( gCurDSP_ULD_type == QueueType.audio_type)
   1196                          {
   1197                              mLoaderState = LOADER_IDLE;
   1198                              tmp_QueueType.audio_type = QueueType.audio_type;
   1199                              tmp_QueueType.source_ctrl = QueueType.source_ctrl;
   1200                              
   1201                              pAudLowLevel_ObjCtrl->BackCtrlSender(&tmp_QueueType);
   1202                              cs49844_spi_mutex_give( );
   1203                              if (QueueType.source_ctrl == CS49844_SOURCE_DSP)
   1204                              {
   1205                                  cs49844_irq_mutex_give( );
   1206                              }
   1207                          }
   1208                          /*If user change the source, detect format first*/
   1209                          else if (QueueType.audio_type == CS49844_LOAD_USER_CTRL)
   1210                          {
   1211                              uint32 u32ReadData;    // 4-byte Unsolicited Read Data
   1212                              CS49844_ADECT_MSG mUserCtrlMsg;
   1213          
   1214                              if(QueueType.source_ctrl==CS49844_SOURCE_USER)
   1215                              {
   1216                                  /*Read format*/
   1217                                  CS49844SPI_ReadSolicited(DSP_CFG_STREAM_TYPE,&u32ReadData);
   1218                                  mUserCtrlMsg = cs49844_getAutoDectMsg( u32ReadData );
   1219                                  cs49844_parseAudioFMT(&QueueType, mUserCtrlMsg);
   1220          
   1221                                  if ( (gCurDSP_ULD_type == QueueType.audio_type) || (QueueType.audio_type == CS49844_LOAD_NULL))
   1222                                  {
   1223                                      mLoaderState = LOADER_IDLE;
   1224                                      tmp_QueueType.audio_type = QueueType.audio_type;
   1225                                      tmp_QueueType.source_ctrl = QueueType.source_ctrl;
   1226          
   1227                                      pAudLowLevel_ObjCtrl->BackCtrlSender(&tmp_QueueType);
   1228                                      cs49844_spi_mutex_give( );                        
   1229                                  }
   1230                                  else
   1231                                  {
   1232          #if ( configAPP_INTERNAL_DSP_ULD == 0 )                
   1233                                      if (ULDLoaderbuf == NULL)
   1234                                      {
   1235                                          ULDLoaderbuf = (unsigned char*)pvPortMalloc( DSPLoadSize);
   1236                                      }
   1237                                                      
   1238                                      if(ULDLoaderbuf == NULL)
   1239                                      {
   1240                                          TRACE_ERROR(( 0, "It isn't enough memory size %d", xPortGetFreeHeapSize() ));
   1241                                          mLoaderState = LOADER_IDLE;
   1242                                          cs49844_spi_mutex_give( );
   1243                                      }
   1244                                      else
   1245                                      {
   1246                                          mLoaderState = LOADER_RESET_DSP;
   1247                                      }
   1248          #else
   1249                                      pAudLowLevel_ObjCtrl->SetVolRampEvent(AUD_VOL_EVENT_SET_MUTE);
   1250                                      mLoaderState = LOADER_RESET_DSP;
   1251          #endif
   1252                                  }
   1253                              }    
   1254                              else if (QueueType.source_ctrl==CS49844_SOURCE_PROCESS_MODE)
   1255                              {
   1256                                  mLoaderState = LOADER_SOFTBOOT; 
   1257                                  QueueType.audio_type = gCurDSP_ULD_type;
   1258                              }
   1259                          }
   1260                          else
   1261                          {
   1262          #if ( configAPP_INTERNAL_DSP_ULD == 0 )                
   1263                              if (ULDLoaderbuf == NULL)
   1264                              {
   1265                                  ULDLoaderbuf = (unsigned char*)pvPortMalloc( DSPLoadSize);
   1266                              }
   1267                                              
   1268                              if(ULDLoaderbuf == NULL)
   1269                              {
   1270                                  TRACE_ERROR(( 0, "It isn't enough memory size %d", xPortGetFreeHeapSize() ));
   1271                                  mLoaderState = LOADER_IDLE;
   1272                                  cs49844_spi_mutex_give( );
   1273                                  cs49844_irq_mutex_give( );
   1274                              }
   1275                              else
   1276                              {
   1277                                  mLoaderState = LOADER_RESET_DSP;
   1278                              }
   1279          #else
   1280                              pAudLowLevel_ObjCtrl->SetVolRampEvent(AUD_VOL_EVENT_SET_MUTE);
   1281                              mLoaderState = LOADER_RESET_DSP;
   1282          #endif
   1283                          }
   1284                      }
   1285                          break;
   1286          
   1287                      /*CS49844x Hardware User's Manual p2-8*/
   1288                      case LOADER_RESET_DSP:
   1289                      {
   1290                          cs49844_HardReset( );
   1291                          mLoaderState = LOADER_BOOT_ASSIST;
   1292                      }
   1293                          break;
   1294          
   1295                      case LOADER_BOOT_ASSIST:
   1296                      {
   1297                          //! write slave boot @{
   1298                          value = SLAVE_BOOT;
   1299                          if (CS49844SPI_write_buffer((byte*)&value, (sizeof(value)/sizeof(uint8))) == SCP1_BSY_TIMEOUT )
   1300                          {
   1301                              mLoaderState = LOADER_ERROR;
   1302                              break;
   1303                          } //@}
   1304                          
   1305                          vTaskDelay(TASK_MSEC2TICKS(1));
   1306                          if ( CS49844SPI_MsgNote1((byte*)&value,sizeof(value)) != SCP1_PASS )
   1307                          {
   1308                              mLoaderState = LOADER_ERROR;
   1309                              break;
   1310                          }
   1311          
   1312                          if ( value != BOOT_START )
   1313                          {
   1314                              mLoaderState = LOADER_ERROR;
   1315                              break;
   1316                          }
   1317                          
   1318          #if ( configAPP_INTERNAL_DSP_ULD == 0 )                
   1319                          /* load DSP Init ULD */
   1320                          if(cs49844_LoadDSP_ULD(ULDLoaderbuf,QueueType.audio_type, OS_ULD) == 0)
   1321                          {
   1322                              mLoaderState = LOADER_ERROR;
   1323                              break;
   1324                          }
   1325          #else
   1326                          if (cs49844_Load_DSP_ULD_InternalFlash(QueueType.audio_type,OS_ULD) == -1 )
   1327                          {
   1328                              mLoaderState = LOADER_ERROR;
   1329                              break;
   1330                          }
   1331          #endif
   1332                          
   1333                          vTaskDelay(TASK_MSEC2TICKS(1));
   1334                          if ( CS49844SPI_MsgNote1((byte*)&value,sizeof(value)) != SCP1_PASS )
   1335                          {
   1336                              mLoaderState = LOADER_ERROR;
   1337                              break;
   1338                          }
   1339                         
   1340                          if ( value != BOOT_SUCCESS)
   1341                          {
   1342                              mLoaderState = LOADER_ERROR;
   1343                              break;
   1344                          }
   1345          
   1346                          //TRACE_DEBUG((0, "DSP BOOT_ASSIST BOOT SUCCESS !! "));
   1347                          mLoaderState = LOADER_SOFT_RESET_DSP_A;
   1348                      }
   1349                          break;
   1350          
   1351                      case LOADER_SOFT_RESET_DSP_A:
   1352                      {
   1353                          value = SLAVE_BOOT;
   1354                          if (CS49844SPI_write_buffer((byte*)&value, (sizeof(value)/sizeof(uint8))) == SCP1_BSY_TIMEOUT)
   1355                          {
   1356                              mLoaderState = LOADER_ERROR;
   1357                              break;
   1358                          }
   1359                                          
   1360                          if ( CS49844SPI_read_buffer((byte*)&value, sizeof(value)) == SCP1_IRQ_TIMEOUT )
   1361                          {
   1362                              mLoaderState = LOADER_ERROR;
   1363                              break;
   1364                          }
   1365                          
   1366                          if ( value != BOOT_START)
   1367                          {
   1368                              mLoaderState = LOADER_ERROR;
   1369                              break;
   1370                          }
   1371          
   1372                          if (QueueType.audio_type == CS49844_LOAD_PCM)
   1373                          {
   1374                              mLoaderState = LOADER_CROSSBAR_ULD;
   1375                              break;
   1376                          }
   1377                          else
   1378                          {
   1379                              mLoaderState = LOADER_DECODER_ULD; 
   1380                              break;
   1381                          }
   1382                      }
   1383                          break;
   1384                      
   1385                      case LOADER_DECODER_ULD:
   1386                      {                  
   1387                          /* load DSP Decoder ULD */
   1388          #if ( configAPP_INTERNAL_DSP_ULD == 0 )                
   1389                          if(cs49844_LoadDSP_ULD(ULDLoaderbuf,QueueType.audio_type,DECODER_ULD) == 0)
   1390                          {
   1391                              TRACE_DEBUG((0,"cs49844_LoadDSP_ULD LOADER_ERROR"));
   1392                              mLoaderState = LOADER_ERROR;
   1393                              break;
   1394                          }
   1395          #else
   1396                          if (cs49844_Load_DSP_ULD_InternalFlash(QueueType.audio_type, DECODER_ULD) == -1 )
   1397                          {
   1398                              mLoaderState = LOADER_ERROR;
   1399                              break;
   1400                          }
   1401          #endif 
   1402                          vTaskDelay(TASK_MSEC2TICKS(1));
   1403                          /*BOOT_SUCCESS*/
   1404                          if ( CS49844SPI_read_buffer((byte*)&value,sizeof(value)) == SCP1_IRQ_TIMEOUT )
   1405                          {
   1406                              
   1407                              mLoaderState = LOADER_ERROR;
   1408                              break;
   1409                          }
   1410                          
   1411                          if ( value != BOOT_SUCCESS)
   1412                          {
   1413                              mLoaderState = LOADER_ERROR;
   1414                              break;
   1415                          }
   1416                          /* BOOT_START */
   1417                          value = SLAVE_BOOT;
   1418                          if (CS49844SPI_write_buffer((byte*)&value, (sizeof(value)/sizeof(uint8))) == SCP1_BSY_TIMEOUT )
   1419                          {
   1420                              mLoaderState = LOADER_ERROR;
   1421                              break;
   1422                          }
   1423          
   1424                          if ( CS49844SPI_read_buffer((byte*)&value,sizeof(value)) == SCP1_IRQ_TIMEOUT )
   1425                          {
   1426                              mLoaderState = LOADER_ERROR;
   1427                              break;
   1428                          }
   1429                          
   1430                          if ( value != BOOT_START)
   1431                          {
   1432                              mLoaderState = LOADER_ERROR;
   1433                              break;
   1434                          }
   1435                          mLoaderState = LOADER_CROSSBAR_ULD;
   1436                      }
   1437                          break;
   1438          
   1439                      case LOADER_CROSSBAR_ULD:
   1440                      {
   1441                          /* load DSP CrossBar ULD */
   1442          #if ( configAPP_INTERNAL_DSP_ULD == 0 )                
   1443                          if(cs49844_LoadDSP_ULD(ULDLoaderbuf,QueueType.audio_type,CROSSBAR_ULD) == 0)
   1444                          {
   1445                              TRACE_DEBUG((0,"CrossBar ULD LOADER_ERROR"));
   1446                              mLoaderState = LOADER_ERROR;
   1447                              break;
   1448                          }
   1449          #else
   1450                          if (cs49844_Load_DSP_ULD_InternalFlash(QueueType.audio_type, CROSSBAR_ULD) == -1 )
   1451                          {
   1452                              mLoaderState = LOADER_ERROR;
   1453                              break;
   1454                          }
   1455          #endif 
   1456                          vTaskDelay(TASK_MSEC2TICKS(1));
   1457                          /*BOOT_SUCCESS*/
   1458                          if ( CS49844SPI_read_buffer((byte*)&value,sizeof(value)) == SCP1_IRQ_TIMEOUT )
   1459                          {
   1460                              mLoaderState = LOADER_ERROR;
   1461                              break;
   1462                          }
   1463                          
   1464                          if ( value != BOOT_SUCCESS)
   1465                          {
   1466                              mLoaderState = LOADER_ERROR;
   1467                              break;
   1468                          }
   1469                          /* BOOT_START */
   1470                          value = SLAVE_BOOT;
   1471                          if (CS49844SPI_write_buffer((byte*)&value, (sizeof(value)/sizeof(uint8))) == SCP1_BSY_TIMEOUT )
   1472                          {
   1473                              mLoaderState = LOADER_ERROR;
   1474                              break;
   1475                          }
   1476          
   1477                          if ( CS49844SPI_read_buffer((byte*)&value,sizeof(value)) == SCP1_IRQ_TIMEOUT )
   1478                          {
   1479                              mLoaderState = LOADER_ERROR;
   1480                              break;
   1481                          }
   1482                          
   1483                          if ( value != BOOT_START)
   1484                          {
   1485                              mLoaderState = LOADER_ERROR;
   1486                              break;
   1487                          }
   1488                          mLoaderState = LOADER_GAIN_ULD;
   1489                      }   
   1490                          break;
   1491          
   1492                      case LOADER_GAIN_ULD:
   1493                      {
   1494          #if ( configAPP_INTERNAL_DSP_ULD == 0 )            
   1495                          if(cs49844_LoadDSP_ULD(ULDLoaderbuf,QueueType.audio_type,GAIN_ULD) == 0)
   1496                          {
   1497                              mLoaderState = LOADER_ERROR;
   1498                              break;
   1499                          }
   1500          #else
   1501                          if (cs49844_Load_DSP_ULD_InternalFlash(QueueType.audio_type, GAIN_ULD) == -1 )
   1502                          {
   1503                              mLoaderState = LOADER_ERROR;
   1504                              break;
   1505                          }
   1506          #endif 
   1507                          vTaskDelay(TASK_MSEC2TICKS(1));
   1508                          /* BOOT_SUCCESS */
   1509                          if ( CS49844SPI_read_buffer((byte*)&value,sizeof(value)) == SCP1_IRQ_TIMEOUT )
   1510                          {
   1511                               mLoaderState = LOADER_ERROR;
   1512                               break;
   1513                          }
   1514                                          
   1515                          if ( value != BOOT_SUCCESS)
   1516                          {
   1517                              mLoaderState = LOADER_ERROR;
   1518                              break;
   1519                          }
   1520                          mLoaderState = LOADER_SOFT_RESET;
   1521                      }
   1522                          break;
   1523          
   1524                      case LOADER_SOFTBOOT:
   1525                      {
   1526                          uint32 value = 0;
   1527                          uint32 soft_timeout = 0;
   1528                          value = SOFT_RESET;
   1529          
   1530                          CS49844SPI_CommandWrite(CMD_SOFT_BOOT, 0x00000001);
   1531                          soft_timeout = xTaskGetTickCount( );
   1532                          while( GPIOMiddleLevel_Read_InBit( __I_SCP1_IRQ ) == 1 )
   1533                          {
   1534                              if ( ((xTaskGetTickCount() - soft_timeout)/portTICK_RATE_MS) > TASK_MSEC2TICKS(100) )
   1535                              {
   1536                                  soft_timeout = 0;
   1537                                  mLoaderState = LOADER_ERROR;
   1538                                  break;
   1539                              }
   1540                          }
   1541          
   1542                          soft_timeout = xTaskGetTickCount( );
   1543                          do
   1544                          {
   1545                              while( GPIOMiddleLevel_Read_InBit( __I_SCP1_IRQ ) == 0 )
   1546                              {
   1547                                  CS49844SPI_read_buffer((byte*)&value,sizeof(value)) == SCP1_IRQ_TIMEOUT;
   1548                              }
   1549                              if ( ((xTaskGetTickCount() - soft_timeout)/portTICK_RATE_MS) > TASK_MSEC2TICKS(1000) )
   1550                              {
   1551                                  soft_timeout = 0;
   1552                                  mLoaderState = LOADER_ERROR;
   1553                                  break;
   1554                              }
   1555          
   1556                          }while (value != SOFTBOOT_ACK);
   1557                          mLoaderState = LOADER_SOFT_RESET;                
   1558                      }
   1559                          break;
   1560                          
   1561                      case LOADER_SOFT_RESET:
   1562                      {
   1563                          value = SOFT_RESET;
   1564                          if (CS49844SPI_write_buffer((byte*)&value, (sizeof(value)/sizeof(uint8))) == SCP1_BSY_TIMEOUT )
   1565                          {
   1566                              mLoaderState = LOADER_ERROR;
   1567                              break;    
   1568                          }
   1569                          /* DSP APP START */
   1570                          if ( CS49844SPI_read_buffer((byte*)&value,sizeof(value)) == SCP1_IRQ_TIMEOUT )
   1571                          {
   1572                              mLoaderState = LOADER_ERROR;
   1573                              break; 
   1574                          }
   1575          
   1576                          if ( value != APP_START)
   1577                          {
   1578                              mLoaderState = LOADER_ERROR;
   1579                              break; 
   1580                          }
   1581          
   1582                          //TRACE_DEBUG((0, "DSP APP START  !!"));
   1583                          mLoaderState = LOADER_CONIGURATION;
   1584                      }
   1585                          break;
   1586          
   1587                      case LOADER_CONIGURATION:
   1588                      {
   1589                          if (CS49844SPI_write_buffer((byte*)&PREKICKSTART_CFG, (sizeof(PREKICKSTART_CFG)/sizeof(uint8))) == SCP1_BSY_TIMEOUT )
   1590                          {
   1591                              mLoaderState = LOADER_ERROR;
   1592                              break;    
   1593                          }
   1594          
   1595                          //TRACE_DEBUG((0, "PRE KICK START !"));
   1596          
   1597                          if(QueueType.audio_type == CS49844_LOAD_AC3)
   1598                          {
   1599                              if (CS49844SPI_write_buffer((byte*)&AC3_INITIAL_CFG, (sizeof(AC3_INITIAL_CFG)/sizeof(uint8)) ) == SCP1_BSY_TIMEOUT )
   1600                              {
   1601                                  mLoaderState = LOADER_ERROR;
   1602                                  break; 
   1603                              }
   1604                          }
   1605                          else if( QueueType.audio_type == CS49844_LOAD_DTS )
   1606                          {
   1607                              if (CS49844SPI_write_buffer((byte*)&DTS_INITIAL_CFG, (sizeof(DTS_INITIAL_CFG)/sizeof(uint8)) ) == SCP1_BSY_TIMEOUT )
   1608                              {
   1609                                  mLoaderState = LOADER_ERROR;
   1610                                  break; 
   1611                              }
   1612                          }
   1613                          else
   1614                          {
   1615                              if (CS49844SPI_write_buffer((byte*)&PCM_INITIAL, (sizeof(PCM_INITIAL)/sizeof(uint8)) ) == SCP1_BSY_TIMEOUT )
   1616                              {
   1617                                  mLoaderState = LOADER_ERROR;
   1618                                  break; 
   1619                              }
   1620                          }
   1621                          mLoaderState = LOADER_KICK_START;
   1622          
   1623                      }
   1624                      break;
   1625          
   1626                      case LOADER_KICK_START:
   1627                      {
   1628                          if (CS49844SPI_write_buffer((byte*)&KICKSTART_CFG, (sizeof(KICKSTART_CFG)/sizeof(uint8)) ) == SCP1_BSY_TIMEOUT )
   1629                          {
   1630                              mLoaderState = LOADER_ERROR;
   1631                              break;
   1632                          }
   1633                          //TRACE_DEBUG((0, "DSP KICK_START !! "));
   1634          
   1635          #if ( configAPP_INTERNAL_DSP_ULD == 0 )            
   1636                          if(ULDLoaderbuf != NULL)
   1637                          {
   1638                              vPortFree(ULDLoaderbuf);
   1639                                          ULDLoaderbuf = NULL;
   1640                              //TRACE_DEBUG((0, "Free ULD Loader Buffer memory space !!"));
   1641                          }
   1642          #endif                 
   1643          
   1644                          gCurDSP_ULD_type = QueueType.audio_type; /*update ULD type*/
   1645                          mLoaderState = LOADER_CONFIG_USER_SETTING;               
   1646                      }
   1647                          break;
   1648          
   1649                      case LOADER_CONFIG_USER_SETTING:
   1650                      {
   1651                          mLoaderState = LOADER_IDLE;                           
   1652                          if( cs49844_RowDataLoader_GetQueueNumber( ) == 0 ) 
   1653                          {
   1654                              //TRACE_ERROR((0, "Q size ----->>>>>> 00000 !! "));
   1655                              cs49844_spi_mutex_give( );
   1656                              pAudLowLevel_ObjCtrl->AudParmsConf( NULL );
   1657                              tmp_QueueType.audio_type = QueueType.audio_type;
   1658                              tmp_QueueType.source_ctrl = QueueType.source_ctrl;
   1659                              
   1660                              pAudLowLevel_ObjCtrl->BackCtrlSender(&tmp_QueueType);
   1661                              if (QueueType.source_ctrl == CS49844_SOURCE_DSP)
   1662                              {
   1663                                  cs49844_irq_mutex_give( );
   1664                              }
   1665                          }
   1666                      }
   1667                          break;
   1668          
   1669                      case LOADER_ERROR:
   1670                      {
   1671                          TRACE_ERROR((0, "DSP is not working, Reset DSP !! "));
   1672          
   1673          #if ( configAPP_INTERNAL_DSP_ULD == 0 )            
   1674                          if( ULDLoaderbuf != NULL )
   1675                          {
   1676                              vPortFree( ULDLoaderbuf );
   1677                              ULDLoaderbuf = NULL;
   1678                          }
   1679          #endif                 
   1680                          mLoaderState = LOADER_HANDLE_Q;
   1681          
   1682                          cs49844_spi_mutex_give( );
   1683                          if (QueueType.source_ctrl == CS49844_SOURCE_DSP)
   1684                          {
   1685                              cs49844_irq_mutex_give( );
   1686                          }
   1687          
   1688                          tmp_QueueType.source_ctrl = CS49844_SOURCE_ERROR;
   1689                          pAudLowLevel_ObjCtrl->BackCtrlSender(&tmp_QueueType);
   1690                      }
   1691                          break;
   1692                  }
   1693                  vTaskDelay(LOADER_TIME_TICK);
   1694              }
   1695          }
   1696          
   1697          static void cs49844_FchDetector_TaskCtrl( xOS_TaskCtrl val )
   1698          {
   1699              if ( val == xOS_setTASK_SUSPENDED )
   1700              {
   1701                  if ( xTaskIsTaskSuspended( xOS_CS49844.fmtTaskHandle ) != pdPASS ) /*task is working*/
   1702                  {
   1703                      vTaskSuspend( xOS_CS49844.fmtTaskHandle );
   1704                      //TRACE_DEBUG((0, "SUSPEND: cs49844_FchDetector"));
   1705                  }
   1706              }
   1707              else if( val == xOS_setTASK_RESUME) 
   1708              {
   1709                  if ( xTaskIsTaskSuspended( xOS_CS49844.fmtTaskHandle ) == pdPASS ) /*task is not working*/
   1710                  {
   1711                      vTaskResume( xOS_CS49844.fmtTaskHandle );
   1712                      //TRACE_DEBUG((0, "RESUME: cs49844_FchDetector"));
   1713                  }
   1714              }
   1715          
   1716          }
   1717          
   1718          static void cs49844_FchDetector_CreateTask( void )
   1719          {
   1720              if ( xTaskCreate( 
   1721                      cs49844_FchDetector, 
   1722                      ( portCHAR * ) "CS49844_FCH", 
   1723                      (STACK_SIZE), 
   1724                      NULL, 
   1725                      tskCS49844_FCH_HANDLER_PRIORITY, 
   1726                      &xOS_CS49844.fmtTaskHandle ) != pdPASS )
   1727              {
   1728                  vTaskDelete( xOS_CS49844.fmtTaskHandle );
   1729                  xOS_CS49844.xOS_ErrId = xOS_TASK_CREATE_FAIL;
   1730              }
   1731              else
   1732              {
   1733                  vTaskSuspend( xOS_CS49844.fmtTaskHandle );
   1734              }
   1735          }
   1736          
   1737          static void cs49844_RowDataLoader_TaskCtrl( xOS_TaskCtrl val )
   1738          {
   1739              xQueueReset( xOS_CS49844.loaderQueue.xQueue );
   1740              
   1741              mLoaderState = LOADER_IDLE;
   1742              gCurDSP_ULD_type = CS49844_LOAD_NULL;
   1743              mAdtectMsg.non_iec61937 = 0;
   1744              mAdtectMsg.stream_descriptor = 0 ;
   1745              
   1746              if ( val == xOS_setTASK_SUSPENDED )
   1747              {
   1748                  if ( xTaskIsTaskSuspended( xOS_CS49844.loaderTaskHandle ) != pdPASS ) /*task is working*/
   1749                  {
   1750                      vTaskSuspend( xOS_CS49844.loaderTaskHandle );
   1751                      TRACE_DEBUG((0, "SUSPEND: cs49844_RowDataLoader"));
   1752                  }
   1753              }
   1754              else if ( val == xOS_setTASK_RESUME )
   1755              {
   1756                  if ( xTaskIsTaskSuspended( xOS_CS49844.loaderTaskHandle ) == pdPASS ) /*task is not working*/
   1757                  {
   1758                      vTaskResume( xOS_CS49844.loaderTaskHandle );
   1759                      TRACE_DEBUG((0, "RESUME cs49844_RowDataLoader"));
   1760                  }
   1761              }
   1762          }
   1763          
   1764          static void cs49844_RowDataLoader_CreateTask( void )
   1765          {
   1766              
   1767              if ( xTaskCreate( 
   1768                      cs49844_RowDataLoader_Task, 
   1769                      ( portCHAR * ) "CS49844_LOADER", 
   1770                      (STACK_SIZE), 
   1771                      NULL, 
   1772                      tskCS49844_Loader_PRIORITY, 
   1773                      &xOS_CS49844.loaderTaskHandle ) != pdPASS )
   1774              {
   1775                  vTaskDelete( xOS_CS49844.loaderTaskHandle );
   1776                  xOS_CS49844.xOS_ErrId = xOS_TASK_CREATE_FAIL;
   1777              }
   1778              else
   1779              {
   1780                  vTaskSuspend( xOS_CS49844.loaderTaskHandle );
   1781              }
   1782          
   1783              xOS_CS49844.loaderQueue.xQueue = xQueueCreate( LOADER_QUEUE_LENGTH, FRTOS_SIZE(CS49844_QUEUE_TYPE) );
   1784              xOS_CS49844.loaderQueue.xBlockTime = BLOCK_TIME(0);
   1785              if( xOS_CS49844.loaderQueue.xQueue == NULL )
   1786              {
   1787                 xOS_CS49844.xOS_ErrId = xOS_TASK_QUEUE_CREATE_FAIL;
   1788              }
   1789          
   1790              xOS_CS49844.spi_sema.xSemaphore = xSemaphoreCreateMutex();
   1791              if ( xOS_CS49844.spi_sema.xSemaphore != NULL )
   1792              {
   1793          #if 0
   1794                  if ( cs49844_spi_mutex_take( ) == TRUE )
   1795                  {
   1796                      xOS_CS49844.xOS_ErrId = xOS_TASK_ERR_NULL;
   1797                  }
   1798          #endif        
   1799              }
   1800             
   1801              xOS_CS49844.spi_sema.xBlockTime = 0x0;
   1802              
   1803              if ( _IRQ_SEMA == NULL )
   1804              {
   1805                  _IRQ_SEMA = xSemaphoreCreateMutex();
   1806              }   
   1807          }   
   1808          
   1809          #if ( configAPP_SPI_FLASH_DSP_ULD == 1 )
   1810          /********* For Load DSP ULD from External Flash *********/
   1811          static unsigned int cs49844_Get_DSP_ULD_StartLocation(CS49844LoadAudioStreamType Stype ,cs49844_ULD_Type Utype)
   1812          {
   1813              unsigned int sLocation = 0;
   1814              
   1815              if(Stype == CS49844_LOAD_PCM)
   1816              {
   1817                  sLocation = PCM_ULD_LOCATION[Utype][0];
   1818              }
   1819              else if(Stype == CS49844_LOAD_AC3)
   1820              {
   1821                  sLocation = AC3_ULD_LOCATION[Utype][0];
   1822              }
   1823              else if(Stype == CS49844_LOAD_DTS)
   1824              {
   1825                  sLocation = DTS_ULD_LOCATION[Utype][0];
   1826              }
   1827              return sLocation;
   1828          }
   1829          #endif 
   1830          
   1831          #if ( configAPP_SPI_FLASH_DSP_ULD == 1 )
   1832          static unsigned int cs49844_Get_DSP_ULD_Length(CS49844LoadAudioStreamType Stype ,cs49844_ULD_Type Utype)
   1833          {
   1834              unsigned int sLocation = 0;
   1835              
   1836              if(Stype == CS49844_LOAD_PCM)
   1837              {
   1838                  sLocation = PCM_ULD_LOCATION[Utype][1];
   1839              }
   1840              else if(Stype == CS49844_LOAD_AC3)
   1841              {
   1842                  sLocation = AC3_ULD_LOCATION[Utype][1];
   1843              }
   1844              else if(Stype == CS49844_LOAD_DTS)
   1845              {
   1846                  sLocation = DTS_ULD_LOCATION[Utype][1];
   1847              }
   1848              return sLocation;
   1849          }
   1850          #endif 
   1851          
   1852          #if ( configAPP_SPI_FLASH_DSP_ULD == 1 )
   1853          static int cs49844_LoadDSP_ULD(unsigned char* buf,CS49844LoadAudioStreamType Stype ,cs49844_ULD_Type Utype )
   1854          {
   1855              int i;
   1856              int8 dsp_spi_ret;
   1857              unsigned int sLocation,ULDLength;  
   1858              unsigned int NumOfDSPLoad,NumOfSingle,Addr;
   1859              int8 ret_val = 1;
   1860          
   1861              sLocation = cs49844_Get_DSP_ULD_StartLocation(Stype,Utype);
   1862              ULDLength = cs49844_Get_DSP_ULD_Length(Stype,Utype);
   1863          
   1864              Addr = sLocation;
   1865              NumOfDSPLoad = ULDLength/DSPLoadSize;
   1866              NumOfSingle = ULDLength%DSPLoadSize;
   1867          
   1868              if( NumOfDSPLoad == 0 )
   1869              {
   1870                  sFLASH_ReadBuffer(ULDLoaderbuf, Addr, NumOfSingle);
   1871                  vTaskDelay(TASK_MSEC2TICKS(1));
   1872          
   1873                  dsp_spi_ret = CS49844SPI_write_ULD_buffer(ULDLoaderbuf, NumOfSingle);
   1874                  if( dsp_spi_ret != SCP1_PASS )
   1875                  {
   1876                      TRACE_DEBUG((0, "Step 1. Write DSP ULD have ERROR !!!\n"));
   1877                      ret_val = 0;
   1878                  }
   1879              }
   1880              else
   1881              {
   1882                  for( i=0; i < NumOfDSPLoad; i++)
   1883                  {
   1884                      sFLASH_ReadBuffer(ULDLoaderbuf, Addr, DSPLoadSize);
   1885                      vTaskDelay(TASK_MSEC2TICKS(1));
   1886          
   1887                      dsp_spi_ret = CS49844SPI_write_ULD_buffer(ULDLoaderbuf, DSPLoadSize);
   1888                      if ( dsp_spi_ret != SCP1_PASS )
   1889                      {
   1890                          TRACE_DEBUG((0, "Step 2. Write DSP ULD have ERROR !!!\n"));
   1891                          ret_val = 0;
   1892                          break;
   1893                      }
   1894          
   1895                       Addr += DSPLoadSize;
   1896                  }
   1897          
   1898                  if (ret_val != 0)
   1899                  {
   1900                      sFLASH_ReadBuffer(ULDLoaderbuf, Addr, NumOfSingle);
   1901                      vTaskDelay(TASK_MSEC2TICKS(1));
   1902          
   1903                      dsp_spi_ret = CS49844SPI_write_ULD_buffer(ULDLoaderbuf, NumOfSingle);
   1904                      if ( dsp_spi_ret != SCP1_PASS )
   1905                      {
   1906                          TRACE_DEBUG((0, "Step 3. Write DSP ULD have ERROR !!!\n"));
   1907                          ret_val = 0;
   1908                      }
   1909                  }
   1910              }
   1911              
   1912          
   1913              if (ret_val != 0)
   1914              {
   1915                  if(Stype == CS49844_LOAD_PCM)
   1916                  {
   1917                      if(Utype == GAIN_ULD)
   1918                          TRACE_DEBUG((0, "Load DSP  \"PCM \"  Finished !!!\n"));
   1919                      //else if(Utype == OS_ULD)
   1920                          //TRACE_DEBUG((0, "Load DSP  \"PCM OS_ULD\"  Finished !!!\n"));
   1921                      //else if(Utype == CROSSBAR_ULD)
   1922                          //TRACE_DEBUG((0, "Load DSP  \"PCM CROSSBAR_ULD\"  Finished !!!\n"));
   1923                  }
   1924                  else if(Stype == CS49844_LOAD_AC3)
   1925                  {
   1926                      if(Utype == GAIN_ULD)
   1927                          TRACE_DEBUG((0, "Load DSP  \"AC3 \"  Finished !!!\n"));
   1928                      //else if(Utype == OS_ULD)
   1929                          //TRACE_DEBUG((0, "Load DSP  \"AC3 OS_ULD\"  Finished !!!\n"));
   1930                      //else if(Utype == CROSSBAR_ULD)
   1931                          //TRACE_DEBUG((0, "Load DSP  \"AC3 CROSSBAR_ULD\"  Finished !!!\n"));
   1932                      //else if(Utype == DECODER_ULD)   
   1933                          //TRACE_DEBUG((0, "Load DSP  \"AC3 DECODER_ULD\"  Finished !!!\n"));
   1934                  }
   1935                  else if(Stype == CS49844_LOAD_DTS)
   1936                  {
   1937                      if(Utype == GAIN_ULD)
   1938                          TRACE_DEBUG((0, "Load DSP  \"DTS \"  Finished !!!\n"));
   1939                      //else if(Utype == OS_ULD)
   1940                          //TRACE_DEBUG((0, "Load DSP  \"DTS OS_ULD\"  Finished !!!\n"));
   1941                      //else if(Utype == CROSSBAR_ULD)
   1942                          //TRACE_DEBUG((0, "Load DSP  \"DTS CROSSBAR_ULD\"  Finished !!!\n"));
   1943                      //else if(Utype == DECODER_ULD)   
   1944                          //TRACE_DEBUG((0, "Load DSP  \"DTS DECODER_ULD\"  Finished !!!\n"));
   1945                  }
   1946              }
   1947              
   1948              return ret_val;
   1949          }
   1950          #endif 
   1951          
   1952          #if (configAPP_INTERNAL_DSP_ULD == 1 )
   1953          static int8 cs49844_Load_DSP_AC3_ULD_InternalFlash( cs49844_ULD_Type module )
   1954          {
   1955              int8 ret = 0;
   1956          
   1957              switch( module )
   1958              {
   1959                  case GAIN_ULD:
   1960                  {
   1961                      if ( cs49844_spi_mutex_take() == TRUE )
   1962                      {
   1963                          if( CS49844SPI_write_buffer((byte*)&AC3_IN_GAIN_ULD, (sizeof(DTS_IN_GAIN_ULD)/sizeof(uint8))) == SCP1_BSY_TIMEOUT )
   1964                          {
   1965                              ret = -1;
   1966                          }
   1967                  
   1968                          cs49844_spi_mutex_give();
   1969                      }
   1970                  }
   1971                      break;
   1972          
   1973                  case OS_ULD:
   1974                  {
   1975                      if ( cs49844_spi_mutex_take() == TRUE )
   1976                      {
   1977                          if (CS49844SPI_write_buffer((byte*)&OS_HD2_RC94_ULD, (sizeof(OS_HD2_RC94_ULD)/sizeof(uint8)) ) == SCP1_BSY_TIMEOUT )
   1978                          {
   1979                              ret = -1;                   
   1980                          }
   1981          
   1982                          cs49844_spi_mutex_give();
   1983                      }
   1984                  }
   1985                      break;
   1986          
   1987                  case CROSSBAR_ULD:
   1988                  {
   1989                      if ( cs49844_spi_mutex_take() == TRUE )
   1990                      {
   1991                          if (CS49844SPI_write_buffer((byte*)&AC3_RC23_ULD, (sizeof(AC3_RC23_ULD)/sizeof(uint8))) == SCP1_BSY_TIMEOUT )
   1992                          {
   1993                              ret = -1;
   1994                          }
   1995          
   1996                          cs49844_spi_mutex_give();
   1997                      }
   1998                  }
   1999                      break;
   2000          
   2001              }
   2002          
   2003               return ret;
   2004          }
   2005          #endif 
   2006          
   2007          #if (configAPP_INTERNAL_DSP_ULD == 1 )
   2008          static int8 cs49844_Load_DSP_DTS_ULD_InternalFlash( cs49844_ULD_Type module )
   2009          {
   2010              int8 ret = 0;
   2011          
   2012              switch( module )
   2013              {
   2014                  case GAIN_ULD:
   2015                  {
   2016                      if ( cs49844_spi_mutex_take() == TRUE )
   2017                      {
   2018                          if( CS49844SPI_write_buffer((byte*)&DTS_IN_GAIN_ULD, (sizeof(DTS_IN_GAIN_ULD)/sizeof(uint8))) == SCP1_BSY_TIMEOUT )
   2019                          {
   2020                              ret = -1;
   2021                          }
   2022                  
   2023                          cs49844_spi_mutex_give();
   2024                      }
   2025                  }
   2026                      break;
   2027          
   2028                  case OS_ULD:
   2029                  {
   2030                      if ( cs49844_spi_mutex_take() == TRUE )
   2031                      {
   2032                          if (CS49844SPI_write_buffer((byte*)&OS_HD2_RC94_ULD, (sizeof(OS_HD2_RC94_ULD)/sizeof(uint8)) ) == SCP1_BSY_TIMEOUT )
   2033                          {
   2034                              ret = -1;                   
   2035                          }
   2036          
   2037                          cs49844_spi_mutex_give();
   2038                      }
   2039                  }
   2040                      break;
   2041          
   2042                  case CROSSBAR_ULD:
   2043                  {
   2044                      if ( cs49844_spi_mutex_take() == TRUE )
   2045                      {
   2046                          if (CS49844SPI_write_buffer((byte*)&DTS_RC25_ULD, (sizeof(DTS_RC25_ULD)/sizeof(uint8))) == SCP1_BSY_TIMEOUT )
   2047                          {
   2048                              ret = -1;
   2049                          }
   2050          
   2051                          cs49844_spi_mutex_give();
   2052                      }
   2053                  }
   2054                      break;
   2055              }
   2056          
   2057              return ret;
   2058          
   2059          }
   2060          #endif 
   2061          
   2062          #if (configAPP_INTERNAL_DSP_ULD == 1 )
   2063          static int8 cs49844_Load_DSP_PCM_ULD_InternalFlash( cs49844_ULD_Type module )
   2064          {
   2065              int8 ret = 0; 
   2066          
   2067              switch( module )
   2068              {
   2069                  case GAIN_ULD:
   2070                  {
   2071                      if ( cs49844_spi_mutex_take() == TRUE )
   2072                      {
   2073                          if( CS49844SPI_write_buffer((byte*)&PCM_IN_GAIN_ULD, (sizeof(PCM_IN_GAIN_ULD)/sizeof(uint8))) == SCP1_BSY_TIMEOUT )
   2074                          {
   2075                              ret = -1;
   2076                          }
   2077                  
   2078                          cs49844_spi_mutex_give();
   2079                      }
   2080                  }
   2081                      break;
   2082          
   2083                  case OS_ULD:
   2084                  {
   2085                      if ( cs49844_spi_mutex_take() == TRUE )
   2086                      {
   2087                          if (CS49844SPI_write_buffer((byte*)&OS_HD2_RC94_ULD, (sizeof(OS_HD2_RC94_ULD)/sizeof(uint8)) ) == SCP1_BSY_TIMEOUT )
   2088                          {
   2089                              ret = -1;                   
   2090                          }
   2091          
   2092                          cs49844_spi_mutex_give();
   2093                      }
   2094                  }
   2095                      break;
   2096          
   2097                  case CROSSBAR_ULD:
   2098                  {
   2099                      if ( cs49844_spi_mutex_take() == TRUE )
   2100                      {
   2101                          if (CS49844SPI_write_buffer((byte*)&PCM_TVCSII_ULD, (sizeof(PCM_TVCSII_ULD)/sizeof(uint8))) == SCP1_BSY_TIMEOUT )
   2102                          {
   2103                              ret = -1;
   2104                          }
   2105          
   2106                          cs49844_spi_mutex_give();
   2107                      }
   2108                  }
   2109                      break;
   2110          
   2111              }
   2112          
   2113              return ret;
   2114          }
   2115          #endif 
   2116          
   2117          #if (configAPP_INTERNAL_DSP_ULD == 1 )
   2118          static int8 cs49844_Load_DSP_ULD_InternalFlash( CS49844LoadAudioStreamType type, cs49844_ULD_Type module )
   2119          {
   2120              int8 ret = 0;
   2121          
   2122              switch( type )
   2123              {
   2124                  case CS49844_LOAD_PCM:
   2125                  {
   2126                      ret = cs49844_Load_DSP_PCM_ULD_InternalFlash( module );
   2127                  }
   2128                      break;
   2129          
   2130                  case CS49844_LOAD_AC3:
   2131                  {
   2132                       ret = cs49844_Load_DSP_AC3_ULD_InternalFlash( module );
   2133                  }
   2134                      break;
   2135          
   2136                  case CS49844_LOAD_DTS:
   2137                  {
   2138                       ret = cs49844_Load_DSP_DTS_ULD_InternalFlash( module );
   2139                  }
   2140                      break;
   2141              }
   2142          
   2143              return ret;
   2144          }
   2145          #endif 
   2146          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  cs49844_FchDetector
              8 -> vTaskDelay
       24  cs49844_FchDetector_CreateTask
             24 -> vTaskDelete
              0 -> vTaskSuspend
             24 -> xTaskGenericCreate
        8  cs49844_FchDetector_TaskCtrl
              0 -> vTaskResume
              0 -> vTaskSuspend
              8 -> xTaskIsTaskSuspended
        0  cs49844_GetAudioStreamType
        0  cs49844_GetLoadrState
       32  cs49844_LoadDSP_ULD
             32 -> CS49844SPI_write_ULD_buffer
             32 -> Debug_printDebug
             32 -> sFLASH_ReadBuffer
             32 -> vTaskDelay
       24  cs49844_LowLevelDetector_CreateTask
              0 -> vTaskDelete
              0 -> vTaskSuspend
             24 -> xTaskGenericCreate
        8  cs49844_LowLevelDetector_TaskCtrl
              8 -> cs49844_lowlevel_task_setState
              0 -> vTaskResume
              0 -> vTaskSuspend
              8 -> xTaskIsTaskSuspended
       24  cs49844_RowDataLoader_CreateTask
             24 -> vTaskDelete
             24 -> vTaskSuspend
             24 -> xQueueCreateMutex
             24 -> xQueueGenericCreate
             24 -> xTaskGenericCreate
        8  cs49844_RowDataLoader_GetQueueNumber
              8 -> uxQueueMessagesWaiting
       16  cs49844_RowDataLoader_InstrSender
             16 -> SPILowLevel_isEnable
             16 -> xQueueGenericReset
             16 -> xQueueGenericSend
       56  cs49844_RowDataLoader_Task
             56 -- Indirect call
             56 -> CS49844SPI_CommandWrite
             56 -> CS49844SPI_MsgNote1
             56 -> CS49844SPI_ReadSolicited
             56 -> CS49844SPI_read_buffer
             56 -> CS49844SPI_write_buffer
             56 -> Debug_printDebug
             56 -> Debug_printError
             56 -> GPIOMiddleLevel_Clr
             56 -> GPIOMiddleLevel_Read_InBit
             56 -> GPIOMiddleLevel_Set
             56 -> cs49844_LoadDSP_ULD
             56 -> cs49844_RowDataLoader_GetQueueNumber
             56 -> cs49844_getAutoDectMsg
             56 -> cs49844_irq_mutex_give
             56 -> cs49844_parseAudioFMT
             56 -> cs49844_spi_mutex_give
             56 -> pvPortMalloc
             56 -> vPortFree
             56 -> vTaskDelay
             56 -> xPortGetFreeHeapSize
             56 -> xQueueGenericReceive
             56 -> xTaskGetTickCount
       16  cs49844_RowDataLoader_TaskCtrl
              0 -> Debug_printDebug
             16 -> vTaskResume
             16 -> vTaskSuspend
             16 -> xQueueGenericReset
             16 -> xTaskIsTaskSuspended
        8  cs49844_SetTVHDMC_Ctrl
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        4  cs49844_getAutoDectMsg
        0  cs49844_getSignalLevel
        8  cs49844_irq_mutex_give
              8 -> xQueueGenericSend
        8  cs49844_lowlevel_task
              8 -> vTaskDelay
        0  cs49844_lowlevel_task_setState
        8  cs49844_parseAudioFMT
              0 -> Debug_printDebug
        8  cs49844_setAVDelay
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_setAudioRoute
              8 -> CS49844SPI_write_buffer
              0 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_setBalanceLs
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_setBalanceRs
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_setBassGain
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_setCenterGain
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_setLsRsGain
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_setMasterGain
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_setMute
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_setNightMode
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_setSilenceThreshold
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_setSubGain
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_setTrebleGain
              8 -> cs49844_spi_mutex_give
              8 -> cs49844_spi_mutex_take
        8  cs49844_spi_mutex_give
              8 -> SPILowLevel_isEnable
              8 -> xQueueGenericSend
        8  cs49844_spi_mutex_take
              8 -> SPILowLevel_isEnable
              8 -> xQueueGenericReceive


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "CS49844_FCH">
      16  ?<Constant "CS49844_LOADER">
      20  ?<Constant "CS49844_lowlevel">
      28  ?<Constant "CrossBar ULD LOADER_E...">
      36  ?<Constant "DSP is not working, R...">
      32  ?<Constant "It isn\'t enough memor...">
      32  ?<Constant "Load DSP  \"AC3 \"  Fin...">
      32  ?<Constant "Load DSP  \"DTS \"  Fin...">
      32  ?<Constant "Load DSP  \"PCM \"  Fin...">
      32  ?<Constant "RESUME cs49844_RowDat...">
      32  ?<Constant "SUSPEND: cs49844_RowD...">
      40  ?<Constant "Step 1. Write DSP ULD...">
      40  ?<Constant "Step 2. Write DSP ULD...">
      40  ?<Constant "Step 3. Write DSP ULD...">
      36  ?<Constant "cs49844_LoadDSP_ULD L...">
      52  ?<Constant "tmp_queue_data->audio...">
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_10
       4  ??DataTable37_11
       4  ??DataTable37_12
       4  ??DataTable37_13
       4  ??DataTable37_14
       4  ??DataTable37_15
       4  ??DataTable37_16
       4  ??DataTable37_2
       4  ??DataTable37_3
       4  ??DataTable37_4
       4  ??DataTable37_5
       4  ??DataTable37_6
       4  ??DataTable37_7
       4  ??DataTable37_8
       4  ??DataTable37_9
       4  ??DataTable41
       4  ??DataTable41_1
       4  ??DataTable41_2
       4  ??DataTable41_3
       8  ?Subroutine0
      10  ?Subroutine1
       8  ?Subroutine10
      22  ?Subroutine2
      10  ?Subroutine3
       6  ?Subroutine4
      10  ?Subroutine5
      12  ?Subroutine6
       8  ?Subroutine7
      10  ?Subroutine8
      10  ?Subroutine9
    5248  AC3_INITIAL_CFG
      64  DSP_DAO_ROUTER_INITIAL
     108  DSP_ObjCtrl
    5064  DTS_INITIAL_CFG
      32  KICKSTART_CFG
    4112  PCM_INITIAL
     528  PREKICKSTART_CFG
      22  cs49844_FchDetector
      50  cs49844_FchDetector_CreateTask
      42  cs49844_FchDetector_TaskCtrl
       8  cs49844_GetAudioStreamType
       8  cs49844_GetLoadrState
     210  cs49844_LoadDSP_ULD
      62  cs49844_LowLevelDetector_CreateTask
      66  cs49844_LowLevelDetector_TaskCtrl
     102  cs49844_RowDataLoader_CreateTask
      16  cs49844_RowDataLoader_GetQueueNumber
      62  cs49844_RowDataLoader_InstrSender
    1050  cs49844_RowDataLoader_Task
      84  cs49844_RowDataLoader_TaskCtrl
      30  cs49844_SetTVHDMC_Ctrl
      28  cs49844_getAutoDectMsg
       8  cs49844_getSignalLevel
      24  cs49844_irq_mutex_give
      12  cs49844_lowlevel_task
      32  cs49844_lowlevel_task_setState
      72  cs49844_parseAudioFMT
      20  cs49844_setAVDelay
      32  cs49844_setAudioRoute
      20  cs49844_setBalanceLs
      20  cs49844_setBalanceRs
      20  cs49844_setBassGain
      20  cs49844_setCenterGain
      20  cs49844_setLsRsGain
      28  cs49844_setMasterGain
      20  cs49844_setMute
      20  cs49844_setNightMode
      20  cs49844_setSilenceThreshold
      20  cs49844_setSubGain
      20  cs49844_setTrebleGain
      30  cs49844_spi_mutex_give
      40  cs49844_spi_mutex_take
     120  mAdtectMsg
          QueueType
          mLoaderState
          gCurDSP_ULD_type
          PCM_ULD_LOCATION
          AC3_ULD_LOCATION
          DTS_ULD_LOCATION
          ULDLoaderbuf
       4  pDSP_ObjCtrl
       1  signal_overthreshold
      44  xOS_CS49844
          _IRQ_SEMA

 
     44 bytes in section .bss
    125 bytes in section .data
 10 232 bytes in section .rodata
  7 972 bytes in section .text
 
  7 972 bytes of CODE  memory
 10 232 bytes of CONST memory
    169 bytes of DATA  memory

Errors: none
Warnings: 10

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:24:19 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Utilities\mainstream_v1\stm32f411\BTHandler.c         #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Utilities\mainstream_v1\stm32f411\BTHandler.c -D      #
#                    S4051A -D DEBUG -D FREE_RTOS -D STM32F40_41xxx -D        #
#                    USE_STM324xG_EVAL -D USE_STDPERIPH_DRIVER -D             #
#                    __ARM_CORTEX_MX__ -D IAR_ARM_CM4F -D USE_USB_OTG_FS      #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applicati #
#                    on\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Ap #
#                    plication\Obj\ --debug --endian=little --cpu=Cortex-M4   #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\BTHandler.lst                                         #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\BTHandler.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Utilities\mainstream_v1\stm32f411\BTHandler.c
      1          #include "Defs.h"
      2          #include "Debug.h"
      3          #include "freertos_conf.h"
      4          #include "freertos_task.h"
      5          #include "freertos_typedef.h"
      6          
      7          #include "GPIOMiddleLevel.h"
      8          #include "GPIOLowLevel.h"
      9          
     10          #include "api_typedef.h"
     11          #include "BTHandler.h"
     12          #include "PowerHandler.h"
     13          #include "UIDeviceManager.h"
     14          #include "HMI_Service.h"
     15          
     16          
     17          #define BT_QUEUE_LENGTH 3
     18          #define BT_AVRCP_CTRL_TIME  TASK_MSEC2TICKS(80)
     19          
     20          #define BT_AUTO_PAIRING_TIME TASK_MSEC2TICKS(50000) //50 SEC
     21          #define BT_ENERGY_SAVING_TIME TASK_MSEC2TICKS(900000) //15 MIN
     22          
     23          #define BT_CLEAN_DEVICE_TIME TASK_MSEC2TICKS(28000) //28 SEC
     24          
     25          #define BT_START_UP_TIMER 10
     26          
     27          #define BT_POWER_TOOGLE_TIME 85
     28          
     29          //____________________________________________________________________________________________________________
     30          /* extern variable */
     31          extern POWER_HANDLE_OBJECT *pPowerHandle_ObjCtrl;
     32          extern UI_DEV_MANAGER_OBJECT *pUDM_ObjCtrl;
     33          extern HMI_SERVICE_OBJECT *pHS_ObjCtrl; /*HMI service*/
     34          
     35          //____________________________________________________________________________________________________________
     36          //static api header
     37          static void BTHandler_Init(void);
     38          static void BTHandler_CreateTask(void);
     39          static bool BTHandler_InstrSender(void * cmds);
     40          static uint8 BTHandler_GetQueueNumber( void );
     41          static void BTHandler_ServiceHandle( void );
     42          static void BTHandler_PowerCtl(void);
     43          //static xBTHandleModuleStatus BTHandler_GetBTStatus(void);
     44          static void BTHandler_GetBTStatus( xBTHandleModuleStatus *update_status );
     45          
     46          static xBTHandleModuleStatus BTHanlder_reportBTStatus( void );
     47          
     48          static bool BTHandler_ToogleBTPower(bool OnOff);
     49          
     50          #if 0
     51          static void BTHandler_handleCommand(void *cmds);
     52          #endif
     53          static void BTHandler_handleCommand( void *params  );
     54          
     55          static void BTHandler_Service( void *pvParameters );
     56          
     57          static bool BT_GPIO_sema_mutex_take( void );
     58          
     59          static bool BT_GPIO_sema_mutex_give( void );
     60          
     61          static void BT_GPIO_BT_PAIRING_CTTL(void);
     62          
     63          static void BT_GPIO_BT_PLAY_CTTL(void);
     64          
     65          static void BT_GPIO_BT_PLAY_NEXT(void);
     66          
     67          static void BT_GPIO_BT_PLAY_PRE(void);
     68          
     69          static void BT_GPIO_BT_CLEAN_DEVICE(void);
     70          
     71          static void BTHandler_TaskCtrl( bool val );
     72          
     73          //____________________________________________________________________________________________________________
     74          const BT_HANDLE_OBJECT   BTHandle =
     75          {
     76              BTHandler_CreateTask,
     77              BTHandler_handleCommand,
     78              BTHandler_InstrSender,
     79              BTHandler_PowerCtl,
     80              BTHanlder_reportBTStatus
     81          };
     82          const BT_HANDLE_OBJECT *pBTHandle_ObjCtrl = &BTHandle;
     83          
     84          typedef struct BT_HANDLE_PARAMETERS
     85          {
     86              xTaskHandle TaskHandle;
     87              uint8 power_handle;
     88              TaskHandleState taskState;
     89              xSemaphoreParameters SParams;
     90              xQueueParameters QParams;
     91          } xBTHandleParams;
     92          
     93          //____________________________________________________________________________________________________________
     94          /*static variable*/
     95          /*static xBTHandleParams mBTHandleParams;
     96          static xBTHandleState BTHandlerState = BT_MS_IDLE;
     97          static uint16 mBTHandlerStamp = 0;
     98          static xBTHandleCommand mBTHandleComd;
     99          static bool NeedPairing = FALSE;
    100          static xBTHandleModuleStatus BTStatus = BT_STATUS_ERROR;
    101          static xBTHandleModuleStatus LastBTStatus = BT_STATUS_ERROR;
    102          static uint8 CleanDeviceCmdSource = 3;
    103          static uint16 mBTHandlerPowerOnStamp = 0;
    104          */
    105          xBTHandleParams mBTHandleParams;
    106          xBTHandleState BTHandlerState = BT_MS_IDLE;
    107          uint16 mBTHandlerStamp = 0;
    108          xBTHandleCommand mBTHandleComd;
    109          bool NeedPairing = FALSE;
    110          xBTHandleModuleStatus BTStatus = BT_STATUS_ERROR;
    111          xBTHandleModuleStatus LastBTStatus = BT_STATUS_ERROR;
    112          uint8 CleanDeviceCmdSource = 3;
    113          uint16 mBTHandlerPowerOnStamp = 0;
    114          
    115          static bool Is_Start_Counter = FALSE;
    116          static portTickType duration_time = 0;
    117          static portTickType start_time = 0;
    118          xBTTimeStatus BT_time_status = BT_TIME_INIT;
    119          
    120          static int retry_timer = 0;
    121          //for mutex mechanism when read/write gpio
    122          xSemaphoreParameters BT_GPIO_sema;
    123          
    124          
    125          /*******************************************************************************
    126           * Mutex
    127           ******************************************************************************/
    128          static bool BT_GPIO_sema_mutex_noWait_take( void )
    129          {
    130          #if 1
    131              if ( BT_GPIO_sema.xSemaphore == NULL )
    132              {
    133                  return FALSE;
    134              }
    135          
    136              //BT_GPIO_sema.xBlockTime = portMAX_DELAY;
    137              if ( xSemaphoreTake( BT_GPIO_sema.xSemaphore, 0 ) != pdTRUE )
    138              {
    139                  return FALSE;
    140              }
    141           #endif   
    142              return TRUE;
    143          }
    144          
    145          static bool BT_GPIO_sema_mutex_take( void )
    146          {
    147              if ( BT_GPIO_sema.xSemaphore == NULL )
    148              {
    149                  return FALSE;
    150              }
    151          
    152              //BT_GPIO_sema.xBlockTime = portMAX_DELAY;
    153              if ( xSemaphoreTake( BT_GPIO_sema.xSemaphore, BT_GPIO_sema.xBlockTime ) != pdTRUE )
    154              {
    155                  return FALSE;
    156              }
    157              
    158              return TRUE;
    159          }
    160          
    161          static bool BT_GPIO_sema_mutex_give( void )
    162          {
    163              if ( BT_GPIO_sema.xSemaphore == NULL )
    164                  return FALSE;
    165          
    166              if ( xSemaphoreGive( BT_GPIO_sema.xSemaphore ) != pdTRUE )
    167              {
    168                  return FALSE;    
    169              }
    170              return TRUE;
    171          }
    172          
    173          
    174          //____________________________________________________________________________________________________________
    175          
    176          static void BTHandler_Init(void)
    177          {
    178              BTHandlerState = BT_MS_IDLE; /* Go to Init state when SB power on */
    179          
    180              GPIOMiddleLevel_Clr(__O_BT_REW);
    181              GPIOMiddleLevel_Clr(__O_BT_FWD);
    182              GPIOMiddleLevel_Clr(__O_BT_REST);
    183              GPIOMiddleLevel_Clr(__O_BT_MFB);
    184          }
    185          
    186          static void BTHandler_CreateTask(void)
    187          {
    188              BTHandler_Init();
    189              
    190              if ( xTaskCreate( 
    191                   BTHandler_Service,
    192                       ( portCHAR * ) "BT_Handle", 
    193                       (STACK_SIZE), 
    194                       NULL, 
    195                       tskBT_HANDLER_PRIORITY, 
    196                       &mBTHandleParams.TaskHandle ) != pdPASS )
    197               {
    198                   TRACE_ERROR((0, "BT_Handle task create failure " ));
    199               }
    200              else
    201               {
    202                  vTaskSuspend( mBTHandleParams.TaskHandle );
    203               }
    204          
    205              mBTHandleParams.QParams.xQueue = xQueueCreate( BT_QUEUE_LENGTH, FRTOS_SIZE(xBTHandleCommand) );
    206              mBTHandleParams.QParams.xBlockTime = BLOCK_TIME(0);
    207          
    208              if(mBTHandleParams.QParams.xQueue == NULL)
    209              {
    210                  TRACE_ERROR((0, "Create BTHandle queue creates failure " ));
    211              }
    212          
    213              xQueueReset(mBTHandleParams.QParams.xQueue);
    214          
    215              mBTHandleParams.power_handle = pPowerHandle_ObjCtrl->register_handle();
    216          
    217              BT_GPIO_sema.xSemaphore = xSemaphoreCreateMutex();
    218              BT_GPIO_sema.xBlockTime = portMAX_DELAY;
    219          
    220              //TRACE_ERROR((0, "BT start up .... " ));
    221              //BTHandler_ToogleBTPower( FALSE );
    222          }
    223          
    224          
    225          static bool BTHandler_InstrSender(void * cmds) 
    226          {
    227          #if 0 // smith removes
    228              xBTHandleCommand* pCmd = ( xBTHandleCommand *)cmds;
    229              
    230              if(mBTHandleParams.QParams.xQueue == NULL)
    231              {
    232                  TRACE_ERROR((0, "BTHandler_InstrSender error !! "));
    233                  return FALSE;
    234              }
    235              else if(xQueueSend(mBTHandleParams.QParams.xQueue,pCmd,mBTHandleParams.QParams.xBlockTime) != pdPASS)
    236              {
    237                  TRACE_ERROR((0, " BTHandler_InstrSender send queue is failure "));
    238                  return FALSE;
    239              }
    240          #endif    
    241              return TRUE;
    242          }
    243          
    244          static bool BTHandler_InstrReceiver( xBTHandleCommand *pCmd ) 
    245          {
    246              if(pCmd == NULL)
    247              {
    248                  TRACE_ERROR((0, " BTHandler_InstrReceiver recevier error !! "));
    249                  return FALSE;
    250              } 
    251              else if(mBTHandleParams.QParams.xQueue == NULL)
    252              {
    253                  TRACE_ERROR((0, "BTHandler_InstrReceiver error !! "));
    254                  return FALSE;
    255              }    
    256              else if(xQueueReceive(mBTHandleParams.QParams.xQueue,pCmd,mBTHandleParams.QParams.xBlockTime) != pdPASS)
    257              {
    258                  TRACE_ERROR((0, " BTHandler_InstrReceiver receiver queue is failure "));
    259                  return FALSE;
    260              }
    261          
    262              return TRUE;   
    263          }
    264          
    265          
    266          static void BTHandler_Service( void *pvParameters )
    267          {
    268              xBTHandleCommand EventParams;
    269          
    270              for ( ;; )
    271              {
    272                  BTHandler_GetBTStatus(&BTStatus);
    273              switch( mBTHandleParams.taskState )
    274              {
    275                  case TASK_SUSPENDED:
    276                  {
    277                  }
    278                  break;
    279          
    280                  case TASK_READY:
    281                  {
    282                      if ( BTHandler_GetQueueNumber() != 0 )
    283                      {
    284                          mBTHandleParams.taskState = TASK_RUNING;
    285                      }
    286                      else
    287                      {
    288                          //if ( BTHandlerState == BT_MS_IDLE )
    289                              BTHandler_ServiceHandle();
    290                      }
    291                  }
    292                  break;
    293          
    294                  case TASK_RUNING:
    295                  {
    296                      if ( BTHandlerState == BT_MS_IDLE )
    297                      {
    298                          if (BTHandler_InstrReceiver( &EventParams ) == TRUE )
    299                          {
    300                              //BTHandler_handleCommand( &EventParams );
    301                          }
    302                          else
    303                              mBTHandleParams.taskState = TASK_READY;
    304                      }
    305                      
    306                      BTHandler_ServiceHandle();
    307                  }
    308                  break;    
    309              }
    310              
    311                  vTaskDelay( TASK_MSEC2TICKS(100) );
    312              }
    313          }
    314          
    315          static void BTHandler_PowerCtl(void)
    316          {
    317              //xBTHandleCommand mBTHandleCommand;
    318          
    319              if(pPowerHandle_ObjCtrl->get_power_state() == POWER_OFF)
    320              {
    321                  mBTHandleParams.taskState = TASK_READY;
    322          
    323                  mBTHandleComd = BT_HANDLE_INIT;
    324                  pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleComd);
    325              }
    326              else
    327              {
    328                  mBTHandleComd = BT_HANDLE_DINIT;
    329                  pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleComd);
    330              }
    331          }
    332          
    333          static bool BTHandler_ToogleBTPower(bool OnOff)
    334          {
    335              if (BT_GPIO_sema_mutex_take() == TRUE)
    336              {
    337                  if ( OnOff == TRUE )
    338                  {
    339                      //if ( GPIOMiddleLevel_Read_OutBit(__O_BT_ON) == 0 )
    340                      //TRACE_DEBUG((0, "BTStatus VREG - 1 %d",BTStatus)); 
    341                      if (BTStatus == BT_POWER_OFF || BTStatus == BT_STATUS_ERROR)
    342                      {
    343                          GPIOMiddleLevel_Clr(__O_BT_ON);
    344                          vTaskDelay( BT_POWER_TOOGLE_TIME );
    345                          GPIOMiddleLevel_Set(__O_BT_ON);
    346                          vTaskDelay( BT_POWER_TOOGLE_TIME );
    347                          GPIOMiddleLevel_Clr(__O_BT_ON);
    348                          vTaskDelay( BT_POWER_TOOGLE_TIME );
    349                          TRACE_DEBUG((0, "BT VREG - 1 ")); 
    350                      }    
    351                      
    352                  }
    353                  else if ( OnOff == FALSE )
    354                  {
    355                      //if ( GPIOMiddleLevel_Read_OutBit(__O_BT_ON) == 1 )        
    356                      if ( BTStatus  != BT_POWER_OFF ) 
    357                      {
    358                          GPIOMiddleLevel_Clr(__O_BT_ON);
    359                          vTaskDelay( BT_POWER_TOOGLE_TIME );
    360                          GPIOMiddleLevel_Set(__O_BT_ON);
    361                          vTaskDelay( BT_POWER_TOOGLE_TIME );
    362                          GPIOMiddleLevel_Clr(__O_BT_ON);
    363                          vTaskDelay( BT_POWER_TOOGLE_TIME );
    364                          TRACE_DEBUG((0, "BT VREG - 0 "));    
    365                          
    366                      }
    367                      //return TRUE;
    368                  }
    369                  BT_GPIO_sema_mutex_give();
    370                  return TRUE;
    371              }
    372          
    373              return FALSE;
    374          
    375          }
    376          
    377          static uint8 BTHandler_GetQueueNumber( void )
    378          {
    379              return (uint8)uxQueueMessagesWaiting(mBTHandleParams.QParams.xQueue);
    380          }
    381          
    382          static xBTHandleModuleStatus BTHanlder_reportBTStatus( void )
    383          {
    384              return BTStatus;
    385          }
    386          
    387          static void BTHandler_GetBTStatus( xBTHandleModuleStatus *update_status )
    388          {   
    389          #if 0
    390              uint8 TempStatus = 5;
    391              
    392              if ( GPIOMiddleLevel_Read_InBit(__I_BT_DET2) ) //LED 0
    393                  TempStatus = 1;
    394              else
    395                  TempStatus = 0;
    396          
    397              if ( GPIOMiddleLevel_Read_InBit(__I_BT_DET1) ) //LED 1
    398                  TempStatus = TempStatus+2;
    399              else
    400                  TempStatus = TempStatus+0;
    401          
    402              return (xBTHandleModuleStatus)TempStatus;
    403          #else
    404              uint8 TempStatus0 = 0;
    405              uint8 TempStatus1 = 0;
    406              xHMISystemParams tmpSystemParams;
    407              //xBTHandleModuleStatus ret_val = BT_STATUS_ERROR;
    408              
    409              if (BT_GPIO_sema_mutex_noWait_take() == TRUE)
    410              {
    411                  TempStatus0 = GPIOMiddleLevel_Read_InBit(__I_BT_DET2);
    412                  TempStatus1 = GPIOMiddleLevel_Read_InBit(__I_BT_DET1);
    413          
    414                  if ( pPowerHandle_ObjCtrl->get_power_state() == POWER_OFF )
    415                  {
    416                      *update_status = BT_POWER_OFF;
    417                      tmpSystemParams.sys_event = SYS_EVENT_SYSTEM_DOWN;
    418                      //pUDM_ObjCtrl->SendEvent( &tmpSystemParams );
    419                      
    420                      //TRACE_DEBUG((0, "update_status power off---- "));
    421                  }
    422                  else if (TempStatus0 == 0 && TempStatus1 == 0)
    423                  {
    424                      //connectable
    425                      *update_status = BT_POWER_ON;
    426                      //TRACE_DEBUG((0, "update_status connectable ---- "));
    427                  }
    428                  else if (TempStatus0 == 1 && TempStatus1 == 1)
    429                  {
    430                      //standby mode
    431                      *update_status = BT_POWER_OFF;
    432                      //TRACE_DEBUG((0, "update_status standby ---- "));
    433                  }
    434                  else if (TempStatus0 == 0 && TempStatus1 == 1)
    435                  {
    436                      //linked
    437                      *update_status = BT_LINKED;
    438                      //TRACE_DEBUG((0, "update_status linked ---- "));
    439                  }
    440                  else if (TempStatus0 == 1 && TempStatus1 == 0)
    441                  {
    442                      //connectable or discoverable
    443                      *update_status = BT_PAIRING;
    444                      //TRACE_DEBUG((0, "update_status discoverable ---- "));
    445                  }
    446                  else
    447                  {
    448                      *update_status = BT_STATUS_ERROR;
    449                      //TRACE_DEBUG((0, "update_status error ---- "));
    450                  }
    451          
    452                  BT_GPIO_sema_mutex_give();
    453              }
    454              //return ret_val;
    455          #endif
    456          }
    457          
    458          static void BT_GPIO_BT_PAIRING_CTTL(void)
    459          {
    460              if (BT_GPIO_sema_mutex_take() == TRUE)
    461              {
    462                  GPIOMiddleLevel_Clr(__O_BT_PAIRING);
    463                  vTaskDelay( TASK_MSEC2TICKS(100) );
    464                  GPIOMiddleLevel_Set(__O_BT_PAIRING);
    465                  vTaskDelay( TASK_MSEC2TICKS(100) );
    466                  GPIOMiddleLevel_Clr(__O_BT_PAIRING);
    467                  BT_GPIO_sema_mutex_give();
    468              }
    469          }
    470          
    471          static void BT_GPIO_BT_PLAY_CTTL(void)
    472          {
    473              if (BT_GPIO_sema_mutex_take() == TRUE)
    474              {
    475                  GPIOMiddleLevel_Set(__O_BT_MFB);
    476                  vTaskDelay( BT_AVRCP_CTRL_TIME );
    477                  GPIOMiddleLevel_Clr(__O_BT_MFB);
    478                  BT_GPIO_sema_mutex_give();
    479              }
    480          }
    481          
    482          static void BT_GPIO_BT_PLAY_NEXT(void)
    483          {
    484              if (BT_GPIO_sema_mutex_take() == TRUE)
    485              {
    486                  GPIOMiddleLevel_Set(__O_BT_FWD);
    487                  vTaskDelay( BT_AVRCP_CTRL_TIME );
    488                  GPIOMiddleLevel_Clr(__O_BT_FWD);
    489                  BT_GPIO_sema_mutex_give();
    490              }
    491          }
    492          
    493          static void BT_GPIO_BT_PLAY_PRE(void)
    494          {
    495              if (BT_GPIO_sema_mutex_take() == TRUE)
    496              {
    497                  GPIOMiddleLevel_Set(__O_BT_REW);
    498                  vTaskDelay( BT_AVRCP_CTRL_TIME );
    499                  GPIOMiddleLevel_Clr(__O_BT_REW);
    500                  BT_GPIO_sema_mutex_give();
    501              }
    502          }
    503          
    504          static void BT_GPIO_BT_CLEAN_DEVICE(void)
    505          {
    506              portTickType curr_time = 0;
    507              //portTickType total_clean_time = 0;
    508              
    509              if (BT_GPIO_sema_mutex_take() == TRUE)
    510              {
    511                  GPIOMiddleLevel_Set(__O_BT_PAIRING);
    512                  GPIOMiddleLevel_Set(__O_BT_REW);
    513                  GPIOMiddleLevel_Set(__O_BT_FWD);
    514                  //vTaskDelay( TASK_MSEC2TICKS(5000) );
    515                  vTaskDelay( TASK_MSEC2TICKS(3000) );
    516          #if 0        
    517                  curr_time = xTaskGetTickCount();
    518                  while (( ((xTaskGetTickCount() - curr_time)/portTICK_RATE_MS) <= BT_CLEAN_DEVICE_TIME))
    519                  {
    520                      curr_time = xTaskGetTickCount();
    521                      vTaskDelay( TASK_MSEC2TICKS(100) );
    522                  }
    523          #endif        
    524                  GPIOMiddleLevel_Clr(__O_BT_REW);
    525                  GPIOMiddleLevel_Clr(__O_BT_FWD);
    526                  vTaskDelay( TASK_MSEC2TICKS(100) );
    527          
    528          #if 0        
    529                  GPIOMiddleLevel_Clr(__O_BT_PAIRING);
    530                  vTaskDelay( TASK_MSEC2TICKS(100) );
    531                  GPIOMiddleLevel_Set(__O_BT_PAIRING);
    532                  vTaskDelay( TASK_MSEC2TICKS(100) );
    533                  GPIOMiddleLevel_Clr(__O_BT_PAIRING);
    534          #endif        
    535                  //vTaskDelay( TASK_MSEC2TICKS(5000) );
    536                  vTaskDelay( TASK_MSEC2TICKS(100) );
    537                  BT_GPIO_sema_mutex_give();
    538              }
    539          }
    540          
    541          static void BTHandler_handleCommand( void *params  )
    542          {
    543              xHMISystemParams* pSystemParms = (xHMISystemParams*)params;
    544          
    545              if ( params == NULL )
    546                  return;
    547          
    548              switch( pSystemParms->sys_event )
    549              {
    550                  case SYS_EVENT_SYSTEM_UP:
    551                  {
    552                      mBTHandleParams.taskState = TASK_READY;
    553                      Is_Start_Counter = FALSE;
    554                      BT_time_status = BT_TIME_INIT;
    555                      
    556                      if ( pSystemParms->input_src == AUDIO_SOURCE_BLUETOOTH )
    557                      {
    558                          //TRACE_DEBUG((0, "111 BT SYS_EVENT_SYSTEM_UP - enable %d",BTHandler_GetBTStatus()));
    559                          //TRACE_ERROR((0, "BT start up ..1111.. " ));    
    560                          BTHandler_ToogleBTPower( TRUE );
    561          
    562                          while (BTStatus == BT_POWER_OFF || BTStatus == BT_STATUS_ERROR)
    563                          {
    564                              BTHandler_GetBTStatus(&BTStatus);
    565                              //TRACE_ERROR((0, "BT start status ..5555.. %d", BTStatus));
    566                              if (retry_timer >= BT_START_UP_TIMER)
    567                              {
    568                                  BTHandler_ToogleBTPower( TRUE );
    569                                  retry_timer = 0;
    570                              }
    571                              else
    572                              {
    573                                  retry_timer++;
    574                              }
    575                          }
    576                          
    577                          BTHandlerState = BT_MS_CHECKING_PAIRING_STATUS;
    578                          //TRACE_DEBUG((0, "BT SYS_EVENT_SYSTEM_UP - enable %d",BTHandler_GetBTStatus()));
    579                          TRACE_DEBUG((0, "BT SYS_EVENT_SYSTEM_UP - Enable "));
    580          
    581                          BTHandler_TaskCtrl(BTASK_RESUME);
    582                      }
    583                      else
    584                      {
    585                          //TRACE_ERROR((0, "BT start down 2222 .... " ));
    586                          BTHandler_ToogleBTPower( FALSE );
    587                          BTHandlerState = BT_MS_IDLE;
    588                          BTHandler_TaskCtrl(BTASK_SUSPENDED);
    589                          TRACE_DEBUG((0, "BT SYS_EVENT_SYSTEM_UP - Disable "));
    590                      }
    591          
    592                      pPowerHandle_ObjCtrl->turn_on_done( mBTHandleParams.power_handle );
    593                  }
    594                      break;
    595          
    596                  case SYS_EVENT_SYSTEM_DOWN:
    597                  {
    598                      //TRACE_ERROR((0, "BT start down 3333 .... " ));
    599                      BTHandler_ToogleBTPower( FALSE );
    600                      BTHandler_TaskCtrl(BTASK_SUSPENDED);
    601                      Is_Start_Counter = FALSE;
    602                      BT_time_status = BT_TIME_INIT;
    603                      pPowerHandle_ObjCtrl->turn_off_done( mBTHandleParams.power_handle );
    604                      TRACE_DEBUG((0, " BT SYS_EVENT_SYSTEM_DOWN "));
    605                  }
    606                      break;
    607          
    608                  case SYS_EVENT_SEL_SRC:
    609                  {
    610                      if ( pSystemParms->input_src == AUDIO_SOURCE_BLUETOOTH )
    611                      {
    612                          //TRACE_ERROR((0, "BT start up 4444.... " ));
    613                          BTHandler_ToogleBTPower( TRUE );
    614                          //BTHandlerState = BT_MS_CHECKING_PAIRING_STATUS;
    615                          BTHandler_TaskCtrl(BTASK_RESUME);
    616                      }
    617                      else
    618                      {
    619                          //TRACE_ERROR((0, "BT start down 5555.... " ));
    620                          BTHandler_ToogleBTPower( FALSE );
    621                          BTHandlerState = BT_MS_IDLE;
    622                          Is_Start_Counter = FALSE;
    623                          BT_time_status = BT_TIME_INIT;
    624                          BTHandler_TaskCtrl(BTASK_SUSPENDED);
    625                          
    626                          TRACE_DEBUG((0, "BT SYS_EVENT_SEL_SRC - Disable "));
    627                      }
    628                  }
    629                      break;
    630          
    631                  case SYS_EVENT_BT_PAIRING:
    632                  {
    633                      if ( pSystemParms->input_src == AUDIO_SOURCE_BLUETOOTH )
    634                      {
    635          #if 0
    636                          GPIOMiddleLevel_Clr(__O_BT_PAIRING);
    637                          vTaskDelay( TASK_MSEC2TICKS(100) );
    638                          GPIOMiddleLevel_Set(__O_BT_PAIRING);
    639                          vTaskDelay( TASK_MSEC2TICKS(100) );
    640          #else
    641                          BT_GPIO_BT_PAIRING_CTTL();
    642          #endif
    643                          BTHandler_TaskCtrl(BTASK_RESUME);
    644                          BTHandlerState = BT_MS_CHECKING_PAIRING_STATUS;
    645                          pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_BT_PAIRING);
    646                          //TRACE_DEBUG((0, "BT is pairing..."));
    647                      }
    648                  }
    649                      break;
    650          
    651                  case SYS_EVENT_BT_AVRCP_PLAY_PAUSE:
    652                  {
    653                      if( ( BTStatus == BT_LINKED ) && ( pSystemParms->input_src == AUDIO_SOURCE_BLUETOOTH ) )
    654                      {
    655          #if 0
    656                          GPIOMiddleLevel_Set(__O_BT_MFB);
    657                          vTaskDelay( BT_AVRCP_CTRL_TIME );
    658                          GPIOMiddleLevel_Clr(__O_BT_MFB);
    659          #else
    660                          BT_GPIO_BT_PLAY_CTTL();
    661          #endif
    662                          TRACE_DEBUG((0, "BT AVRCP PLAY or PAUSE "));
    663                      }
    664          
    665                  }
    666                      break;
    667          
    668                  case SYS_EVENT_BT_AVRCP_NEXT:
    669                  {
    670                      if( ( BTStatus == BT_LINKED ) && ( pSystemParms->input_src == AUDIO_SOURCE_BLUETOOTH ) )
    671                      {
    672          #if 0
    673                          GPIOMiddleLevel_Set(__O_BT_FWD);
    674                          vTaskDelay( BT_AVRCP_CTRL_TIME );
    675                          GPIOMiddleLevel_Clr(__O_BT_FWD);
    676          #else
    677                          BT_GPIO_BT_PLAY_NEXT();
    678          #endif
    679                          TRACE_DEBUG((0, "BT AVRCP NEXT"));
    680                      }
    681                  }
    682                      break;
    683          
    684                  case SYS_EVENT_BT_AVRCP_PREVIOUS:
    685                  {
    686                      if( ( BTStatus == BT_LINKED ) && ( pSystemParms->input_src == AUDIO_SOURCE_BLUETOOTH ) )
    687                      {
    688          #if 0
    689                          GPIOMiddleLevel_Set(__O_BT_REW);
    690                          vTaskDelay( BT_AVRCP_CTRL_TIME );
    691                          GPIOMiddleLevel_Clr(__O_BT_REW);
    692          #else
    693                          BT_GPIO_BT_PLAY_PRE();
    694          #endif
    695                          TRACE_DEBUG((0, "BT AVRCP PREVIOUS"));
    696                      }
    697                  }
    698                      break;
    699          
    700                  case SYS_EVENT_SYSTEM_RESET:
    701                  case SYS_EVENT_BT_CLEAN_DEVICE:
    702                  {
    703                      BTHandlerState = BT_MS_CLEAN_DEVICE;
    704                      
    705                      BTHandler_ToogleBTPower( TRUE );
    706                      
    707                      BTHandler_TaskCtrl(BTASK_RESUME);
    708                      
    709                      //TRACE_DEBUG((0, "BT clean device start  %d",xTaskGetTickCount()));
    710                      
    711                     //TRACE_DEBUG((0, "BT clean device end  %d",xTaskGetTickCount()));
    712          #if 1            
    713                      while (BTHandlerState != BT_MS_IDLE)
    714                      {
    715                          TRACE_DEBUG((0, "BT clean device ..."));
    716                      }
    717          #endif
    718                      BTHandler_ToogleBTPower( FALSE );
    719                      BTHandler_TaskCtrl(BTASK_SUSPENDED);
    720                  }
    721                      break;
    722          
    723          #if 0
    724                      case SYS_EVENT_BT_AVRCP_PREVIOUS:
    725                          {
    726                              static bool invert = FALSE;
    727          
    728                              invert = ~invert;
    729          
    730                              if ( invert )
    731                                  {
    732                              GPIOMiddleLevel_Set(__O_BT_REW);
    733                              GPIOMiddleLevel_Set(__O_BT_FWD);
    734                                  }
    735                              else
    736                                  {
    737                              GPIOMiddleLevel_Clr(__O_BT_REW);
    738                              GPIOMiddleLevel_Clr(__O_BT_FWD);
    739                                  }
    740                          }
    741                          break;
    742          #endif
    743                  default:
    744                      break;
    745          
    746              }        
    747              
    748          }
    749          
    750          #if 0
    751          static void BTHandler_handleCommand(void *cmds)
    752          {
    753              xBTHandleCommand* BTHandleCmd = (xBTHandleCommand*)cmds;
    754          
    755              switch(*BTHandleCmd)
    756              {
    757          
    758                  case BT_NOTIFY_POW_SEQ_DONE:
    759                  {
    760                      TRACE_INFO((0, " BTHandler_handleCommand :  BT_NOTIFY_POW_SEQ_DONE !! "));
    761                      
    762                      if(pPowerHandle_ObjCtrl->get_power_state() == POWER_ON)
    763                      {
    764                          pPowerHandle_ObjCtrl->turn_on_done( mBTHandleParams.power_handle );
    765                      }
    766                      else// if(pPowerHandle_ObjCtrl->get_power_state() == POWER_DOWN)
    767                      {
    768                          pPowerHandle_ObjCtrl->turn_off_done( mBTHandleParams.power_handle );
    769                          mBTHandleParams.taskState = TASK_SUSPENDED;
    770                      }
    771                  }
    772                  break;
    773                  
    774                  case BT_HANDLE_ON:
    775                  {
    776                      TRACE_INFO((0, " BTHandler_handleCommand :  BT_HANDLE_ON !! "));
    777                      BTHandlerState = BT_MS_POWER_ON;
    778                      mBTHandlerStamp = 0;
    779                  }
    780                  break;
    781          
    782                  case BT_HANDLE_OFF:
    783                  {
    784                      TRACE_INFO((0, " BTHandler_handleCommand :  BT_HANDLE_OFF !! "));
    785                      BTHandlerState = BT_MS_POWER_OFF;
    786                      mBTHandlerStamp = 0;
    787                  }
    788                  break;
    789          
    790                  case BT_HANDLE_INIT:
    791                  {
    792                      TRACE_INFO((0, " BTHandler_handleCommand :  BT_HANDLE_INIT !! "));
    793                      BTHandlerState = BT_MS_INIT;
    794                      mBTHandlerStamp = 0;
    795                  }
    796                  break;
    797          
    798                  case BT_HANDLE_DINIT:
    799                  {
    800                      TRACE_INFO((0, " BTHandler_handleCommand :  BT_HANDLE_DINIT !! "));
    801                      BTHandlerState = BT_MS_DEINIT;
    802                      mBTHandlerStamp = 0;
    803                  }
    804                  break;
    805          
    806                  case BT_HANDLE_NEXT:
    807                  {
    808                      TRACE_INFO((0, " BTHandler_handleCommand :  BT_HANDLE_NEXT !! "));    
    809                      BTHandlerState = BT_MS_NEXT;
    810                      mBTHandlerStamp = 0;
    811                  }
    812                  break;
    813          
    814                  case BT_HANDLE_PREVIOUS:
    815                  {
    816                      TRACE_INFO((0, " BTHandler_handleCommand :  BT_HANDLE_PREVIOUS !! "));
    817                      BTHandlerState = BT_MS_PREVIOUS;
    818                      mBTHandlerStamp = 0;
    819                  }
    820                  break;
    821          
    822                  case BT_HANDLE_PLAY_PAUSE:
    823                  {
    824                      TRACE_INFO((0, " BTHandler_handleCommand :  BT_HANDLE_PLAY_PAUSE !! "));
    825                      BTHandlerState = BT_MS_PLAY_PAUSE;
    826                      mBTHandlerStamp = 0;
    827                  }
    828                  break;
    829                  
    830                  case BT_HANDLE_PAIRING:
    831                  {
    832                      TRACE_INFO((0, " BTHandler_handleCommand :  BT_HANDLE_PAIRING !! "));
    833                      BTHandlerState = BT_MS_PAIRING;
    834                      mBTHandlerStamp = 0;
    835                  }
    836                  break;
    837          
    838                  case BT_HANDLE_CLEAN_DEVICE:
    839                  {
    840                      TRACE_INFO((0, " BTHandler_handleCommand :  BT_HANDLE_CLEAN_DEVICE !! "));
    841                      BTHandlerState = BT_MS_CLEAN_DEVICE;
    842                      mBTHandlerStamp = 0;
    843                  }
    844                  break;
    845          
    846                  case BT_HANDLE_RESET_BT:
    847                  {
    848                      TRACE_INFO((0, " BTHandler_handleCommand :  BT_HANDLE_RESET_BT !! "));
    849                      BTHandlerState = BT_MS_RESET_BT;
    850                      mBTHandlerStamp = 0;
    851                  }
    852                  break;
    853          
    854              default:
    855                  break;    
    856              }
    857          }
    858          #endif
    859          
    860          static void BTHandler_ServiceHandle( void )
    861          {
    862              xHMISrvEventParams srv_parms = {xHMI_EVENT_BT, USER_EVENT_UNDEFINED };
    863          
    864              switch(BTHandlerState)
    865              {
    866                  case BT_MS_IDLE:
    867                  {
    868                      //TRACE_ERROR((0, "BT_MS_IDLE.... %d", BTStatus));
    869                      if ((BTStatus == BT_POWER_ON) ||
    870                          (BTStatus == BT_PAIRING))
    871                      {
    872                          BTHandlerState = BT_MS_CHECKING_PAIRING_STATUS;
    873                      }
    874                  }
    875                      break;
    876          
    877                  case BT_MS_CLEAN_DEVICE:
    878                  {
    879                      //TRACE_ERROR((0, "BT start up 6666.... " ));
    880          #if 1
    881                      BTHandler_ToogleBTPower( TRUE );
    882                      vTaskDelay( TASK_MSEC2TICKS(100) );
    883          
    884          #if 0
    885                      GPIOMiddleLevel_Set(__O_BT_REW);
    886                      GPIOMiddleLevel_Set(__O_BT_FWD);
    887                      //vTaskDelay( TASK_MSEC2TICKS(5000) );
    888                      vTaskDelay( TASK_MSEC2TICKS(2900) );
    889                      GPIOMiddleLevel_Clr(__O_BT_REW);
    890                      GPIOMiddleLevel_Clr(__O_BT_FWD);
    891          #else
    892                      BT_GPIO_BT_CLEAN_DEVICE();
    893          #endif
    894                      //TRACE_ERROR((0, "BT start down 7777 .... " ));
    895                      BTHandler_ToogleBTPower( FALSE );
    896                      pPowerHandle_ObjCtrl->turn_off_done( mBTHandleParams.power_handle );
    897                      TRACE_DEBUG((0, "BT clean device finished"));
    898          #endif        
    899                      BTHandlerState = BT_MS_IDLE;
    900                  }
    901                      break;
    902          
    903                  case BT_MS_CHECKING_PAIRING_STATUS:
    904                  {
    905                      //TRACE_DEBUG((0, " BT_MS_CHECKING_PAIRING_STATUS BT status ... %d ",BTStatus));
    906                      if ( BTStatus == BT_LINKED )
    907                      {
    908                          /*LED indicates bt pairing success*/
    909                          pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_BT_PAIRED);
    910          
    911                          TRACE_DEBUG((0, "BT pairing is done "));
    912                          BTHandlerState = BT_MS_IDLE;
    913                          Is_Start_Counter = FALSE;
    914                          BT_time_status = BT_TIME_INIT;
    915                          start_time = 0;
    916                      }
    917                      else if ( BTStatus == BT_PAIRING  || BTStatus == BT_POWER_ON)
    918                      {
    919                          /*LED indicates bt pairing success*/
    920                          if (Is_Start_Counter == FALSE)
    921                          {
    922                              //if (BTStatus == BT_PAIRING)
    923                              {
    924                                  pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_BT_PAIRING);
    925                                  TRACE_DEBUG((0, " show pairing led light ...  "));
    926                              }
    927                              start_time = xTaskGetTickCount( );
    928                              Is_Start_Counter = TRUE;
    929                              
    930                          }
    931          
    932                          //pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_BT_PAIRING);
    933                          
    934                          if (( ((xTaskGetTickCount() - start_time)/portTICK_RATE_MS) > BT_AUTO_PAIRING_TIME) && (BT_time_status == BT_TIME_INIT))
    935                          {
    936                              //Trigger auto pairing mechanism
    937                              if (BTStatus != BT_PAIRING)
    938                              {
    939                                  BT_GPIO_BT_PAIRING_CTTL();
    940                              }
    941                              start_time = xTaskGetTickCount();
    942                              BT_time_status = BT_TIME_AUTO_PAIRING;
    943                              TRACE_DEBUG((0, "BT auto pairing start..."));
    944                          }
    945                          else if ( (((xTaskGetTickCount() - start_time)/portTICK_RATE_MS) > BT_ENERGY_SAVING_TIME) && (BT_time_status == BT_TIME_AUTO_PAIRING))
    946                          {
    947                              //Auto power off
    948                              //TRACE_ERROR((0, "BT start down 8888 .... " ));
    949                              start_time = 0;
    950                              Is_Start_Counter = FALSE;
    951                              BTHandlerState = BT_MS_IDLE;
    952                              BT_time_status = BT_TIME_INIT;
    953          
    954                              
    955                              BTHandler_ToogleBTPower(FALSE);
    956                              //send event to hmi
    957                              
    958                              srv_parms.event = USER_EVENT_POWER;
    959                              pHS_ObjCtrl->SendEvent( &srv_parms );
    960                          }
    961                          
    962                          //TRACE_DEBUG((0, "Display BT pairing ... "));
    963                          //BTHandlerState = BT_MS_IDLE;
    964                      }
    965                      else if ( BTStatus == BT_POWER_OFF )
    966                      {
    967                          //TRACE_DEBUG((0, "Display BT Power off ... "));
    968                          start_time = 0;
    969                          Is_Start_Counter = FALSE;
    970                          BTHandlerState = BT_MS_IDLE;
    971                          BT_time_status = BT_TIME_INIT;
    972                      }
    973                  }
    974                      break;
    975          
    976          
    977              }
    978          
    979          }
    980          
    981          static void BTHandler_TaskCtrl( bool val )
    982          {
    983              if ( val == BTASK_SUSPENDED )
    984              {
    985                  if ( xTaskIsTaskSuspended( mBTHandleParams.TaskHandle ) != pdPASS ) /*task is working*/
    986                  {            
    987                      start_time = 0;
    988                      Is_Start_Counter = FALSE;
    989                      BTHandlerState = BT_MS_IDLE;
    990                      BT_time_status = BT_TIME_INIT;
    991                      BTStatus = BT_POWER_OFF;
    992                      vTaskSuspend( mBTHandleParams.TaskHandle );
    993                      //TRACE_DEBUG((0, "SUSPEND: AuidoDeviceManager_lowlevel_Exception_Task"));
    994                  }
    995              }
    996              else if ( val == BTASK_RESUME )
    997              {
    998                  if ( xTaskIsTaskSuspended( mBTHandleParams.TaskHandle ) == pdPASS ) /*task is not working*/
    999                  {
   1000                      vTaskResume( mBTHandleParams.TaskHandle );
   1001                      //TRACE_DEBUG((0, "RESUME: AuidoDeviceManager_lowlevel_Exception_Task"));
   1002                  }
   1003              }
   1004          }
   1005          
   1006          #if 0
   1007          static void BTHandler_ServiceHandle( void )
   1008          { 
   1009          
   1010              //for(;;)
   1011              //{       
   1012                  switch(BTHandlerState)
   1013                  {
   1014                      case BT_MS_IDLE:
   1015                      {    
   1016                          LastBTStatus = BTStatus;
   1017                          BTStatus = BTHandler_GetBTStatus();
   1018                          
   1019          		if ( BTStatus != BT_POWER_OFF )
   1020          		{
   1021          		    if ( mBTHandlerPowerOnStamp != 0xff )
   1022          		        mBTHandlerPowerOnStamp++;
   1023          			
   1024          		    if ( mBTHandlerPowerOnStamp > 11 );
   1025          			mBTHandlerPowerOnStamp = 0xff;	//had powered on more than 1s
   1026          		
   1027          		}
   1028          		else
   1029          			mBTHandlerPowerOnStamp = 0;	//No need to count for power on when power off or more than 1s
   1030          
   1031                          /*if( (BTStatus == BT_LINKED) && ( NeedPairing == TRUE) )
   1032                          {                     
   1033                              xHMISystemParams srv_parms;
   1034          
   1035                              NeedPairing = FALSE;
   1036                      
   1037                              srv_parms.sys_event = SYS_EVENT_SYSTEM_UP;    // Set LED
   1038                              pUDM_ObjCtrl->SendEvent( &srv_parms ); 
   1039                          }*/
   1040          				
   1041                          if ( (BTStatus == BT_LINKED) && (LastBTStatus != BT_LINKED) )
   1042                          {
   1043                              pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_BT_PAIRED);
   1044                          }
   1045                          
   1046          /*              if( BTStatus == BT_LINKED )
   1047                          {                     
   1048                              mBTHandlerStamp = 0;
   1049                          }
   1050                          else
   1051                          {                   
   1052                              mBTHandlerStamp++;
   1053                              
   1054                              if(mBTHandlerStamp > 600)
   1055                              {
   1056                                  BTHandlerState = BT_MS_PAIRING;
   1057                                  mBTHandlerStamp = 0;
   1058                              }
   1059                          }
   1060          */
   1061                      }
   1062                      break;
   1063          
   1064                      case BT_MS_INIT:
   1065                      {
   1066          /*              mBTHandlerStamp++;
   1067          
   1068                          if ( mBTHandlerStamp == 1 )
   1069                          {
   1070                              GPIOMiddleLevel_Clr(__O_BT_INF);
   1071                          }
   1072                          if ( mBTHandlerStamp == 10 )
   1073                          {
   1074                              GPIOMiddleLevel_Set(__O_BT_INF);
   1075                          }
   1076                          else if ( mBTHandlerStamp >= 31 )
   1077                          {
   1078                              GPIOMiddleLevel_Clr(__O_BT_INF);
   1079                             BTHandlerState = BT_MS_IDLE;
   1080                                  BTHandler_handleCommand(BT_NOTIFY_POW_SEQ_DONE);
   1081                          }
   1082          */
   1083                          GPIOMiddleLevel_Clr(__O_BT_REW);
   1084                          GPIOMiddleLevel_Clr(__O_BT_FWD);
   1085                          GPIOMiddleLevel_Clr(__O_BT_MFB);
   1086                          GPIOMiddleLevel_Set(__O_BT_REST);
   1087                      
   1088                          //mBTHandleComd = BT_NOTIFY_POW_SEQ_DONE;
   1089                          //pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleComd);
   1090                      
   1091                          BTHandlerState = BT_MS_IDLE;
   1092                      }
   1093                      break;
   1094          
   1095                      case BT_MS_POWER_ON:
   1096                      {                
   1097                          mBTHandlerStamp++;
   1098          
   1099                          if ( BTStatus == BT_CLEAN_DONE )
   1100                              NeedPairing = TRUE;
   1101          
   1102                          LastBTStatus = BT_POWER_OFF;
   1103                          BTStatus = BTHandler_GetBTStatus();
   1104          
   1105                          if(mBTHandlerStamp == 1)
   1106                          {
   1107                              GPIOMiddleLevel_Set(__O_BT_REST);                    
   1108          
   1109                              if ( BTStatus == BT_POWER_OFF )    //Power of BT if BT is not in power off mode
   1110                              {
   1111                                  if ( BTHandler_ToogleBTPower(TRUE) )
   1112          	    		    mBTHandlerStamp = 0;
   1113                              }
   1114                          }
   1115                          else
   1116                          {
   1117                              if ( BTStatus != BT_POWER_OFF )    //Power of BT if BT is not in power off mode
   1118                              {
   1119                                  mBTHandlerStamp = 0;
   1120          			mBTHandlerPowerOnStamp = 1;
   1121          
   1122          			if ( BTStatus != BT_LINKED )
   1123                                      pUDM_ObjCtrl->ExceptionSendEvent(UI_EVENT_BT_PAIRING);
   1124          			
   1125                                  if ( NeedPairing == TRUE )
   1126                                  {
   1127                                      BTHandlerState = BT_MS_PAIRING;
   1128          			    NeedPairing = FALSE;
   1129                                  }
   1130                                  else
   1131                                  {
   1132                                      BTHandlerState = BT_MS_IDLE;
   1133                                  }
   1134          
   1135                              }
   1136                              else if ( mBTHandlerStamp >= 31 )
   1137                              {
   1138                                  TRACE_INFO((0, " BTHandler_handleCommand :  Wait for BT Power ON timeout. "));
   1139          
   1140                                  mBTHandlerStamp = 0;
   1141                                  //BTHandlerState = BT_MS_IDLE;
   1142                              }
   1143                          }
   1144                      }
   1145                      break;
   1146          
   1147                      case BT_MS_RESET_BT:
   1148          	    {
   1149                          mBTHandlerStamp++;
   1150                          BTHandlerState = BT_MS_CLEAN_DEVICE;
   1151                      }
   1152          	    break;
   1153          		
   1154                      case BT_MS_DEINIT:
   1155                      case BT_MS_POWER_OFF:
   1156                      {
   1157                      //xBTHandleModuleStatus BTStatus = BT_STATUS_ERROR
   1158          
   1159          		if ( mBTHandlerPowerOnStamp != 0xff )	// The time of BT in power on stage is less 1 second 
   1160          		{
   1161          		        if ( mBTHandlerPowerOnStamp )
   1162          		        {
   1163          			    mBTHandlerPowerOnStamp++;
   1164          
   1165          			    if ( mBTHandlerPowerOnStamp > 11 )	// The time of BT in power on stage is more than 1 second 
   1166          			    {
   1167          				mBTHandlerPowerOnStamp = 0xff;
   1168          			    }
   1169          		        }
   1170          			else 
   1171          			{
   1172          			    if ( BTHandlerState == BT_MS_DEINIT )
   1173          			    {
   1174                                          mBTHandleComd = BT_NOTIFY_POW_SEQ_DONE;
   1175                                          pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleComd);
   1176          			    }
   1177          				
   1178          			    BTHandlerState = BT_MS_IDLE;
   1179          			}
   1180          		}
   1181          
   1182                          //if ( (BTHandlerState == BT_MS_RESET_BT) && (mBTHandlerStamp == 0) ) // Need do clean device before powering off
   1183                          //{
   1184                          //    mBTHandlerStamp++;
   1185                          //    BTHandlerState = BT_MS_CLEAN_DEVICE;
   1186                          //}
   1187                          else	//power off BT process
   1188                          {
   1189                              mBTHandlerStamp++;
   1190                              LastBTStatus = BTStatus;
   1191                              BTStatus = BTHandler_GetBTStatus();
   1192                      
   1193                              if ( mBTHandlerStamp == 2 )
   1194                              {
   1195                                  GPIOMiddleLevel_Clr(__O_BT_MFB);
   1196                                  GPIOMiddleLevel_Clr(__O_BT_REW);
   1197                                  GPIOMiddleLevel_Clr(__O_BT_FWD);
   1198          
   1199                                  if ( BTHandlerState != BT_MS_POWER_OFF )
   1200                                      GPIOMiddleLevel_Clr(__O_BT_REST);                    
   1201          
   1202                                  //if( BTStatus == BT_PAIRING )                // Need exit Pairing mode before power off BT
   1203                                  //    GPIOMiddleLevel_Set(__O_BT_PAIRING);
   1204                              }
   1205                              else if ( mBTHandlerStamp == 3 )
   1206                              {
   1207                                  if( BTStatus == BT_PAIRING )
   1208                                      GPIOMiddleLevel_Clr(__O_BT_PAIRING);
   1209                              }
   1210                              else if ( mBTHandlerStamp == 4 )
   1211                              {
   1212                                  if ( BTStatus != BT_POWER_OFF )    //Power off BT if BT is not in power off mode
   1213                                      if ( BTHandler_ToogleBTPower(FALSE) )
   1214          	    			mBTHandlerStamp = 3;
   1215                              }
   1216                              else if ( mBTHandlerStamp >= 6 )
   1217                              {
   1218                                  if ( BTStatus == BT_POWER_OFF )    //Power off BT if BT is not in power off mode
   1219                                  {
   1220                                      if ( BTHandlerState == BT_MS_DEINIT)        //Need send notify message to system when powered off while system is powering off
   1221                                      {
   1222                                          mBTHandleComd = BT_NOTIFY_POW_SEQ_DONE;
   1223                                          pBTHandle_ObjCtrl->bt_instr_sender(&mBTHandleComd);
   1224                                      }
   1225          
   1226                                      mBTHandlerStamp = 0;
   1227                                      BTHandlerState = BT_MS_IDLE;
   1228          			    mBTHandlerPowerOnStamp = 0;
   1229          
   1230                                  }
   1231                                  else if ( mBTHandlerStamp >= 36 )
   1232                                  {
   1233                                      //TRACE_INFO((0, " BTHandler_handleCommand :  BT deinit time out!Can power off BT in 8 seconds"));
   1234                                      
   1235                                      mBTHandlerStamp = 3;
   1236                                      //BTHandlerState = BT_MS_IDLE;
   1237                                  }
   1238                              }
   1239                          }
   1240                      }
   1241                      break;
   1242                      
   1243                      case BT_MS_AUTO_LINK:
   1244                      {
   1245          		if ( mBTHandlerPowerOnStamp != 0xff )
   1246          			mBTHandlerPowerOnStamp++;
   1247          
   1248          		if ( mBTHandlerPowerOnStamp > 11 )
   1249          			mBTHandlerPowerOnStamp = 0xff;
   1250          
   1251                          mBTHandlerStamp++;
   1252          
   1253                          if ( mBTHandlerStamp == 1 )
   1254                              GPIOMiddleLevel_Set(__O_BT_MFB);
   1255                          else if ( mBTHandlerStamp == 13 )
   1256                          {
   1257                              GPIOMiddleLevel_Clr(__O_BT_MFB);
   1258                              mBTHandlerStamp = 0;
   1259                              BTHandlerState = BT_MS_IDLE;
   1260                          }
   1261                      }
   1262                      break;     
   1263                      case BT_MS_PLAY_PAUSE:
   1264                      {
   1265          		if ( mBTHandlerPowerOnStamp != 0 )
   1266          			mBTHandlerPowerOnStamp++;
   1267          
   1268                          mBTHandlerStamp++;
   1269                          if(mBTHandlerStamp == 1)
   1270                          {
   1271                              GPIOMiddleLevel_Set(__O_BT_MFB);
   1272                          }
   1273                          else if(mBTHandlerStamp == 2)
   1274                          {
   1275                              GPIOMiddleLevel_Clr(__O_BT_MFB);
   1276                              mBTHandlerStamp = 0;
   1277                              BTHandlerState = BT_MS_IDLE;
   1278                          }
   1279                      }
   1280                      break;
   1281          
   1282                      case BT_MS_NEXT:
   1283                      {
   1284          		if ( mBTHandlerPowerOnStamp != 0 )
   1285          			mBTHandlerPowerOnStamp++;
   1286          
   1287                          mBTHandlerStamp++;
   1288                          if(mBTHandlerStamp == 1)
   1289                          {
   1290                              GPIOMiddleLevel_Set(__O_BT_FWD);
   1291                          }
   1292                          else if(mBTHandlerStamp == 2)
   1293                          {
   1294                              GPIOMiddleLevel_Clr(__O_BT_FWD);
   1295                              mBTHandlerStamp = 0;
   1296                              BTHandlerState = BT_MS_IDLE;
   1297                          }
   1298                      }
   1299                      break;
   1300          
   1301                      case BT_MS_PREVIOUS:
   1302                      {
   1303          		if ( mBTHandlerPowerOnStamp != 0 )
   1304          			mBTHandlerPowerOnStamp++;
   1305          
   1306                          mBTHandlerStamp++;
   1307                          if(mBTHandlerStamp == 1)
   1308                          {
   1309                              GPIOMiddleLevel_Set(__O_BT_REW);
   1310                          }
   1311                          else if(mBTHandlerStamp == 2)
   1312                          {
   1313                              GPIOMiddleLevel_Clr(__O_BT_REW);
   1314                              mBTHandlerStamp = 0;
   1315                              BTHandlerState = BT_MS_IDLE;
   1316                          }
   1317                      }
   1318                      break;
   1319          
   1320                      case BT_MS_PAIRING:
   1321                      {
   1322          		if ( mBTHandlerPowerOnStamp != 0xff )
   1323          			mBTHandlerPowerOnStamp++;
   1324          
   1325          		if ( mBTHandlerPowerOnStamp > 11 )
   1326          			mBTHandlerPowerOnStamp = 0xff;
   1327          
   1328                          LastBTStatus = BTStatus;
   1329                          BTStatus = BTHandler_GetBTStatus();
   1330          
   1331                          if ( BTStatus == BT_POWER_OFF )
   1332                          {
   1333                              TRACE_INFO((0, " BTHandler_handleCommand :  Fail to do BT pairing. BT is in power off mode"));
   1334                              mBTHandlerStamp = 0;
   1335                              BTHandlerState = BT_MS_IDLE;
   1336                              return;
   1337                          }
   1338                          
   1339                          mBTHandlerStamp++;
   1340                  
   1341                          if ( BTStatus == BT_PAIRING )
   1342                          {
   1343                              mBTHandlerStamp = 0;
   1344                              BTHandlerState = BT_MS_IDLE;
   1345                          }
   1346                          else if(mBTHandlerStamp == 1)
   1347                          {
   1348                              GPIOMiddleLevel_Clr(__O_BT_PAIRING);
   1349                          }
   1350                          else if(mBTHandlerStamp == 2)
   1351                          {
   1352                              GPIOMiddleLevel_Set(__O_BT_PAIRING);
   1353                          }
   1354                          else if(mBTHandlerStamp >= 10)
   1355                          {
   1356                              TRACE_INFO((0, " BTHandler_handleCommand :  BT is fail to go into pairing mode in 1s."));
   1357          
   1358                              mBTHandlerStamp = 0;
   1359                              BTHandlerState = BT_MS_IDLE;
   1360                          }
   1361                      }
   1362                      break;
   1363                      
   1364                      case BT_MS_CLEAN_DEVICE:
   1365                      {
   1366          		if ( mBTHandlerPowerOnStamp )	// 0 means power off, non 0 means power on
   1367          		{
   1368          		    if ( mBTHandlerPowerOnStamp != 0xff )
   1369          		    {
   1370          			mBTHandlerPowerOnStamp++;
   1371          
   1372          		        if ( mBTHandlerPowerOnStamp > 11 )
   1373          			    mBTHandlerPowerOnStamp = 0xff;
   1374          		    }
   1375          		}
   1376          
   1377                          LastBTStatus = BTStatus;
   1378                          BTStatus = BTHandler_GetBTStatus();
   1379          
   1380                          if ( mBTHandlerStamp <= 1 )        // 0 means from factory command, 1 means from BT_MS_RESET_BT (device reset)
   1381                          {
   1382                              if ( BTStatus == BT_POWER_OFF )
   1383                                  BTHandler_ToogleBTPower(TRUE);
   1384          
   1385                              if ( mBTHandlerStamp == 0 )    
   1386                              {
   1387                                  CleanDeviceCmdSource = 0    ;    // command request from factory command
   1388                              }
   1389                              else
   1390                              {
   1391                                  CleanDeviceCmdSource = 1;    // command request from BT_MS_RESET_BT (device reset)
   1392                              }
   1393          
   1394                              mBTHandlerStamp = 2;
   1395                          }
   1396                          else 
   1397                          {
   1398                              if ( BTStatus != BT_POWER_OFF )
   1399                                  mBTHandlerStamp++;
   1400          		    else
   1401          			break;
   1402          
   1403                              if( mBTHandlerStamp == 3 )
   1404                              {
   1405                                  GPIOMiddleLevel_Set(__O_BT_REW);
   1406                                  GPIOMiddleLevel_Set(__O_BT_FWD);
   1407                              }
   1408                              else if( mBTHandlerStamp == 54 )
   1409                              {
   1410                                  GPIOMiddleLevel_Clr(__O_BT_REW);
   1411                                  GPIOMiddleLevel_Clr(__O_BT_FWD);
   1412                              }
   1413                              else if ( mBTHandlerStamp > 54 ) //wait BT clean time 2.5s (8 device * 300ms = 2.4 s)
   1414                              {
   1415                                  TRACE_INFO((0, "BT clean Device is finish !! "));
   1416                                 
   1417                                  BTStatus = BT_CLEAN_DONE;
   1418                          
   1419                                  if ( CleanDeviceCmdSource == 0 )
   1420                                  {
   1421                                      mBTHandlerStamp = 0;
   1422                                      BTHandlerState = BT_MS_IDLE;
   1423                                  }
   1424                                  else if ( CleanDeviceCmdSource == 1 )
   1425                                  {
   1426                                      mBTHandlerStamp = 1;
   1427                                      BTHandlerState = BT_MS_DEINIT;
   1428                                  }
   1429                                  else
   1430                                  {
   1431                                      TRACE_INFO((0, "ERROR: Don't who ask for BT Clean Devic! "));
   1432          
   1433                                      mBTHandlerStamp = 0;
   1434                                      BTHandlerState = BT_MS_IDLE;
   1435                                  }
   1436                                  
   1437                              }
   1438                          }
   1439                      }
   1440                      break;
   1441          
   1442                      case BT_MS_END:
   1443                      {
   1444          		if ( mBTHandlerPowerOnStamp != 0 )
   1445          			mBTHandlerPowerOnStamp++;
   1446          
   1447                          mBTHandlerStamp = 0;
   1448                      }
   1449                      break;
   1450                  }
   1451          
   1452               //   vTaskDelay( TASK_MSEC2TICKS(100) );
   1453              //}
   1454          }
   1455          #endif
   1456          
   1457          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       32  BTHandler_CreateTask
             32 -- Indirect call
             32 -> Debug_printError
             32 -> GPIOMiddleLevel_Clr
             32 -> vTaskSuspend
             32 -> xQueueCreateMutex
             32 -> xQueueGenericCreate
             32 -> xQueueGenericReset
             32 -> xTaskGenericCreate
       16  BTHandler_GetBTStatus
             16 -- Indirect call
              0 -> BT_GPIO_sema_mutex_give
             16 -> GPIOMiddleLevel_Read_InBit
             16 -> xQueueGenericReceive
        0  BTHandler_InstrSender
        8  BTHandler_PowerCtl
              0 -- Indirect call
              8 -- Indirect call
       24  BTHandler_Service
             24 -> BTHandler_GetBTStatus
             24 -> BTHandler_ServiceHandle
             24 -> Debug_printError
             24 -> uxQueueMessagesWaiting
             24 -> vTaskDelay
             24 -> xQueueGenericReceive
       16  BTHandler_ServiceHandle
             16 -- Indirect call
             16 -> BTHandler_ToogleBTPower
             16 -> BT_GPIO_BT_PAIRING_CTTL
             16 -> BT_GPIO_sema_mutex_give
             16 -> BT_GPIO_sema_mutex_take
             16 -> Debug_printDebug
             16 -> GPIOMiddleLevel_Clr
             16 -> GPIOMiddleLevel_Set
             16 -> vTaskDelay
             16 -> xTaskGetTickCount
        8  BTHandler_TaskCtrl
              0 -> vTaskResume
              0 -> vTaskSuspend
              8 -> xTaskIsTaskSuspended
        8  BTHandler_ToogleBTPower
              8 -> BT_GPIO_sema_mutex_give
              8 -> BT_GPIO_sema_mutex_take
              8 -> Debug_printDebug
              8 -> GPIOMiddleLevel_Clr
              8 -> GPIOMiddleLevel_Set
              8 -> vTaskDelay
       16  BTHandler_handleCommand
              0 -- Indirect call
             16 -- Indirect call
             16 -> BTHandler_GetBTStatus
              0 -> BTHandler_TaskCtrl
             16 -> BTHandler_TaskCtrl
             16 -> BTHandler_ToogleBTPower
             16 -> BT_GPIO_BT_PAIRING_CTTL
             16 -> BT_GPIO_sema_mutex_give
             16 -> BT_GPIO_sema_mutex_take
              0 -> Debug_printDebug
             16 -> Debug_printDebug
             16 -> GPIOMiddleLevel_Clr
             16 -> GPIOMiddleLevel_Set
             16 -> vTaskDelay
        0  BTHanlder_reportBTStatus
        8  BT_GPIO_BT_PAIRING_CTTL
              0 -> BT_GPIO_sema_mutex_give
              8 -> BT_GPIO_sema_mutex_take
              8 -> GPIOMiddleLevel_Clr
              8 -> GPIOMiddleLevel_Set
              8 -> vTaskDelay
        8  BT_GPIO_sema_mutex_give
              8 -> xQueueGenericSend
        8  BT_GPIO_sema_mutex_take
              8 -> xQueueGenericReceive


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      28  ?<Constant " BT SYS_EVENT_SYSTEM_...">
      52  ?<Constant " BTHandler_InstrRecei...">
      32  ?<Constant " show pairing led lig...">
      16  ?<Constant "BT AVRCP NEXT">
      24  ?<Constant "BT AVRCP PLAY or PAUSE ">
      20  ?<Constant "BT AVRCP PREVIOUS">
      32  ?<Constant "BT SYS_EVENT_SEL_SRC ...">
      36  ?<Constant "BT SYS_EVENT_SYSTEM_U...">
      36  ?<Constant "BT SYS_EVENT_SYSTEM_U...">_1
      16  ?<Constant "BT VREG - 0 ">
      16  ?<Constant "BT VREG - 1 ">
      28  ?<Constant "BT auto pairing start...">
      20  ?<Constant "BT clean device ...">
      28  ?<Constant "BT clean device finished">
      20  ?<Constant "BT pairing is done ">
      36  ?<Constant "BTHandler_InstrReceiv...">
      32  ?<Constant "BT_Handle task create...">
      12  ?<Constant "BT_Handle">
      40  ?<Constant "Create BTHandle queue...">
       4  ?<Constant {9, 100}>
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_2
       4  ??DataTable31_3
       4  ??DataTable31_4
       4  ??DataTable31_5
       6  ?Subroutine0
       4  ?Subroutine1
       4  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
       6  ?Subroutine5
      20  BTHandle
      24  BTHandlerState
          BTStatus
          Is_Start_Counter
          BT_time_status
          BT_GPIO_sema
          start_time
          retry_timer
     154  BTHandler_CreateTask
     108  BTHandler_GetBTStatus
       4  BTHandler_InstrSender
      42  BTHandler_PowerCtl
     106  BTHandler_Service
     326  BTHandler_ServiceHandle
      68  BTHandler_TaskCtrl
     114  BTHandler_ToogleBTPower
     464  BTHandler_handleCommand
       8  BTHanlder_reportBTStatus
      44  BT_GPIO_BT_PAIRING_CTTL
      30  BT_GPIO_sema_mutex_give
      30  BT_GPIO_sema_mutex_take
       1  CleanDeviceCmdSource
       1  LastBTStatus
       1  NeedPairing
      40  mBTHandleParams
          mBTHandleComd
          pBTHandle_ObjCtrl
       2  mBTHandlerPowerOnStamp
       2  mBTHandlerStamp

 
     5 bytes in section .bss
    66 bytes in section .data
    20 bytes in section .rodata
 2 082 bytes in section .text
 
 2 082 bytes of CODE  memory
    20 bytes of CONST memory
    71 bytes of DATA  memory

Errors: none
Warnings: 4

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:26:16 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\STM32_USB_HOST_Library\Core\src\usbh_core.c #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\STM32_USB_HOST_Library\Core\src\usbh_core.c #
#                     -D S4051A -D DEBUG -D FREE_RTOS -D STM32F40_41xxx -D    #
#                    USE_STM324xG_EVAL -D USE_STDPERIPH_DRIVER -D             #
#                    __ARM_CORTEX_MX__ -D IAR_ARM_CM4F -D USE_USB_OTG_FS      #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applicati #
#                    on\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Ap #
#                    plication\Obj\ --debug --endian=little --cpu=Cortex-M4   #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\usbh_core.lst                                         #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\usbh_core.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Libraries\STM32_USB_HOST_Library\Core\src\usbh_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_core.c 
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    19-March-2012
      7            * @brief   This file implements the functions for the core state machine process
      8            *          the enumeration and the control transfer process
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     13            *
     14            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     15            * You may not use this file except in compliance with the License.
     16            * You may obtain a copy of the License at:
     17            *
     18            *        http://www.st.com/software_license_agreement_liberty_v2
     19            *
     20            * Unless required by applicable law or agreed to in writing, software 
     21            * distributed under the License is distributed on an "AS IS" BASIS, 
     22            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     23            * See the License for the specific language governing permissions and
     24            * limitations under the License.
     25            *
     26            ******************************************************************************
     27            */ 
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "freertos_conf.h"
     30          #include "freertos_task.h"
     31          
     32          #include "usbh_ioreq.h"
     33          #include "usb_bsp.h"
     34          #include "usbh_hcs.h"
     35          #include "usbh_stdreq.h"
     36          #include "usbh_core.h"
     37          #include "usb_hcd_int.h"
     38          
     39          
     40          #define USBH_CORE_100MS TASK_MSEC2TICKS(100)
     41          
     42          portTickType duration;
     43          int16_t HostDeviceCount = 0;
     44          
     45          
     46          /** @addtogroup USBH_LIB
     47            * @{
     48            */
     49          
     50          /** @addtogroup USBH_LIB_CORE
     51          * @{
     52          */
     53          
     54          /** @defgroup USBH_CORE 
     55            * @brief TThis file handles the basic enumaration when a device is connected 
     56            *          to the host.
     57            * @{
     58            */ 
     59          
     60          /** @defgroup USBH_CORE_Private_TypesDefinitions
     61            * @{
     62            */ 
     63          uint8_t USBH_Disconnected (USB_OTG_CORE_HANDLE *pdev); 
     64          uint8_t USBH_Connected (USB_OTG_CORE_HANDLE *pdev); 
     65          uint8_t USBH_SOF (USB_OTG_CORE_HANDLE *pdev); 
     66          
     67          USBH_HCD_INT_cb_TypeDef USBH_HCD_INT_cb = 
     68          {
     69            USBH_SOF,
     70            USBH_Connected, 
     71            USBH_Disconnected,    
     72          };
     73          
     74          USBH_HCD_INT_cb_TypeDef  *USBH_HCD_INT_fops = &USBH_HCD_INT_cb;
     75          /**
     76            * @}
     77            */ 
     78          
     79          
     80          /** @defgroup USBH_CORE_Private_Defines
     81            * @{
     82            */ 
     83          /**
     84            * @}
     85            */ 
     86          
     87          
     88          /** @defgroup USBH_CORE_Private_Macros
     89            * @{
     90            */ 
     91          /**
     92            * @}
     93            */ 
     94          
     95          
     96          /** @defgroup USBH_CORE_Private_Variables
     97            * @{
     98            */ 
     99          /**
    100            * @}
    101            */ 
    102          
    103          
    104          /** @defgroup USBH_CORE_Private_FunctionPrototypes
    105            * @{
    106            */
    107          static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost);
    108          USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost);
    109          
    110          /**
    111            * @}
    112            */ 
    113          
    114          
    115          /** @defgroup USBH_CORE_Private_Functions
    116            * @{
    117            */ 
    118          
    119          
    120          /**
    121            * @brief  USBH_Connected
    122            *         USB Connect callback function from the Interrupt. 
    123            * @param  selected device
    124            * @retval Status
    125          */
    126          uint8_t USBH_Connected (USB_OTG_CORE_HANDLE *pdev)
    127          {
    128            pdev->host.ConnSts = 1;
    129            return 0;
    130          }
    131          
    132          /**
    133          * @brief  USBH_Disconnected
    134          *         USB Disconnect callback function from the Interrupt. 
    135          * @param  selected device
    136          * @retval Status
    137          */
    138          
    139          uint8_t USBH_Disconnected (USB_OTG_CORE_HANDLE *pdev)
    140          {
    141            pdev->host.ConnSts = 0;
    142            return 0;  
    143          }
    144          
    145          /**
    146            * @brief  USBH_SOF
    147            *         USB SOF callback function from the Interrupt. 
    148            * @param  selected device
    149            * @retval Status
    150            */
    151          
    152          uint8_t USBH_SOF (USB_OTG_CORE_HANDLE *pdev)
    153          {
    154            /* This callback could be used to implement a scheduler process */
    155            return 0;  
    156          }
    157          /**
    158            * @brief  USBH_Init
    159            *         Host hardware and stack initializations 
    160            * @param  class_cb: Class callback structure address
    161            * @param  usr_cb: User callback structure address
    162            * @retval None
    163            */
    164          void USBH_Init(USB_OTG_CORE_HANDLE *pdev,
    165                         USB_OTG_CORE_ID_TypeDef coreID,
    166                         USBH_HOST *phost,               
    167                         USBH_Class_cb_TypeDef *class_cb, 
    168                         USBH_Usr_cb_TypeDef *usr_cb)
    169          {
    170               
    171            /* Hardware Init */
    172            USB_OTG_BSP_Init(pdev);  
    173            
    174            /* configure GPIO pin used for switching VBUS power */
    175            USB_OTG_BSP_ConfigVBUS(0);  
    176            
    177            
    178            /* Host de-initializations */
    179            USBH_DeInit(pdev, phost);
    180            
    181            /*Register class and user callbacks */
    182            phost->class_cb = class_cb;
    183            phost->usr_cb = usr_cb;  
    184              
    185            /* Start the USB OTG core */     
    186             HCD_Init(pdev , coreID);
    187             
    188            /* Upon Init call usr call back */
    189            phost->usr_cb->Init();
    190            
    191            /* Enable Interrupts */
    192            //USB_OTG_BSP_EnableInterrupt(pdev);
    193          
    194            USB_OTG_BSP_Host_EnableInterrupt(pdev); /*Smith JUNE 14 2013: When USB is set to HOST mode, its priority should be higher than timer.*/
    195          }
    196          
    197          /**
    198            * @brief  USBH_DeInit 
    199            *         Re-Initialize Host
    200            * @param  None 
    201            * @retval status: USBH_Status
    202            */
    203          USBH_Status USBH_DeInit(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
    204          {
    205            /* Software Init */
    206            
    207            phost->gState = HOST_IDLE;
    208            phost->gStateBkp = HOST_IDLE; 
    209            phost->EnumState = ENUM_IDLE;
    210            phost->RequestState = CMD_SEND;  
    211            
    212            phost->Control.state = CTRL_SETUP;
    213            phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
    214            
    215            phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
    216            phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
    217            
    218            USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
    219            USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
    220            return USBH_OK;
    221          }
    222          
    223          /**
    224          * @brief  USBH_Process
    225          *         USB Host core main state machine process
    226          * @param  None 
    227          * @retval None
    228          */
    229          HOST_State USBH_Process(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
    230          {
    231              volatile USBH_Status status = USBH_FAIL;
    232              static portTickType xTimeTick = 0;
    233            
    234            /* check for Host port events */
    235            if ((HCD_IsDeviceConnected(pdev) == 0)&& (phost->gState != HOST_IDLE)) 
    236            {
    237              if(phost->gState != HOST_DEV_DISCONNECTED) 
    238              {
    239                  phost->gState = HOST_DEV_DISCONNECTED;
    240              }
    241            }
    242              
    243            switch (phost->gState)
    244            {
    245            
    246            case HOST_IDLE :
    247              
    248              if (HCD_IsDeviceConnected(pdev))  
    249              {
    250                  vTaskDelay( USBH_CORE_100MS );
    251                  phost->gState = HOST_DEV_ATTACHED;
    252                  xTimeTick = xTaskGetTickCount( );
    253                  HostDeviceCount = 0;
    254              }
    255          	else
    256          	{
    257                  duration = ( xTaskGetTickCount( ) - xTimeTick );
    258                  xTimeTick = xTaskGetTickCount( );
    259                  if ( (duration/portTICK_RATE_MS) > TASK_MSEC2TICKS(10) )
    260                  {
    261                      HostDeviceCount ++;
    262                  }
    263                  
    264          		/*Smith: Don't modify HostDeviceCount that interfere USB flash driver compatibility*/
    265          		if ( HostDeviceCount >= 220 ) 
    266          		{
    267          			HostDeviceCount = 0;
    268          			phost->gState = HOST_ERROR_STATE;
    269          		}
    270          	}
    271              break;
    272             
    273            case HOST_DEV_ATTACHED :
    274              
    275              phost->usr_cb->DeviceAttached();
    276              phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
    277              phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
    278            
    279              /* Reset USB Device */
    280              if ( HCD_ResetPort(pdev) == 0)
    281              {
    282                phost->usr_cb->ResetDevice();
    283                /*  Wait for USB USBH_ISR_PrtEnDisableChange()  
    284                Host is Now ready to start the Enumeration 
    285                */
    286                
    287                phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
    288                
    289                phost->gState = HOST_ENUMERATION;
    290                phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
    291                  
    292                /* Open Control pipes */
    293                USBH_Open_Channel (pdev,
    294                                     phost->Control.hc_num_in,
    295                                     phost->device_prop.address,
    296                                     phost->device_prop.speed,
    297                                     EP_TYPE_CTRL,
    298                                     phost->Control.ep0size); 
    299                
    300                /* Open Control pipes */
    301                USBH_Open_Channel (pdev,
    302                                     phost->Control.hc_num_out,
    303                                     phost->device_prop.address,
    304                                     phost->device_prop.speed,
    305                                     EP_TYPE_CTRL,
    306                                     phost->Control.ep0size);          
    307             }
    308              break;
    309              
    310            case HOST_ENUMERATION:     
    311              /* Check for enumeration status */  
    312              if ( USBH_HandleEnum(pdev , phost) == USBH_OK)
    313              { 
    314                /* The function shall return USBH_OK when full enumeration is complete */
    315                
    316                /* user callback for end of device basic enumeration */
    317                phost->usr_cb->EnumerationDone();
    318                
    319                phost->gState  = HOST_USR_INPUT;    
    320              }
    321              break;
    322              
    323            case HOST_USR_INPUT:    
    324              /*The function should return user response true to move to class state */
    325              if ( phost->usr_cb->UserInput() == USBH_USR_RESP_OK)
    326              {
    327                if((phost->class_cb->Init(pdev, phost))\
    328                  == USBH_OK)
    329                {
    330                  phost->gState  = HOST_CLASS_REQUEST;     
    331                }     
    332              }   
    333              break;
    334              
    335            case HOST_CLASS_REQUEST:  
    336              /* process class standard contol requests state machine */ 
    337              status = phost->class_cb->Requests(pdev, phost);
    338              
    339               if(status == USBH_OK)
    340               {
    341                 phost->gState  = HOST_CLASS;
    342               }  
    343               
    344               else
    345               {
    346                 USBH_ErrorHandle(phost, status);
    347               }
    348           
    349              
    350              break;    
    351            case HOST_CLASS:   
    352              /* process class state machine */
    353              status = phost->class_cb->Machine(pdev, phost);
    354              USBH_ErrorHandle(phost, status);
    355              break;       
    356              
    357              case HOST_CTRL_XFER:
    358              {  
    359                  /* process control transfer state machine */
    360                  USBH_HandleControl(pdev, phost);
    361              }    
    362                  break;
    363              
    364            case HOST_SUSPENDED:
    365              break;
    366            
    367            case HOST_ERROR_STATE:
    368              /* Re-Initilaize Host for new Enumeration */
    369              USBH_DeInit(pdev, phost);
    370              phost->usr_cb->DeInit();
    371              phost->class_cb->DeInit(pdev, &phost->device_prop);
    372              break;
    373              
    374            case HOST_DEV_DISCONNECTED :
    375              
    376              /* Manage User disconnect operations*/
    377              phost->usr_cb->DeviceDisconnected();
    378              
    379              /* Re-Initilaize Host for new Enumeration */
    380              USBH_DeInit(pdev, phost);
    381              phost->usr_cb->DeInit();
    382              phost->class_cb->DeInit(pdev, &phost->device_prop); 
    383              USBH_DeAllocate_AllChannel(pdev);  
    384              phost->gState = HOST_IDLE;
    385              
    386              break;
    387              
    388            default :
    389              break;
    390            }
    391          
    392          	return phost->gState; /*smith implemented*/
    393          }
    394          
    395          
    396          /**
    397            * @brief  USBH_ErrorHandle 
    398            *         This function handles the Error on Host side.
    399            * @param  errType : Type of Error or Busy/OK state
    400            * @retval None
    401            */
    402          void USBH_ErrorHandle(USBH_HOST *phost, USBH_Status errType)
    403          {
    404            /* Error unrecovered or not supported device speed */
    405            if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
    406                 (errType == USBH_UNRECOVERED_ERROR) )
    407            {
    408              phost->usr_cb->UnrecoveredError(); 
    409              phost->gState = HOST_ERROR_STATE;   
    410            }  
    411            /* USB host restart requested from application layer */
    412            else if(errType == USBH_APPLY_DEINIT)
    413            {
    414              phost->gState = HOST_ERROR_STATE;  
    415              /* user callback for initalization */
    416              phost->usr_cb->Init();
    417            } 
    418          }
    419          
    420          
    421          /**
    422            * @brief  USBH_HandleEnum 
    423            *         This function includes the complete enumeration process
    424            * @param  pdev: Selected device
    425            * @retval USBH_Status
    426            */
    427          static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
    428          {
    429            USBH_Status Status = USBH_BUSY;  
    430            uint8_t Local_Buffer[64];
    431            
    432            switch (phost->EnumState)
    433            {
    434            case ENUM_IDLE:  
    435              /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
    436              if ( USBH_Get_DevDesc(pdev , phost, 8) == USBH_OK)
    437              {
    438                phost->Control.ep0size = phost->device_prop.Dev_Desc.bMaxPacketSize;
    439                
    440                /* Issue Reset  */
    441                HCD_ResetPort(pdev);
    442                phost->EnumState = ENUM_GET_FULL_DEV_DESC;
    443                
    444                /* modify control channels configuration for MaxPacket size */
    445                USBH_Modify_Channel (pdev,
    446                                     phost->Control.hc_num_out,
    447                                     0,
    448                                     0,
    449                                     0,
    450                                     phost->Control.ep0size);
    451                
    452                USBH_Modify_Channel (pdev,
    453                                     phost->Control.hc_num_in,
    454                                     0,
    455                                     0,
    456                                     0,
    457                                     phost->Control.ep0size);      
    458              }
    459              break;
    460              
    461            case ENUM_GET_FULL_DEV_DESC:  
    462              /* Get FULL Device Desc  */
    463              if ( USBH_Get_DevDesc(pdev, phost, USB_DEVICE_DESC_SIZE)\
    464                == USBH_OK)
    465              {
    466                /* user callback for device descriptor available */
    467                phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
    468                phost->EnumState = ENUM_SET_ADDR;
    469              }
    470              break;
    471             
    472            case ENUM_SET_ADDR: 
    473              /* set address */
    474              if ( USBH_SetAddress(pdev, phost, USBH_DEVICE_ADDRESS) == USBH_OK)
    475              {
    476                USB_OTG_BSP_mDelay(2);
    477                phost->device_prop.address = USBH_DEVICE_ADDRESS;
    478                
    479                /* user callback for device address assigned */
    480                phost->usr_cb->DeviceAddressAssigned();
    481                phost->EnumState = ENUM_GET_CFG_DESC;
    482                
    483                /* modify control channels to update device address */
    484                USBH_Modify_Channel (pdev,
    485                                     phost->Control.hc_num_in,
    486                                     phost->device_prop.address,
    487                                     0,
    488                                     0,
    489                                     0);
    490                
    491                USBH_Modify_Channel (pdev,
    492                                     phost->Control.hc_num_out,
    493                                     phost->device_prop.address,
    494                                     0,
    495                                     0,
    496                                     0);         
    497              }
    498              break;
    499              
    500            case ENUM_GET_CFG_DESC:  
    501              /* get standard configuration descriptor */
    502              if ( USBH_Get_CfgDesc(pdev, 
    503                                    phost,
    504                                    USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
    505              {
    506                phost->EnumState = ENUM_GET_FULL_CFG_DESC;
    507              }
    508              break;
    509              
    510            case ENUM_GET_FULL_CFG_DESC:  
    511              /* get FULL config descriptor (config, interface, endpoints) */
    512              if (USBH_Get_CfgDesc(pdev, 
    513                                   phost,
    514                                   phost->device_prop.Cfg_Desc.wTotalLength) == USBH_OK)
    515              {
    516                /* User callback for configuration descriptors available */
    517                phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
    518                                                                phost->device_prop.Itf_Desc,
    519                                                                phost->device_prop.Ep_Desc[0]);
    520                
    521                phost->EnumState = ENUM_GET_MFC_STRING_DESC;
    522              }
    523              break;
    524              
    525            case ENUM_GET_MFC_STRING_DESC:  
    526              if (phost->device_prop.Dev_Desc.iManufacturer != 0)
    527              { /* Check that Manufacturer String is available */
    528                
    529                if ( USBH_Get_StringDesc(pdev,
    530                                         phost,
    531                                         phost->device_prop.Dev_Desc.iManufacturer, 
    532                                         Local_Buffer , 
    533                                         0xff) == USBH_OK)
    534                {
    535                  /* User callback for Manufacturing string */
    536                  phost->usr_cb->ManufacturerString(Local_Buffer);
    537                  phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
    538                }
    539              }
    540              else
    541              {
    542                phost->usr_cb->ManufacturerString("N/A");      
    543                phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
    544              }
    545              break;
    546              
    547            case ENUM_GET_PRODUCT_STRING_DESC:   
    548              if (phost->device_prop.Dev_Desc.iProduct != 0)
    549              { /* Check that Product string is available */
    550                if ( USBH_Get_StringDesc(pdev,
    551                                         phost,
    552                                         phost->device_prop.Dev_Desc.iProduct, 
    553                                         Local_Buffer, 
    554                                         0xff) == USBH_OK)
    555                {
    556                  /* User callback for Product string */
    557                  phost->usr_cb->ProductString(Local_Buffer);
    558                  phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
    559                }
    560              }
    561              else
    562              {
    563                phost->usr_cb->ProductString("N/A");
    564                phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
    565              } 
    566              break;
    567              
    568            case ENUM_GET_SERIALNUM_STRING_DESC:   
    569              if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
    570              { /* Check that Serial number string is available */    
    571                if ( USBH_Get_StringDesc(pdev, 
    572                                         phost,
    573                                         phost->device_prop.Dev_Desc.iSerialNumber, 
    574                                         Local_Buffer, 
    575                                         0xff) == USBH_OK)
    576                {
    577                  /* User callback for Serial number string */
    578                  phost->usr_cb->SerialNumString(Local_Buffer);
    579                  phost->EnumState = ENUM_SET_CONFIGURATION;
    580                }
    581              }
    582              else
    583              {
    584                phost->usr_cb->SerialNumString("N/A");      
    585                phost->EnumState = ENUM_SET_CONFIGURATION;
    586              }  
    587              break;
    588                
    589            case ENUM_SET_CONFIGURATION:
    590              /* set configuration  (default config) */
    591              if (USBH_SetCfg(pdev, 
    592                              phost,
    593                              phost->device_prop.Cfg_Desc.bConfigurationValue) == USBH_OK)
    594              {
    595                phost->EnumState = ENUM_DEV_CONFIGURED;
    596              }
    597              break;
    598          
    599              
    600            case ENUM_DEV_CONFIGURED:
    601              /* user callback for enumeration done */
    602              Status = USBH_OK;
    603              break;
    604              
    605            default:
    606              break;
    607            }  
    608            return Status;
    609          }
    610          
    611          
    612          /**
    613            * @brief  USBH_HandleControl
    614            *         Handles the USB control transfer state machine
    615            * @param  pdev: Selected device
    616            * @retval Status
    617            */
    618          USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
    619          {
    620            uint8_t direction;  
    621            static uint16_t timeout = 0;
    622            USBH_Status status = USBH_OK;
    623            URB_STATE URB_Status = URB_IDLE;
    624            
    625            phost->Control.status = CTRL_START;
    626          
    627            
    628            switch (phost->Control.state)
    629            {
    630            case CTRL_SETUP:
    631              /* send a SETUP packet */
    632              USBH_CtlSendSetup     (pdev, 
    633          	                   phost->Control.setup.d8 , 
    634          	                   phost->Control.hc_num_out);  
    635              phost->Control.state = CTRL_SETUP_WAIT;  
    636              break; 
    637              
    638            case CTRL_SETUP_WAIT:
    639              
    640              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out); 
    641              /* case SETUP packet sent successfully */
    642              if(URB_Status == URB_DONE)
    643              { 
    644                direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
    645                
    646                /* check if there is a data stage */
    647                if (phost->Control.setup.b.wLength.w != 0 )
    648                {        
    649                  timeout = DATA_STAGE_TIMEOUT;
    650                  if (direction == USB_D2H)
    651                  {
    652                    /* Data Direction is IN */
    653                    phost->Control.state = CTRL_DATA_IN;
    654                  }
    655                  else
    656                  {
    657                    /* Data Direction is OUT */
    658                    phost->Control.state = CTRL_DATA_OUT;
    659                  } 
    660                }
    661                /* No DATA stage */
    662                else
    663                {
    664                  timeout = NODATA_STAGE_TIMEOUT;
    665                  
    666                  /* If there is No Data Transfer Stage */
    667                  if (direction == USB_D2H)
    668                  {
    669                    /* Data Direction is IN */
    670                    phost->Control.state = CTRL_STATUS_OUT;
    671                  }
    672                  else
    673                  {
    674                    /* Data Direction is OUT */
    675                    phost->Control.state = CTRL_STATUS_IN;
    676                  } 
    677                }          
    678                /* Set the delay timer to enable timeout for data stage completion */
    679                phost->Control.timer = HCD_GetCurrentFrame(pdev);
    680              }
    681              else if(URB_Status == URB_ERROR)
    682              {
    683                phost->Control.state = CTRL_ERROR;     
    684                phost->Control.status = CTRL_XACTERR;
    685              }    
    686              break;
    687              
    688            case CTRL_DATA_IN:  
    689              /* Issue an IN token */ 
    690              USBH_CtlReceiveData(pdev,
    691                                  phost->Control.buff, 
    692                                  phost->Control.length,
    693                                  phost->Control.hc_num_in);
    694           
    695              phost->Control.state = CTRL_DATA_IN_WAIT;
    696              break;    
    697              
    698            case CTRL_DATA_IN_WAIT:
    699              
    700              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
    701              
    702              /* check is DATA packet transfered successfully */
    703              if  (URB_Status == URB_DONE)
    704              { 
    705                phost->Control.state = CTRL_STATUS_OUT;
    706              }
    707             
    708              /* manage error cases*/
    709              if  (URB_Status == URB_STALL) 
    710              { 
    711                /* In stall case, return to previous machine state*/
    712                phost->gState =   phost->gStateBkp;
    713              }   
    714              else if (URB_Status == URB_ERROR)
    715              {
    716                /* Device error */
    717                phost->Control.state = CTRL_ERROR;    
    718              }
    719              else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
    720              {
    721                /* timeout for IN transfer */
    722                phost->Control.state = CTRL_ERROR; 
    723              }   
    724              break;
    725              
    726            case CTRL_DATA_OUT:
    727              /* Start DATA out transfer (only one DATA packet)*/
    728              pdev->host.hc[phost->Control.hc_num_out].toggle_out = 1; 
    729                  
    730              USBH_CtlSendData (pdev,
    731                                phost->Control.buff, 
    732                                phost->Control.length , 
    733                                phost->Control.hc_num_out);
    734              
    735          
    736          
    737          
    738              
    739              phost->Control.state = CTRL_DATA_OUT_WAIT;
    740              break;
    741              
    742            case CTRL_DATA_OUT_WAIT:
    743              
    744              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);     
    745              if  (URB_Status == URB_DONE)
    746              { /* If the Setup Pkt is sent successful, then change the state */
    747                phost->Control.state = CTRL_STATUS_IN;
    748              }
    749              
    750              /* handle error cases */
    751              else if  (URB_Status == URB_STALL) 
    752              { 
    753                /* In stall case, return to previous machine state*/
    754                phost->gState =   phost->gStateBkp;
    755                phost->Control.state = CTRL_STALLED;  
    756              } 
    757              else if  (URB_Status == URB_NOTREADY)
    758              { 
    759                /* Nack received from device */
    760                phost->Control.state = CTRL_DATA_OUT;
    761              }    
    762              else if (URB_Status == URB_ERROR)
    763              {
    764                /* device error */
    765                phost->Control.state = CTRL_ERROR;      
    766              } 
    767              break;
    768              
    769              
    770            case CTRL_STATUS_IN:
    771              /* Send 0 bytes out packet */
    772              USBH_CtlReceiveData (pdev,
    773                                   0,
    774                                   0,
    775                                   phost->Control.hc_num_in);
    776              
    777              phost->Control.state = CTRL_STATUS_IN_WAIT;
    778              
    779              break;
    780              
    781            case CTRL_STATUS_IN_WAIT:
    782              
    783              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
    784              
    785              if  ( URB_Status == URB_DONE)
    786              { /* Control transfers completed, Exit the State Machine */
    787                phost->gState =   phost->gStateBkp;
    788                phost->Control.state = CTRL_COMPLETE;
    789              }
    790              
    791              else if (URB_Status == URB_ERROR)
    792              {
    793                phost->Control.state = CTRL_ERROR;  
    794              }
    795              
    796              else if((HCD_GetCurrentFrame(pdev)\
    797                - phost->Control.timer) > timeout)
    798              {
    799                phost->Control.state = CTRL_ERROR; 
    800              }
    801               else if(URB_Status == URB_STALL)
    802              {
    803                /* Control transfers completed, Exit the State Machine */
    804                phost->gState =   phost->gStateBkp;
    805                phost->Control.status = CTRL_STALL;
    806                status = USBH_NOT_SUPPORTED;
    807              }
    808              break;
    809              
    810            case CTRL_STATUS_OUT:
    811              pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
    812              USBH_CtlSendData (pdev,
    813                                0,
    814                                0,
    815                                phost->Control.hc_num_out);
    816              
    817              phost->Control.state = CTRL_STATUS_OUT_WAIT;
    818              break;
    819              
    820            case CTRL_STATUS_OUT_WAIT: 
    821              
    822              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
    823              if  (URB_Status == URB_DONE)
    824              { 
    825                phost->gState =   phost->gStateBkp; 
    826                phost->Control.state = CTRL_COMPLETE; 
    827              }
    828              else if  (URB_Status == URB_NOTREADY)
    829              { 
    830                phost->Control.state = CTRL_STATUS_OUT;
    831              }      
    832              else if (URB_Status == URB_ERROR)
    833              {
    834                phost->Control.state = CTRL_ERROR;      
    835              }
    836              break;
    837              
    838            case CTRL_ERROR:
    839              /* 
    840              After a halt condition is encountered or an error is detected by the 
    841              host, a control endpoint is allowed to recover by accepting the next Setup 
    842              PID; i.e., recovery actions via some other pipe are not required for control
    843              endpoints. For the Default Control Pipe, a device reset will ultimately be 
    844              required to clear the halt or error condition if the next Setup PID is not 
    845              accepted.
    846              */
    847              if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
    848              {
    849                /* Do the transmission again, starting from SETUP Packet */
    850                phost->Control.state = CTRL_SETUP; 
    851              }
    852              else
    853              {
    854                phost->Control.status = CTRL_FAIL;
    855                phost->gState =   phost->gStateBkp;
    856                
    857                status = USBH_FAIL;
    858              }
    859              break;
    860              
    861            default:
    862              break;
    863            }
    864            return status;
    865          }
    866          
    867          
    868          /**
    869          * @}
    870          */ 
    871          
    872          /**
    873          * @}
    874          */ 
    875          
    876          /**
    877          * @}
    878          */
    879          
    880          /**
    881          * @}
    882          */ 
    883          
    884          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    885          
    886          
    887          
    888          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  USBH_Connected
       16  USBH_DeInit
             16 -> USBH_Free_Channel
        0  USBH_Disconnected
        8  USBH_ErrorHandle
              0 -- Indirect call
              8 -- Indirect call
       24  USBH_HandleControl
             24 -> HCD_GetCurrentFrame
             24 -> HCD_GetURB_State
             24 -> USBH_CtlReceiveData
             24 -> USBH_CtlSendData
             24 -> USBH_CtlSendSetup
       96  USBH_HandleEnum
             96 -- Indirect call
             96 -> HCD_ResetPort
             96 -> USBH_Get_CfgDesc
             96 -> USBH_Get_DevDesc
             96 -> USBH_Get_StringDesc
             96 -> USBH_Modify_Channel
             96 -> USBH_SetAddress
             96 -> USBH_SetCfg
             96 -> USB_OTG_BSP_mDelay
       24  USBH_Init
             24 -- Indirect call
             24 -> HCD_Init
             24 -> USBH_DeInit
             24 -> USB_OTG_BSP_ConfigVBUS
              0 -> USB_OTG_BSP_Host_EnableInterrupt
             24 -> USB_OTG_BSP_Init
       24  USBH_Process
             24 -- Indirect call
             24 -> HCD_GetCurrentSpeed
             24 -> HCD_IsDeviceConnected
             24 -> HCD_ResetPort
             24 -> USBH_Alloc_Channel
             24 -> USBH_DeAllocate_AllChannel
             24 -> USBH_DeInit
             24 -> USBH_ErrorHandle
             24 -> USBH_HandleControl
             24 -> USBH_HandleEnum
             24 -> USBH_Open_Channel
             24 -> vTaskDelay
             24 -> xTaskGetTickCount
        0  USBH_SOF


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "N/A">
       4  ??DataTable2
       4  ??DataTable3
       4  ??DataTable3_1
       8  ?Subroutine0
       8  ?Subroutine1
      12  ?Subroutine2
      18  ?Subroutine3
      14  ?Subroutine4
      12  HostDeviceCount
          duration
          xTimeTick
       4  USBH_Connected
      56  USBH_DeInit
       2  USBH_Disconnected
      48  USBH_ErrorHandle
      12  USBH_HCD_INT_cb
       4  USBH_HCD_INT_fops
     422  USBH_HandleControl
     392  USBH_HandleEnum
      64  USBH_Init
     414  USBH_Process
       4  USBH_SOF
       2  timeout

 
    14 bytes in section .bss
    16 bytes in section .data
     4 bytes in section .rodata
 1 478 bytes in section .text
 
 1 478 bytes of CODE  memory
     4 bytes of CONST memory
    30 bytes of DATA  memory

Errors: none
Warnings: none

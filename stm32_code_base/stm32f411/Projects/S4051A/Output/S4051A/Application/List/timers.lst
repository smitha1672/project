###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:24:17 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\FreeRTOS\Source\timers.c                    #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\FreeRTOS\Source\timers.c -D S4051A -D       #
#                    DEBUG -D FREE_RTOS -D STM32F40_41xxx -D                  #
#                    USE_STM324xG_EVAL -D USE_STDPERIPH_DRIVER -D             #
#                    __ARM_CORTEX_MX__ -D IAR_ARM_CM4F -D USE_USB_OTG_FS      #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applicati #
#                    on\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Ap #
#                    plication\Obj\ --debug --endian=little --cpu=Cortex-M4   #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\timers.lst                                            #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\timers.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Libraries\FreeRTOS\Source\timers.c
      1          /*
      2              FreeRTOS V8.0.0:rc2 - Copyright (C) 2014 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              ***************************************************************************
      8               *                                                                       *
      9               *    FreeRTOS provides completely free yet professionally developed,    *
     10               *    robust, strictly quality controlled, supported, and cross          *
     11               *    platform software that has become a de facto standard.             *
     12               *                                                                       *
     13               *    Help yourself get started quickly and support the FreeRTOS         *
     14               *    project by purchasing a FreeRTOS tutorial book, reference          *
     15               *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
     16               *                                                                       *
     17               *    Thank you!                                                         *
     18               *                                                                       *
     19              ***************************************************************************
     20          
     21              This file is part of the FreeRTOS distribution.
     22          
     23              FreeRTOS is free software; you can redistribute it and/or modify it under
     24              the terms of the GNU General Public License (version 2) as published by the
     25              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     26          
     27              >>! NOTE: The modification to the GPL is included to allow you to distribute
     28              >>! a combined work that includes FreeRTOS without being obliged to provide
     29              >>! the source code for proprietary components outside of the FreeRTOS
     30              >>! kernel.
     31          
     32              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     33              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     34              FOR A PARTICULAR PURPOSE.  Full license text is available from the following
     35              link: http://www.freertos.org/a00114.html
     36          
     37              1 tab == 4 spaces!
     38          
     39              ***************************************************************************
     40               *                                                                       *
     41               *    Having a problem?  Start by reading the FAQ "My application does   *
     42               *    not run, what could be wrong?"                                     *
     43               *                                                                       *
     44               *    http://www.FreeRTOS.org/FAQHelp.html                               *
     45               *                                                                       *
     46              ***************************************************************************
     47          
     48              http://www.FreeRTOS.org - Documentation, books, training, latest versions,
     49              license and Real Time Engineers Ltd. contact details.
     50          
     51              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     52              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     53              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     54          
     55              http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
     56              Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
     57              licenses offer ticketed support, indemnification and middleware.
     58          
     59              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     60              engineered and independently SIL3 certified version for use in safety and
     61              mission critical applications that require provable dependability.
     62          
     63              1 tab == 4 spaces!
     64          */
     65          
     66          /* Standard includes. */
     67          #include <stdlib.h>
     68          
     69          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     70          all the API functions to use the MPU wrappers.  That should only be done when
     71          task.h is included from an application file. */
     72          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     73          
     74          #include "FreeRTOS.h"
     75          #include "task.h"
     76          #include "queue.h"
     77          #include "timers.h"
     78          
     79          #if ( INCLUDE_xTimerPendFunctionCallFromISR == 1 ) && ( configUSE_TIMERS == 0 )
     80          	#error configUSE_TIMERS must be set to 1 to make the INCLUDE_xTimerPendFunctionCallFromISR() function available.
     81          #endif
     82          
     83          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     84          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     85          header files above, but not in this file, in order to generate the correct
     86          privileged Vs unprivileged linkage and placement. */
     87          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     88          
     89          
     90          /* This entire source file will be skipped if the application is not configured
     91          to include software timer functionality.  This #if is closed at the very bottom
     92          of this file.  If you want to include software timer functionality then ensure
     93          configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
     94          #if ( configUSE_TIMERS == 1 )
     95          
     96          /* Misc definitions. */
     97          #define tmrNO_DELAY		( TickType_t ) 0U
     98          
     99          /* The definition of the timers themselves. */
    100          typedef struct tmrTimerControl
    101          {
    102          	const char				*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    103          	ListItem_t				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for event management. */
    104          	TickType_t				xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
    105          	UBaseType_t				uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one-shot timer. */
    106          	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
    107          	TimerCallbackFunction_t	pxCallbackFunction;	/*<< The function that will be called when the timer expires. */
    108          } Timer_t;
    109          
    110          /* The definition of messages that can be sent and received on the timer queue.
    111          Two types of message can be queued - messages that manipulate a software timer,
    112          and messages that request the execution of a non-timer related callback.  The
    113          two message types are defined in two separate structures, xTimerParametersType
    114          and xCallbackParametersType respectively. */
    115          typedef struct tmrTimerParameters
    116          {
    117          	TickType_t			xMessageValue;		/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
    118          	Timer_t *			pxTimer;			/*<< The timer to which the command will be applied. */
    119          } TimerParameter_t;
    120          
    121          
    122          typedef struct tmrCallbackParameters
    123          {
    124          	PendedFunction_t	pxCallbackFunction;	/* << The callback function to execute. */
    125          	void *pvParameter1;						/* << The value that will be used as the callback functions first parameter. */
    126          	uint32_t ulParameter2;					/* << The value that will be used as the callback functions second parameter. */
    127          } CallbackParameters_t;
    128          
    129          /* The structure that contains the two message types, along with an identifier
    130          that is used to determine which message type is valid. */
    131          typedef struct tmrTimerQueueMessage
    132          {
    133          	BaseType_t			xMessageID;			/*<< The command being sent to the timer service task. */
    134          	union
    135          	{
    136          		TimerParameter_t xTimerParameters;
    137          
    138          		/* Don't include xCallbackParameters if it is not going to be used as
    139          		it makes the structure (and therefore the timer queue) larger. */
    140          		#if ( INCLUDE_xTimerPendFunctionCallFromISR == 1 )
    141          			CallbackParameters_t xCallbackParameters;
    142          		#endif /* INCLUDE_xTimerPendFunctionCallFromISR */
    143          	} u;
    144          } DaemonTaskMessage_t;
    145          
    146          /*lint -e956 A manual analysis and inspection has been used to determine which
    147          static variables must be declared volatile. */
    148          
    149          /* The list in which active timers are stored.  Timers are referenced in expire
    150          time order, with the nearest expiry time at the front of the list.  Only the
    151          timer service task is allowed to access these lists. */
    152          PRIVILEGED_DATA static List_t xActiveTimerList1;
    153          PRIVILEGED_DATA static List_t xActiveTimerList2;
    154          PRIVILEGED_DATA static List_t *pxCurrentTimerList;
    155          PRIVILEGED_DATA static List_t *pxOverflowTimerList;
    156          
    157          /* A queue that is used to send commands to the timer service task. */
    158          PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
    159          
    160          #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
    161          
    162          	PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
    163          
    164          #endif
    165          
    166          /*lint +e956 */
    167          
    168          /*-----------------------------------------------------------*/
    169          
    170          /*
    171           * Initialise the infrastructure used by the timer service task if it has not
    172           * been initialised already.
    173           */
    174          static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
    175          
    176          /*
    177           * The timer service task (daemon).  Timer functionality is controlled by this
    178           * task.  Other tasks communicate with the timer service task using the
    179           * xTimerQueue queue.
    180           */
    181          static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
    182          
    183          /*
    184           * Called by the timer service task to interpret and process a command it
    185           * received on the timer queue.
    186           */
    187          static void	prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
    188          
    189          /*
    190           * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
    191           * depending on if the expire time causes a timer counter overflow.
    192           */
    193          static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime ) PRIVILEGED_FUNCTION;
    194          
    195          /*
    196           * An active timer has reached its expire time.  Reload the timer if it is an
    197           * auto reload timer, then call its callback.
    198           */
    199          static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
    200          
    201          /*
    202           * The tick count has overflowed.  Switch the timer lists after ensuring the
    203           * current timer list does not still reference some timers.
    204           */
    205          static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
    206          
    207          /*
    208           * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
    209           * if a tick count overflow occurred since prvSampleTimeNow() was last called.
    210           */
    211          static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
    212          
    213          /*
    214           * If the timer list contains any active timers then return the expire time of
    215           * the timer that will expire first and set *pxListWasEmpty to false.  If the
    216           * timer list does not contain any timers then return 0 and set *pxListWasEmpty
    217           * to pdTRUE.
    218           */
    219          static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION;
    220          
    221          /*
    222           * If a timer has expired, process it.  Otherwise, block the timer service task
    223           * until either a timer does expire or a command is received.
    224           */
    225          static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
    226          
    227          /*-----------------------------------------------------------*/
    228          
    229          BaseType_t xTimerCreateTimerTask( void )
    230          {
    231          BaseType_t xReturn = pdFAIL;
    232          
    233          	/* This function is called when the scheduler is started if
    234          	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
    235          	timer service task has been created/initialised.  If timers have already
    236          	been created then the initialisation will already have been performed. */
    237          	prvCheckForValidListAndQueue();
    238          
    239          	if( xTimerQueue != NULL )
    240          	{
    241          		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
    242          		{
    243          			/* Create the timer task, storing its handle in xTimerTaskHandle so
    244          			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
    245          			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
    246          		}
    247          		#else
    248          		{
    249          			/* Create the timer task without storing its handle. */
    250          			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    251          		}
    252          		#endif
    253          	}
    254          	else
    255          	{
    256          		mtCOVERAGE_TEST_MARKER();
    257          	}
    258          
    259          	configASSERT( xReturn );
    260          	return xReturn;
    261          }
    262          /*-----------------------------------------------------------*/
    263          
    264          TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    265          {
    266          Timer_t *pxNewTimer;
    267          
    268          	/* Allocate the timer structure. */
    269          	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
    270          	{
    271          		pxNewTimer = NULL;
    272          	}
    273          	else
    274          	{
    275          		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    276          		if( pxNewTimer != NULL )
    277          		{
    278          			/* Ensure the infrastructure used by the timer service task has been
    279          			created/initialised. */
    280          			prvCheckForValidListAndQueue();
    281          
    282          			/* Initialise the timer structure members using the function parameters. */
    283          			pxNewTimer->pcTimerName = pcTimerName;
    284          			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    285          			pxNewTimer->uxAutoReload = uxAutoReload;
    286          			pxNewTimer->pvTimerID = pvTimerID;
    287          			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    288          			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    289          
    290          			traceTIMER_CREATE( pxNewTimer );
    291          		}
    292          		else
    293          		{
    294          			traceTIMER_CREATE_FAILED();
    295          		}
    296          	}
    297          
    298          	/* 0 is not a valid value for xTimerPeriodInTicks. */
    299          	configASSERT( ( xTimerPeriodInTicks > 0 ) );
    300          
    301          	return ( TimerHandle_t ) pxNewTimer;
    302          }
    303          /*-----------------------------------------------------------*/
    304          
    305          BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xBlockTime )
    306          {
    307          BaseType_t xReturn = pdFAIL;
    308          DaemonTaskMessage_t xMessage;
    309          
    310          	/* Send a message to the timer service task to perform a particular action
    311          	on a particular timer definition. */
    312          	if( xTimerQueue != NULL )
    313          	{
    314          		/* Send a command to the timer service task to start the xTimer timer. */
    315          		xMessage.xMessageID = xCommandID;
    316          		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    317          		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    318          
    319          		if( pxHigherPriorityTaskWoken == NULL )
    320          		{
    321          			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    322          			{
    323          				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
    324          			}
    325          			else
    326          			{
    327          				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    328          			}
    329          		}
    330          		else
    331          		{
    332          			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    333          		}
    334          
    335          		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
    336          	}
    337          	else
    338          	{
    339          		mtCOVERAGE_TEST_MARKER();
    340          	}
    341          
    342          	return xReturn;
    343          }
    344          /*-----------------------------------------------------------*/
    345          
    346          #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
    347          
    348          	TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    349          	{
    350          		/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
    351          		started, then xTimerTaskHandle will be NULL. */
    352          		configASSERT( ( xTimerTaskHandle != NULL ) );
    353          		return xTimerTaskHandle;
    354          	}
    355          
    356          #endif
    357          /*-----------------------------------------------------------*/
    358          
    359          static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
    360          {
    361          BaseType_t xResult;
    362          Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    363          
    364          	/* Remove the timer from the list of active timers.  A check has already
    365          	been performed to ensure the list is not empty. */
    366          	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    367          	traceTIMER_EXPIRED( pxTimer );
    368          
    369          	/* If the timer is an auto reload timer then calculate the next
    370          	expiry time and re-insert the timer in the list of active timers. */
    371          	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    372          	{
    373          		/* The timer is inserted into a list using a time relative to anything
    374          		other than the current time.  It will therefore be inserted into the
    375          		correct list relative to the time this task thinks it is now. */
    376          		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    377          		{
    378          			/* The timer expired before it was added to the active timer
    379          			list.  Reload it now.  */
    380          			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    381          			configASSERT( xResult );
    382          			( void ) xResult;
    383          		}
    384          		else
    385          		{
    386          			mtCOVERAGE_TEST_MARKER();
    387          		}
    388          	}
    389          	else
    390          	{
    391          		mtCOVERAGE_TEST_MARKER();
    392          	}
    393          
    394          	/* Call the timer callback. */
    395          	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    396          }
    397          /*-----------------------------------------------------------*/
    398          
    399          static void prvTimerTask( void *pvParameters )
    400          {
    401          TickType_t xNextExpireTime;
    402          BaseType_t xListWasEmpty;
    403          
    404          	/* Just to avoid compiler warnings. */
    405          	( void ) pvParameters;
    406          
    407          	for( ;; )
    408          	{
    409          		/* Query the timers list to see if it contains any timers, and if so,
    410          		obtain the time at which the next timer will expire. */
    411          		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    412          
    413          		/* If a timer has expired, process it.  Otherwise, block this task
    414          		until either a timer does expire, or a command is received. */
    415          		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    416          
    417          		/* Empty the command queue. */
    418          		prvProcessReceivedCommands();
    419          	}
    420          }
    421          /*-----------------------------------------------------------*/
    422          
    423          static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
    424          {
    425          TickType_t xTimeNow;
    426          BaseType_t xTimerListsWereSwitched;
    427          
    428          	vTaskSuspendAll();
    429          	{
    430          		/* Obtain the time now to make an assessment as to whether the timer
    431          		has expired or not.  If obtaining the time causes the lists to switch
    432          		then don't process this timer as any timers that remained in the list
    433          		when the lists were switched will have been processed within the
    434          		prvSampleTimeNow() function. */
    435          		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    436          		if( xTimerListsWereSwitched == pdFALSE )
    437          		{
    438          			/* The tick count has not overflowed, has the timer expired? */
    439          			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    440          			{
    441          				( void ) xTaskResumeAll();
    442          				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    443          			}
    444          			else
    445          			{
    446          				/* The tick count has not overflowed, and the next expire
    447          				time has not been reached yet.  This task should therefore
    448          				block to wait for the next expire time or a command to be
    449          				received - whichever comes first.  The following line cannot
    450          				be reached unless xNextExpireTime > xTimeNow, except in the
    451          				case when the current timer list is empty. */
    452          				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    453          
    454          				if( xTaskResumeAll() == pdFALSE )
    455          				{
    456          					/* Yield to wait for either a command to arrive, or the block time
    457          					to expire.  If a command arrived between the critical section being
    458          					exited and this yield then the yield will not cause the task
    459          					to block. */
    460          					portYIELD_WITHIN_API();
    461          				}
    462          				else
    463          				{
    464          					mtCOVERAGE_TEST_MARKER();
    465          				}
    466          			}
    467          		}
    468          		else
    469          		{
    470          			( void ) xTaskResumeAll();
    471          		}
    472          	}
    473          }
    474          /*-----------------------------------------------------------*/
    475          
    476          static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    477          {
    478          TickType_t xNextExpireTime;
    479          
    480          	/* Timers are listed in expiry time order, with the head of the list
    481          	referencing the task that will expire first.  Obtain the time at which
    482          	the timer with the nearest expiry time will expire.  If there are no
    483          	active timers then just set the next expire time to 0.  That will cause
    484          	this task to unblock when the tick count overflows, at which point the
    485          	timer lists will be switched and the next expiry time can be
    486          	re-assessed.  */
    487          	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    488          	if( *pxListWasEmpty == pdFALSE )
    489          	{
    490          		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    491          	}
    492          	else
    493          	{
    494          		/* Ensure the task unblocks when the tick count rolls over. */
    495          		xNextExpireTime = ( TickType_t ) 0U;
    496          	}
    497          
    498          	return xNextExpireTime;
    499          }
    500          /*-----------------------------------------------------------*/
    501          
    502          static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    503          {
    504          TickType_t xTimeNow;
    505          PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
    506          
    507          	xTimeNow = xTaskGetTickCount();
    508          
    509          	if( xTimeNow < xLastTime )
    510          	{
    511          		prvSwitchTimerLists();
    512          		*pxTimerListsWereSwitched = pdTRUE;
    513          	}
    514          	else
    515          	{
    516          		*pxTimerListsWereSwitched = pdFALSE;
    517          	}
    518          
    519          	xLastTime = xTimeNow;
    520          
    521          	return xTimeNow;
    522          }
    523          /*-----------------------------------------------------------*/
    524          
    525          static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
    526          {
    527          BaseType_t xProcessTimerNow = pdFALSE;
    528          
    529          	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    530          	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    531          
    532          	if( xNextExpiryTime <= xTimeNow )
    533          	{
    534          		/* Has the expiry time elapsed between the command to start/reset a
    535          		timer was issued, and the time the command was processed? */
    536          		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    537          		{
    538          			/* The time between a command being issued and the command being
    539          			processed actually exceeds the timers period.  */
    540          			xProcessTimerNow = pdTRUE;
    541          		}
    542          		else
    543          		{
    544          			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    545          		}
    546          	}
    547          	else
    548          	{
    549          		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    550          		{
    551          			/* If, since the command was issued, the tick count has overflowed
    552          			but the expiry time has not, then the timer must have already passed
    553          			its expiry time and should be processed immediately. */
    554          			xProcessTimerNow = pdTRUE;
    555          		}
    556          		else
    557          		{
    558          			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    559          		}
    560          	}
    561          
    562          	return xProcessTimerNow;
    563          }
    564          /*-----------------------------------------------------------*/
    565          
    566          static void	prvProcessReceivedCommands( void )
    567          {
    568          DaemonTaskMessage_t xMessage;
    569          Timer_t *pxTimer;
    570          BaseType_t xTimerListsWereSwitched, xResult;
    571          TickType_t xTimeNow;
    572          
    573          	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    574          	{
    575          		#if ( INCLUDE_xTimerPendFunctionCallFromISR == 1 )
    576          		{
    577          			if( xMessage.xMessageID == tmrCOMMAND_EXECUTE_CALLBACK )
    578          			{
    579          				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
    580          
    581          				/* The timer uses the xCallbackParameters member to request a
    582          				callback be executed.  Check the callback is not NULL. */
    583          				configASSERT( pxCallback );
    584          
    585          				/* Call the function. */
    586          				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
    587          			}
    588          			else
    589          			{
    590          				mtCOVERAGE_TEST_MARKER();
    591          			}
    592          		}
    593          		#endif /* INCLUDE_xTimerPendFunctionCallFromISR */
    594          
    595          		if( xMessage.xMessageID != tmrCOMMAND_EXECUTE_CALLBACK )
    596          		{
    597          			/* The messages uses the xTimerParameters member to work on a
    598          			software timer. */
    599          			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    600          
    601          			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    602          			{
    603          				/* The timer is in a list, remove it. */
    604          				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    605          			}
    606          			else
    607          			{
    608          				mtCOVERAGE_TEST_MARKER();
    609          			}
    610          
    611          			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
    612          
    613          			/* In this case the xTimerListsWereSwitched parameter is not used, but
    614          			it must be present in the function call.  prvSampleTimeNow() must be
    615          			called after the message is received from xTimerQueue so there is no
    616          			possibility of a higher priority task adding a message to the message
    617          			queue with a time that is ahead of the timer daemon task (because it
    618          			pre-empted the timer daemon task after the xTimeNow value was set). */
    619          			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    620          
    621          			switch( xMessage.xMessageID )
    622          			{
    623          				case tmrCOMMAND_START :
    624          					/* Start or restart a timer. */
    625          					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    626          					{
    627          						/* The timer expired before it was added to the active
    628          						timer list.  Process it now. */
    629          						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    630          						traceTIMER_EXPIRED( pxTimer );
    631          
    632          						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    633          						{
    634          							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    635          							configASSERT( xResult );
    636          							( void ) xResult;
    637          						}
    638          						else
    639          						{
    640          							mtCOVERAGE_TEST_MARKER();
    641          						}
    642          					}
    643          					else
    644          					{
    645          						mtCOVERAGE_TEST_MARKER();
    646          					}
    647          					break;
    648          
    649          				case tmrCOMMAND_STOP :
    650          					/* The timer has already been removed from the active list.
    651          					There is nothing to do here. */
    652          					break;
    653          
    654          				case tmrCOMMAND_CHANGE_PERIOD :
    655          					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    656          					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    657          
    658          					/* The new period does not really have a reference, and can be
    659          					longer or shorter than the old one.  The command time is
    660          					therefore set to the current time, and as the period cannot be
    661          					zero the next expiry time can only be in the future, meaning
    662          					(unlike for the xTimerStart() case above) there is no fail case
    663          					that needs to be handled here. */
    664          					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    665          					break;
    666          
    667          				case tmrCOMMAND_DELETE :
    668          					/* The timer has already been removed from the active list,
    669          					just free up the memory. */
    670          					vPortFree( pxTimer );
    671          					break;
    672          
    673          				default	:
    674          					/* Don't expect to get here. */
    675          					break;
    676          			}
    677          		}
    678          	}
    679          }
    680          /*-----------------------------------------------------------*/
    681          
    682          static void prvSwitchTimerLists( void )
    683          {
    684          TickType_t xNextExpireTime, xReloadTime;
    685          List_t *pxTemp;
    686          Timer_t *pxTimer;
    687          BaseType_t xResult;
    688          
    689          	/* The tick count has overflowed.  The timer lists must be switched.
    690          	If there are any timers still referenced from the current timer list
    691          	then they must have expired and should be processed before the lists
    692          	are switched. */
    693          	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    694          	{
    695          		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    696          
    697          		/* Remove the timer from the list. */
    698          		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    699          		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    700          		traceTIMER_EXPIRED( pxTimer );
    701          
    702          		/* Execute its callback, then send a command to restart the timer if
    703          		it is an auto-reload timer.  It cannot be restarted here as the lists
    704          		have not yet been switched. */
    705          		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    706          
    707          		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    708          		{
    709          			/* Calculate the reload value, and if the reload value results in
    710          			the timer going into the same timer list then it has already expired
    711          			and the timer should be re-inserted into the current list so it is
    712          			processed again within this loop.  Otherwise a command should be sent
    713          			to restart the timer to ensure it is only inserted into a list after
    714          			the lists have been swapped. */
    715          			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    716          			if( xReloadTime > xNextExpireTime )
    717          			{
    718          				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    719          				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    720          				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    721          			}
    722          			else
    723          			{
    724          				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    725          				configASSERT( xResult );
    726          				( void ) xResult;
    727          			}
    728          		}
    729          		else
    730          		{
    731          			mtCOVERAGE_TEST_MARKER();
    732          		}
    733          	}
    734          
    735          	pxTemp = pxCurrentTimerList;
    736          	pxCurrentTimerList = pxOverflowTimerList;
    737          	pxOverflowTimerList = pxTemp;
    738          }
    739          /*-----------------------------------------------------------*/
    740          
    741          static void prvCheckForValidListAndQueue( void )
    742          {
    743          	/* Check that the list from which active timers are referenced, and the
    744          	queue used to communicate with the timer service, have been
    745          	initialised. */
    746          	taskENTER_CRITICAL();
    747          	{
    748          		if( xTimerQueue == NULL )
    749          		{
    750          			vListInitialise( &xActiveTimerList1 );
    751          			vListInitialise( &xActiveTimerList2 );
    752          			pxCurrentTimerList = &xActiveTimerList1;
    753          			pxOverflowTimerList = &xActiveTimerList2;
    754          			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    755          			configASSERT( xTimerQueue );
    756          
    757          			#if ( configQUEUE_REGISTRY_SIZE > 0 )
    758          			{
    759          				if( xTimerQueue != NULL )
    760          				{
    761          					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    762          				}
    763          				else
    764          				{
    765          					mtCOVERAGE_TEST_MARKER();
    766          				}
    767          			}
    768          			#endif /* configQUEUE_REGISTRY_SIZE */
    769          		}
    770          		else
    771          		{
    772          			mtCOVERAGE_TEST_MARKER();
    773          		}
    774          	}
    775          	taskEXIT_CRITICAL();
    776          }
    777          /*-----------------------------------------------------------*/
    778          
    779          BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    780          {
    781          BaseType_t xTimerIsInActiveList;
    782          Timer_t *pxTimer = ( Timer_t * ) xTimer;
    783          
    784          	/* Is the timer in the list of active timers? */
    785          	taskENTER_CRITICAL();
    786          	{
    787          		/* Checking to see if it is in the NULL list in effect checks to see if
    788          		it is referenced from either the current or the overflow timer lists in
    789          		one go, but the logic has to be reversed, hence the '!'. */
    790          		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
    791          	}
    792          	taskEXIT_CRITICAL();
    793          
    794          	return xTimerIsInActiveList;
    795          }
    796          /*-----------------------------------------------------------*/
    797          
    798          void *pvTimerGetTimerID( const TimerHandle_t xTimer )
    799          {
    800          Timer_t * const pxTimer = ( Timer_t * ) xTimer;
    801          
    802          	return pxTimer->pvTimerID;
    803          }
    804          /*-----------------------------------------------------------*/
    805          
    806          #if( INCLUDE_xTimerPendFunctionCallFromISR == 1 )
    807          
    808          	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
    809          	{
    810          	DaemonTaskMessage_t xMessage;
    811          	BaseType_t xReturn;
    812          
    813          		/* Complete the message with the function parameters and post it to the
    814          		daemon task. */
    815          		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
    816          		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    817          		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    818          		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    819          
    820          		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    821          
    822          		return xReturn;
    823          	}
    824          
    825          #endif /* INCLUDE_xTimerPendFunctionCallFromISR */
    826          /*-----------------------------------------------------------*/
    827          
    828          /* This entire source file will be skipped if the application is not configured
    829          to include software timer functionality.  If you want to include software timer
    830          functionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
    831          #endif /* configUSE_TIMERS == 1 */
    832          
    833          
    834          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  prvCheckForValidListAndQueue
              8 -> ulPortSetInterruptMask
              8 -> vListInitialise
              8 -> vPortEnterCritical
              0 -> vPortExitCritical
              8 -> vQueueAddToRegistry
              8 -> xQueueGenericCreate
       16  prvInsertTimerInActiveList
             16 -> vListInsert
       32  prvProcessReceivedCommands
             32 -- Indirect call
             32 -> prvInsertTimerInActiveList
             32 -> prvSampleTimeNow
             32 -> ulPortSetInterruptMask
             32 -> uxListRemove
             32 -> vPortFree
             32 -> xQueueGenericReceive
             32 -> xTimerGenericCommand
       16  prvSampleTimeNow
             16 -> prvSwitchTimerLists
             16 -> xTaskGetTickCount
       24  prvSwitchTimerLists
             24 -- Indirect call
             24 -> ulPortSetInterruptMask
             24 -> uxListRemove
             24 -> vListInsert
             24 -> xTimerGenericCommand
       32  prvTimerTask
             32 -- Indirect call
             32 -> prvInsertTimerInActiveList
             32 -> prvProcessReceivedCommands
             32 -> prvSampleTimeNow
             32 -> ulPortSetInterruptMask
             32 -> uxListRemove
             32 -> vPortYield
             32 -> vQueueWaitForMessageRestricted
             32 -> vTaskSuspendAll
             32 -> xTaskResumeAll
             32 -> xTimerGenericCommand
        0  pvTimerGetTimerID
       32  xTimerCreate
             32 -> prvCheckForValidListAndQueue
             32 -> pvPortMalloc
             32 -> ulPortSetInterruptMask
             32 -> vListInitialiseItem
       24  xTimerCreateTimerTask
             24 -> prvCheckForValidListAndQueue
             24 -> ulPortSetInterruptMask
             24 -> xTaskGenericCreate
       32  xTimerGenericCommand
             32 -> xQueueGenericSend
             32 -> xQueueGenericSendFromISR
             32 -> xTaskGetSchedulerState
        8  xTimerIsTimerActive
              8 -> vPortEnterCritical
              8 -> vPortExitCritical


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "Tmr Svc">
       8  ?<Constant "TmrQ">
       4  ??DataTable9
       4  ??DataTable9_1
      12  ?Subroutine0
      76  prvCheckForValidListAndQueue
      52  prvInsertTimerInActiveList
     162  prvProcessReceivedCommands
      36  prvSampleTimeNow
      86  prvSwitchTimerLists
     146  prvTimerTask
       4  pvTimerGetTimerID
      52  pxCurrentTimerList
          pxOverflowTimerList
          xTimerQueue
          xActiveTimerList1
          xActiveTimerList2
       4  xLastTime
      62  xTimerCreate
      56  xTimerCreateTimerTask
      66  xTimerGenericCommand
      26  xTimerIsTimerActive

 
  56 bytes in section .bss
 808 bytes in section .text
 
 808 bytes of CODE memory
  56 bytes of DATA memory

Errors: none
Warnings: none

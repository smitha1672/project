###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:25:35 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\HT68F30\HT68F30.c               #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\HT68F30\HT68F30.c -D S4051A -D  #
#                    DEBUG -D FREE_RTOS -D STM32F40_41xxx -D                  #
#                    USE_STM324xG_EVAL -D USE_STDPERIPH_DRIVER -D             #
#                    __ARM_CORTEX_MX__ -D IAR_ARM_CM4F -D USE_USB_OTG_FS      #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applicati #
#                    on\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Ap #
#                    plication\Obj\ --debug --endian=little --cpu=Cortex-M4   #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\HT68F30.lst                                           #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\HT68F30.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Libraries\AMT_Drivers\HT68F30\HT68F30.c
      1          #include "Defs.h"
      2          #include "Debug.h"
      3          #include "freertos_conf.h"
      4          #include "freertos_task.h"
      5          #include "freertos_typedef.h"
      6          #include "api_typedef.h"
      7          #include "HT68F30.h"
      8          #include "HT68F30_i2c.h"
      9          
     10          /* LED_effect*/
     11          
     12          typedef struct HT68F30_PARAMETERS 
     13          {
     14              xTaskHandle HT68F30_TaskHandle;
     15              TaskHandleState HT68F30_state;
     16              uint8 volume;
     17              bool mute_state;
     18          } xHT68F30_Params;
     19          
     20          static xHT68F30_Params mHT68F30Parms;
     21          
     22          static void HT68F30_LightBar_CreateTask( void );
     23          
     24          void HT68F30_setStatus(const void *parms);
     25          
     26          void HT68F30_LightConverter(uint8 StartPos, uint8 EndPos);
     27          
     28          void HT68F30_Set(uint8 StartPos, uint8 EndPos);
     29          
     30          void HT68F30_BlinkFadeToDarkConverter(uint8 StartPos, uint8 EndPos,uint16 Holdtime,uint16 duration, uint16 times);
     31          
     32          void HT68F30_FadeToDarkConverter(uint8 StartPos, uint8 EndPos,uint16 Holdtime,bool Foreground,bool Background,bool Clean);
     33          
     34          void HT68F30_BreathConverter(uint8 StartPos, uint8 EndPos);
     35          
     36          void HT68F30_BreathClear(uint8 StartPos, uint8 EndPos);
     37          
     38          void HT68F30_ScanningConverter(uint8 StartPos, uint8 EndPos);
     39          
     40          void HT68F30_StepsConverter(uint8 StartPos, uint8 EndPos);
     41          
     42          void HT68F30_StepsClear(uint8 StartPos, uint8 EndPos);
     43          
     44          void HT68F30_DarkConverter(uint8 StartPos, uint8 EndPos);
     45          
     46          void HT68F30_Flashing(uint8 StartPos, uint8 EndPos,uint16 duration, uint16 times,bool StandbyLED);
     47          
     48          void HT68F30_Version(void);
     49          
     50          void HT68F30_CleanALL(uint8 StartPos, uint8 EndPos,uint16 Holdtime, bool background);
     51          
     52          void HT68F30_CleanLED(uint8 StartPos, uint8 EndPos,uint16 Holdtime, bool background);
     53          
     54          bool HT68F30_IsControllingLED(void);    //Angus added in order to know whether leds are contoled or not for UI 4.3 Spec 7.1.1.
     55          
     56          void HT68F30_UpdateDemoTimeOutState(bool state);    //Angus adder for demo mode timeout behavior.
     57          
     58          const LED_OBJECT HT68F30_ObjCtrl = 
     59          {
     60              HT68F30_LightBar_CreateTask,
     61              HT68F30_setStatus,
     62              HT68F30_LightConverter,
     63              HT68F30_Set,
     64              HT68F30_BlinkFadeToDarkConverter,
     65              HT68F30_FadeToDarkConverter,
     66              HT68F30_BreathConverter,
     67              HT68F30_BreathClear,
     68              HT68F30_ScanningConverter,
     69              HT68F30_StepsConverter,
     70              HT68F30_StepsClear,
     71              HT68F30_DarkConverter,
     72              HT68F30_Flashing,
     73              HT68F30_Version,
     74              HT68F30_CleanALL,
     75              HT68F30_CleanLED,
     76              HT68F30_IsControllingLED,
     77              HT68F30_UpdateDemoTimeOutState,
     78          };
     79          
     80          const LED_OBJECT *pLED_ObjCtrl = &HT68F30_ObjCtrl;
     81          
     82          /* LED position define */
     83          typedef struct
     84          {
     85              const uint8 light_addr;
     86              uint8 duty;
     87              xHT68F30EFFECT effect;
     88              uint16 time_stamp;
     89              bool changed;
     90          }LightBar;
     91          
     92          /* LED duty define */
     93          #define LIGHT_BAR_DUTY_MAX   0x78
     94          #define DUTY_HIGH            50
     95          #define DUTY_MID             25
     96          #define DUTY_LOW             5
     97          
     98          #ifdef LIGHT_BAR_INVERT
     99          #define LIGHT_BAR_DUTY_HIGH (0x78 - ((LIGHT_BAR_DUTY_MAX*DUTY_HIGH) /100))
    100          #define LIGHT_BAR_DUTY_MID  (0x78 - ((LIGHT_BAR_DUTY_MAX*DUTY_MID) /100))
    101          #define LIGHT_BAR_DUTY_LOW  (0x78 - ((LIGHT_BAR_DUTY_MAX*DUTY_LOW) /100))
    102          #define LIGHT_BAR_DUTY(X)   (0x78 - ((LIGHT_BAR_DUTY_MAX * X) /100))
    103          #define LIGHT_BAR_DUTY_DARK (LIGHT_BAR_DUTY_MAX)
    104          #else
    105          #define LIGHT_BAR_DUTY_HIGH (0x00 + ((LIGHT_BAR_DUTY_MAX*DUTY_HIGH) /100))
    106          #define LIGHT_BAR_DUTY_MID  (0x00 + ((LIGHT_BAR_DUTY_MAX*DUTY_MID) /100))
    107          #define LIGHT_BAR_DUTY_LOW  (0x00 + ((LIGHT_BAR_DUTY_MAX*DUTY_LOW) /100))
    108          #define LIGHT_BAR_DUTY(X)   (0x00 + ((LIGHT_BAR_DUTY_MAX * X) /100))
    109          #define LIGHT_BAR_DUTY_DARK (0x00)
    110          #endif /*LIGHT_BAR_INVERT*/
    111          
    112          /* Light Bar */
    113          const static uint8 mLightBar_Duty1[]={LIGHT_BAR_DUTY_LOW,LIGHT_BAR_DUTY_MID,LIGHT_BAR_DUTY_HIGH};
    114          
    115          static LightBar mLightBarParams[] = 
    116          {
    117              { 0x0C, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    118              { 0x0B, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    119              { 0x0A, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    120              { 0x09, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    121              { 0x08, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    122              { 0x07, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    123              { 0x06, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    124              { 0x05, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    125              { 0x04, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    126              { 0x03, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    127              { 0x02, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    128              { 0x01, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    129              { 0x0D, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE},
    130              { 0x0E, LIGHT_BAR_DUTY_DARK, HT68F30_NULL, 0, TRUE}
    131          };
    132          
    133          /*  Sound Bar LED S3851
    134          level:0~                               35  36 ~41
    135              _____________________________________________
    136             |  *  *  *  *  *  *  *  *  *  *  *  *   *  *  |   
    137                C  B  A  9  8  7  6  5  4  3  2  1 | D  E   
    138                         LED_VOL_NUMBER              LED_FORMAT_NUMBER
    139          */
    140          #define DUTY1_NUM                 (sizeof(mLightBar_Duty1)/sizeof(uint8))
    141          #define MAX_DUTY1_INDEX           DUTY1_NUM-1
    142          #define MIN_DUTY1_INDEX           0
    143          
    144          #define LED_LEVEL_NUM             (sizeof(mLightBarParams)/sizeof(LightBar))
    145          #define LED_VOL_LEVEL_NUM         LED_LEVEL_NUM -2
    146          
    147          #define MAX_LED_LEVEL_INDEX       LED_LEVEL_NUM - 1
    148          #define MID_LED_LEVEL_INDEX       (LED_LEVEL_NUM/2)
    149          #define MIN_LED_LEVEL_INDEX       0
    150          
    151          #define LED_FORMAT_NUMBER         2
    152          #define LED_VOL_NUMBER            LED_LEVEL_NUM - LED_FORMAT_NUMBER
    153          
    154          #define MIN_VOL_POS               0
    155          #define POW_VOL_POS               2
    156          #define MAX_VOL_POS               35
    157          #define MIN_FORMAT_POS            36
    158          #define MAX_FORMAT_POS            41
    159          
    160          static LightBar mNewLightBarParams[] = 
    161          {
    162              { 0x0C, NULL, HT68F30_NULL, 0, TRUE},
    163              { 0x0B, NULL, HT68F30_NULL, 0, TRUE},
    164              { 0x0A, NULL, HT68F30_NULL, 0, TRUE},
    165              { 0x09, NULL, HT68F30_NULL, 0, TRUE},
    166              { 0x08, NULL, HT68F30_NULL, 0, TRUE},
    167              { 0x07, NULL, HT68F30_NULL, 0, TRUE},
    168              { 0x06, NULL, HT68F30_NULL, 0, TRUE},
    169              { 0x05, NULL, HT68F30_NULL, 0, TRUE},
    170              { 0x04, NULL, HT68F30_NULL, 0, TRUE},
    171              { 0x03, NULL, HT68F30_NULL, 0, TRUE},
    172              { 0x02, NULL, HT68F30_NULL, 0, TRUE},
    173              { 0x01, NULL, HT68F30_NULL, 0, TRUE},
    174              { 0x0D, NULL, HT68F30_NULL, 0, TRUE},
    175              { 0x0E, NULL, HT68F30_NULL, 0, TRUE}
    176          };
    177          
    178          static uint8 nFlashCount;
    179          static uint8 nFlashSpeedTarget;
    180          static uint8 nFlashSpeed;
    181          static bool bFlasgingVector = TRUE;
    182          static bool bStandby = TRUE;
    183          
    184          static uint8 nStepsEndNum = 0;
    185          static uint8 nScanNum;     
    186          static uint8 nStepsNum;
    187          static uint8 nScanCount;
    188          static uint8 nStepsCount;      
    189          
    190          static bool LightBar_DemoTimeOut = FALSE;    //Angus added , for auto setting timeout led after diaplay another led behavior.(2014/11/5)
    191          //______________________________________________________________________________
    192          
    193          void HT68F30_setStatus(const void *parms)
    194          {
    195              xHMISystemParams* pSystemParms = (xHMISystemParams*)parms;
    196          
    197              mHT68F30Parms.mute_state = pSystemParms->mute;
    198              mHT68F30Parms.volume = pSystemParms->master_gain;
    199          }
    200          
    201          void HT68F30_LightBarControl( uint8 position, uint8 duty )
    202          {
    203              mLightBarParams[position].duty = duty;
    204              HT68F30_WriteI2C_Byte( mLightBarParams[position].light_addr, 
    205                                     mLightBarParams[position].duty );
    206          }
    207          
    208          void HT68F30_CleanALL(uint8 StartPos, uint8 EndPos,uint16 Holdtime, bool background)
    209          {
    210              uint8 position;
    211              uint8 StartIndex;
    212              uint8 EndIndex;
    213              uint8 i;
    214              /* If start and end are in volume section, clean all volume section */
    215              /* otherwise start and end are in format section, clean all format section */ 
    216          
    217              if(( StartPos >= MIN_FORMAT_POS)&&( EndPos <= MAX_FORMAT_POS)) 
    218              {
    219                  StartIndex = MIN_FORMAT_POS;
    220                  EndIndex = MAX_FORMAT_POS;
    221              }
    222              else
    223              {
    224                  StartIndex = MIN_VOL_POS;
    225                  EndIndex = MAX_VOL_POS;
    226              }
    227              
    228              for (i = StartIndex; i <= EndIndex; i = i + DUTY1_NUM)
    229              {
    230                  position = i/DUTY1_NUM;
    231          
    232                  if(background == FALSE)
    233                  {
    234                      mNewLightBarParams[position].duty = LIGHT_BAR_DUTY_DARK;
    235                      mNewLightBarParams[position].effect = HT68F30_DARK;
    236                  }
    237                  else
    238                  {
    239                      mNewLightBarParams[position].duty = LIGHT_BAR_DUTY_LOW;
    240                      mNewLightBarParams[position].effect = HT68F30_FADE_TO_DARK;
    241                  }
    242          
    243                  mNewLightBarParams[position].time_stamp = Holdtime + 60;
    244                  mNewLightBarParams[position].changed= TRUE;
    245              }
    246          }
    247          
    248          void HT68F30_CleanLED(uint8 StartPos, uint8 EndPos,uint16 Holdtime, bool background)
    249          {
    250              uint8 position;
    251              uint8 i;
    252              
    253              for (i = StartPos; i <= EndPos; i = i + DUTY1_NUM)
    254              {
    255                  position = i/DUTY1_NUM;
    256          
    257                  if(background == FALSE)
    258                  {
    259                      mNewLightBarParams[position].duty = LIGHT_BAR_DUTY_DARK;
    260                      mNewLightBarParams[position].effect = HT68F30_DARK;
    261                  }
    262                  else
    263                  {
    264                      mNewLightBarParams[position].duty = LIGHT_BAR_DUTY_LOW;
    265                      mNewLightBarParams[position].effect = HT68F30_FADE_TO_DARK;
    266                  }
    267          
    268                  mNewLightBarParams[position].time_stamp = Holdtime + 60;
    269                  mNewLightBarParams[position].changed= TRUE;
    270              }
    271          }
    272          
    273          void HT68F30_LightConverter(uint8 StartPos, uint8 EndPos)
    274          {
    275              uint8 LightSum;
    276              uint8 LightRemainder;
    277              uint8 position;
    278              uint8 LastPos;
    279              uint8 i;
    280              LightSum = EndPos - StartPos;
    281              LightRemainder = LightSum%DUTY1_NUM;
    282              LastPos = (EndPos + LightRemainder)/DUTY1_NUM;
    283          
    284              HT68F30_CleanALL(StartPos,EndPos,0,FALSE);
    285              
    286              for (i = StartPos; i<=EndPos; i = i+DUTY1_NUM)
    287              {
    288                  position = i/DUTY1_NUM;
    289          
    290                  if (position == LastPos)
    291                  {
    292                      mNewLightBarParams[position].duty = mLightBar_Duty1[LightRemainder];
    293                  }
    294                  else
    295                  {
    296                      mNewLightBarParams[position].duty = mLightBar_Duty1[MAX_DUTY1_INDEX];
    297                  }
    298                  mNewLightBarParams[position].effect = HT68F30_NORMAL;
    299                  mNewLightBarParams[position].time_stamp = 0;
    300                  mNewLightBarParams[position].changed= TRUE;
    301              }
    302          }
    303          
    304          void HT68F30_Set(uint8 StartPos, uint8 EndPos)
    305          {
    306              uint8 LightSum;
    307              uint8 LightRemainder;
    308              uint8 position;
    309              uint8 LastPos;
    310              uint8 i;
    311              LightSum = EndPos - StartPos;
    312              LightRemainder = LightSum%DUTY1_NUM;
    313              LastPos = (EndPos + LightRemainder)/DUTY1_NUM;
    314              
    315              for (i = StartPos; i<=EndPos; i = i+DUTY1_NUM)
    316              {
    317                  position = i/DUTY1_NUM;
    318          
    319                  if (position == LastPos)
    320                  {
    321                      mNewLightBarParams[position].duty = mLightBar_Duty1[LightRemainder];
    322                  }
    323                  else
    324                  {
    325                      mNewLightBarParams[position].duty = mLightBar_Duty1[MAX_DUTY1_INDEX];
    326                  }
    327                  mNewLightBarParams[position].effect = HT68F30_NORMAL;
    328                  mNewLightBarParams[position].time_stamp = 0;
    329                  mNewLightBarParams[position].changed= TRUE;
    330              }
    331          }
    332          
    333          void HT68F30_BlinkFadeToDarkConverter(uint8 StartPos, uint8 EndPos,uint16 Holdtime,uint16 duration, uint16 times)
    334          {
    335              uint8 LightSum;
    336              uint8 LightRemainder;
    337              uint8 position;
    338              uint8 LastPos;
    339              uint8 i;
    340              LightSum = EndPos - StartPos;
    341              LightRemainder = LightSum % DUTY1_NUM;
    342              LastPos = (EndPos + LightRemainder)/DUTY1_NUM;
    343          
    344              nFlashSpeedTarget = duration;
    345              nFlashSpeed = 0;
    346              nFlashCount = times;
    347              bFlasgingVector = FALSE;
    348          
    349              HT68F30_CleanALL(StartPos,EndPos,0,FALSE);
    350              /* Light the LED */
    351              for (i = StartPos; i<=EndPos; i = i+DUTY1_NUM)
    352              {
    353                  position = i/DUTY1_NUM;
    354          
    355                  mNewLightBarParams[position].duty = LIGHT_BAR_DUTY_DARK;
    356                  mNewLightBarParams[position].effect = HT68F30_BLINK_FADE_TO_DARK;        
    357                  mNewLightBarParams[position].time_stamp = Holdtime + 60;
    358                  mNewLightBarParams[position].changed= TRUE;
    359              }
    360          }
    361          
    362          void HT68F30_FadeToDarkConverter(uint8 StartPos, uint8 EndPos,uint16 Holdtime,bool Foreground,bool Background,bool Clean)
    363          {
    364              uint8 LightSum;
    365              uint8 LightRemainder;
    366              uint8 position;
    367              uint8 LastPos;
    368              uint8 i;
    369              LightSum = EndPos - StartPos;
    370              LightRemainder = LightSum % DUTY1_NUM;
    371              LastPos = EndPos/DUTY1_NUM;
    372              
    373              if (Clean)
    374              {
    375                  HT68F30_CleanALL(StartPos,EndPos,Holdtime,Background);
    376              }
    377              /* Light the LED */
    378              for (i = StartPos; i<=EndPos; i = i+DUTY1_NUM)
    379              {
    380                  position = i/DUTY1_NUM;
    381                  if(Foreground == TRUE)
    382                  {
    383                  if (position == LastPos)
    384                  {
    385                      mNewLightBarParams[position].duty = mLightBar_Duty1[LightRemainder];
    386                  }
    387                  else
    388                  {
    389                      mNewLightBarParams[position].duty = mLightBar_Duty1[MAX_DUTY1_INDEX];
    390                  }
    391          
    392                  mNewLightBarParams[position].effect = HT68F30_FADE_TO_DARK;
    393                  }
    394                  else
    395                  {
    396                      mNewLightBarParams[position].duty = LIGHT_BAR_DUTY_DARK;
    397                      mNewLightBarParams[position].effect = HT68F30_DARK;
    398                  }
    399                  
    400                  mNewLightBarParams[position].time_stamp = Holdtime + 60;
    401                  mNewLightBarParams[position].changed= TRUE;
    402              }
    403          }
    404          
    405          void HT68F30_BreathConverter(uint8 StartPos, uint8 EndPos)
    406          {
    407              uint8 position;
    408              uint8 i;
    409              
    410              HT68F30_CleanALL(StartPos,EndPos,0,FALSE);
    411              for (i = StartPos; i<=EndPos; i = i+DUTY1_NUM)
    412              {
    413                  position = i/DUTY1_NUM;
    414                  mNewLightBarParams[position].duty = mLightBar_Duty1[MAX_DUTY1_INDEX];
    415                  mNewLightBarParams[position].effect = HT68F30_BREATH;
    416                  mNewLightBarParams[position].time_stamp = 0;
    417                  mNewLightBarParams[position].changed= TRUE;
    418              }  
    419          }
    420          
    421          void HT68F30_BreathClear(uint8 StartPos, uint8 EndPos)
    422          {
    423              HT68F30_CleanLED(EndPos,MAX_VOL_POS,0,FALSE);
    424          }
    425          
    426          void HT68F30_ScanningConverter(uint8 StartPos, uint8 EndPos)
    427          {
    428              uint8 position;
    429              uint8 i;
    430          
    431              HT68F30_CleanALL(StartPos,EndPos,0,FALSE);
    432              
    433              for (i = StartPos; i<EndPos; i = i+DUTY1_NUM)
    434              {
    435                  position = i/DUTY1_NUM;
    436          
    437                  mNewLightBarParams[position].duty = LIGHT_BAR_DUTY_DARK;
    438                  mNewLightBarParams[position].effect = HT68F30_SCANNING;
    439                  mNewLightBarParams[position].time_stamp = 0;
    440                  mNewLightBarParams[position].changed= TRUE;
    441              }  
    442          }
    443          
    444          void HT68F30_StepsConverter(uint8 StartPos, uint8 EndPos)
    445          {
    446              uint8 LightSum;
    447              uint8 LightRemainder;
    448              uint8 position;
    449              uint8 LastPos;
    450              uint8 i;
    451              LightSum = EndPos - StartPos;
    452              LightRemainder = LightSum % DUTY1_NUM;
    453              nStepsEndNum = ((EndPos-LightRemainder)/DUTY1_NUM)+1;
    454              nStepsNum = ((StartPos < LightRemainder) ? 1 : ((EndPos-LightRemainder)/DUTY1_NUM)+1);
    455              nStepsCount = 0;
    456          
    457              HT68F30_CleanALL(StartPos,EndPos,0,FALSE);
    458              
    459              for (i = StartPos; i<=EndPos; i = i+DUTY1_NUM)
    460              {
    461                  position = i/DUTY1_NUM;
    462          
    463                  mNewLightBarParams[position].duty = LIGHT_BAR_DUTY_DARK;
    464                  mNewLightBarParams[position].effect = HT68F30_STEPS;
    465                  mNewLightBarParams[position].time_stamp = 0;
    466                  mNewLightBarParams[position].changed= TRUE;
    467              }  
    468          }
    469          
    470          void HT68F30_StepsClear(uint8 StartPos, uint8 EndPos)
    471          {
    472              uint8 LightSum;
    473              uint8 LightRemainder;
    474              LightSum = EndPos - StartPos;
    475              LightRemainder = LightSum % DUTY1_NUM;
    476              nStepsEndNum = ((EndPos-LightRemainder)/DUTY1_NUM)+1;
    477          }
    478          
    479          void HT68F30_DarkConverter(uint8 StartPos, uint8 EndPos)
    480          {
    481              uint8 position;
    482              uint8 i;
    483              for (i = StartPos; i<EndPos; i = i+DUTY1_NUM)
    484              {
    485                  position = i/DUTY1_NUM;
    486                  mNewLightBarParams[position].duty = LIGHT_BAR_DUTY_DARK; 
    487          
    488                  mNewLightBarParams[position].effect = HT68F30_DARK;
    489                  mNewLightBarParams[position].time_stamp = 0;
    490                  mNewLightBarParams[position].changed= TRUE;
    491              }
    492          }
    493          
    494          void HT68F30_Flashing(uint8 StartPos, uint8 EndPos,uint16 duration, uint16 times,bool StandbyLED)
    495          {
    496              uint8 LightSum;
    497              uint8 LightRemainder;
    498              uint8 position;
    499              uint8 LastPos;
    500              uint8 i;
    501              LightSum = EndPos - StartPos+1;
    502              LightRemainder = LightSum % DUTY1_NUM;
    503              LastPos = (EndPos + LightRemainder)/DUTY1_NUM;
    504          
    505              nFlashSpeedTarget = duration;
    506              nFlashSpeed = duration;
    507              nFlashCount = times;
    508              bFlasgingVector = TRUE;
    509              bStandby = StandbyLED;
    510              HT68F30_CleanALL(StartPos,MAX_VOL_POS,0,FALSE);
    511              if (StartPos!=MIN_VOL_POS)
    512              {
    513                  mLightBarParams[0].time_stamp = 0;
    514                  mLightBarParams[0].duty = LIGHT_BAR_DUTY_HIGH;
    515                  mLightBarParams[0].effect = HT68F30_NORMAL;
    516                  mLightBarParams[0].changed= TRUE;
    517              }
    518              /* Light the LED */
    519              for (i = StartPos; i<=EndPos; i = i+DUTY1_NUM)
    520              {
    521                  position = i/DUTY1_NUM;
    522          
    523                  mNewLightBarParams[position].duty = mLightBar_Duty1[MAX_DUTY1_INDEX];
    524                  mNewLightBarParams[position].effect = HT68F30_FLASHING;        
    525                  mNewLightBarParams[position].time_stamp = 0;
    526                  mNewLightBarParams[position].changed= TRUE;
    527              }
    528          }
    529          
    530          void HT68F30_Version(void)
    531          {
    532              uint8 i = 0;
    533              uint8 tmp,tmp2;
    534             
    535              HT68F30_CleanALL(0,MAX_FORMAT_POS,0,FALSE);
    536              tmp = (uint8)(VERSION>>8) & 0xFF;
    537              tmp2 = tmp/16*10;
    538              tmp2 += tmp%16;
    539              tmp2 <<= 4;
    540          
    541              for (i=0; i < 4; i++) 
    542              { // first 4 LED
    543                  if ((tmp2<<i) & 0x80) 
    544                  {
    545                      mNewLightBarParams[i].duty = mLightBar_Duty1[MAX_DUTY1_INDEX];
    546                  } 
    547                  else 
    548                  {
    549                      mNewLightBarParams[i].duty = mLightBar_Duty1[MIN_DUTY1_INDEX];
    550                  }
    551                  mNewLightBarParams[i].effect = HT68F30_NORMAL;        
    552                  mNewLightBarParams[i].time_stamp = 0;
    553                  mNewLightBarParams[i].changed= TRUE;
    554              }
    555          
    556              tmp = (uint8)(VERSION&0x00F0);
    557              for (; i < 8; i++) 
    558              { // min 4 LED
    559                  if ((tmp<<(i-4)) & 0x80) 
    560                  {
    561                      mNewLightBarParams[i].duty = mLightBar_Duty1[MAX_DUTY1_INDEX];
    562                  } 
    563                  else 
    564                  {
    565                      mNewLightBarParams[i].duty = mLightBar_Duty1[MIN_DUTY1_INDEX];
    566                  }
    567                  mNewLightBarParams[i].effect = HT68F30_NORMAL;        
    568                  mNewLightBarParams[i].time_stamp = 0;
    569                  mNewLightBarParams[i].changed= TRUE;
    570              }
    571          
    572              tmp = (uint8)(VERSION&0X000F);
    573              tmp <<= 4;
    574              for ( ; i < LED_VOL_LEVEL_NUM; i++ ) // last 4 LED
    575              {
    576                  TRACE_DEBUG((0,"LED_VOL_LEVEL_NUM=%X",LED_VOL_LEVEL_NUM));
    577                  if ((tmp<<(i-8)) & 0x80) 
    578                  {
    579                      mNewLightBarParams[i].duty = mLightBar_Duty1[MAX_DUTY1_INDEX];
    580                  } 
    581                  else 
    582                  {
    583                      mNewLightBarParams[i].duty = mLightBar_Duty1[MIN_DUTY1_INDEX];
    584                  }
    585                  mNewLightBarParams[i].effect = HT68F30_NORMAL;        
    586                  mNewLightBarParams[i].time_stamp = 0;
    587                  mNewLightBarParams[i].changed= TRUE;
    588              }
    589          }
    590          
    591          
    592          void HT68F30_MuteLED(void)
    593          {
    594              if(mHT68F30Parms.mute_state)
    595              {
    596                  HT68F30_BreathConverter(MIN_VOL_POS,mHT68F30Parms.volume);
    597              }
    598          }
    599          
    600          void HT68F30_UpdateDemoTimeOutState(bool state)
    601          {
    602              LightBar_DemoTimeOut = state;
    603          }
    604          void HT68F30_DemoTimeOutLED(void)
    605          {
    606              if(LightBar_DemoTimeOut)
    607              {
    608                  HT68F30_StepsConverter(MIN_VOL_POS,MAX_VOL_POS);
    609              }
    610          }
    611          
    612          bool HT68F30_IsControllingLED(void)
    613          {
    614              if(mLightBarParams[0].effect == HT68F30_NORMAL &&
    615                  mLightBarParams[0].changed == FALSE)
    616              {
    617                  return FALSE;
    618              }
    619              return TRUE;
    620          }
    621          
    622          void HT68F30_LightBar_task( void *pvParameters )
    623          {
    624              for(;;)
    625              {
    626                  static bool bBreatheVector = TRUE;/* conunt down */
    627                  static bool bScanningVector = TRUE;/* left to right */
    628                  static bool bStepsVector = TRUE;/* left to right */    
    629                  uint8 i;
    630                  uint8 nDuty;
    631          
    632                  for(i=0 ; i <= MAX_LED_LEVEL_INDEX; i++)
    633                  {
    634                      if (i == 0) 
    635                      {
    636                          /* Breath */
    637                          if (bBreatheVector == FALSE)
    638                          {
    639                              nDuty = nDuty - 5;
    640                              if (nDuty < 15)
    641                              {
    642                                  bBreatheVector = TRUE;
    643                              }
    644                          }  
    645                          else if (bBreatheVector == TRUE)
    646                          {
    647                              nDuty = nDuty + 5;
    648                              if (nDuty >=100)
    649                              {
    650                                  bBreatheVector = FALSE;
    651                              }
    652                          }
    653          
    654                          /* Scaning*/
    655                          if (bScanningVector == FALSE) /*right to left*/
    656                          {
    657                              if (nScanCount%1==0)
    658                              {   /*0.1 sec move one step*/
    659                                  nScanNum = nScanNum - 1;
    660                                  if (nScanNum == 0)
    661                                  {
    662                                      bScanningVector = TRUE;
    663                                  }
    664                              }
    665                              nScanCount++;
    666          
    667                          }
    668                          else if (bScanningVector == TRUE) /*left to right*/
    669                          {
    670                              if (nScanCount%1==0)
    671                              {
    672                                  nScanNum = nScanNum + 1;
    673                                  if (nScanNum == LED_VOL_NUMBER-1)
    674                                  {
    675                                      bScanningVector = FALSE;
    676                                  }
    677                              }      
    678                              nScanCount++;
    679                          }      
    680          
    681                          /* Steps*/
    682                          if (bStepsVector == FALSE) /*right to left*/
    683                          {
    684                              if (nStepsCount%1==0)
    685                              {   /*0.3 sec move one step*/
    686                                  nStepsNum = nStepsNum - 1;
    687                                  if (nStepsNum == 0)
    688                                  {
    689                                      bStepsVector = TRUE;
    690                                  }
    691                              }
    692                              nStepsCount++;
    693          
    694                          }
    695                          else if (bStepsVector == TRUE) /*left to right*/
    696                          {
    697                              if (nStepsCount%1==0)
    698                              {
    699                                  nStepsNum = nStepsNum + 1;
    700                                  if (nStepsNum >nStepsEndNum)
    701                                  {
    702                                      bStepsVector = FALSE;
    703                                      nStepsNum = nStepsNum - 1;
    704                                  }
    705                              }      
    706                              nStepsCount++;
    707                          }    
    708          
    709                          /* Flashing*/
    710                          if (bFlasgingVector == TRUE)
    711                          {
    712                              nFlashSpeed --;
    713                              if (nFlashSpeed == 0)
    714                              {
    715                                  bFlasgingVector = FALSE;
    716                              }
    717                          }  
    718                          else if (bFlasgingVector == FALSE)
    719                          {
    720                              nFlashSpeed ++;
    721                              if (nFlashSpeed == nFlashSpeedTarget)
    722                              {   
    723                                  if (nFlashCount!=0xFF)
    724                                  {
    725                                      nFlashCount--;
    726                                  }
    727                                  bFlasgingVector = TRUE;
    728                              }
    729                          }
    730                      }
    731                      
    732                      if (mNewLightBarParams[i].changed)
    733                      {
    734                          mLightBarParams[i].duty = mNewLightBarParams[i].duty;
    735                          mLightBarParams[i].effect = mNewLightBarParams[i].effect;
    736                          mLightBarParams[i].time_stamp= mNewLightBarParams[i].time_stamp;
    737                          mLightBarParams[i].changed= mNewLightBarParams[i].changed;
    738                          mNewLightBarParams[i].changed = FALSE;
    739                      }
    740                      
    741                      switch(mLightBarParams[i].effect)
    742                      {   
    743                          case HT68F30_BLINK_FADE_TO_DARK:
    744                          {
    745                              if (bFlasgingVector ==TRUE)
    746                              {   
    747                                  mLightBarParams[i].duty = mLightBar_Duty1[MAX_DUTY1_INDEX];
    748                              }
    749                              else 
    750                              {
    751                                  mLightBarParams[i].duty = LIGHT_BAR_DUTY_DARK;
    752                              }
    753          
    754                              if(nFlashCount == 0)
    755                              {
    756                                  mLightBarParams[i].time_stamp = 60;
    757                                  mLightBarParams[i].duty = mLightBar_Duty1[MAX_DUTY1_INDEX]; 
    758                                  mLightBarParams[i].effect = HT68F30_FADE_TO_DARK;
    759                              
    760                              }
    761                              
    762                              mLightBarParams[i].changed= TRUE;
    763                          }
    764                      
    765                          case HT68F30_FADE_TO_DARK:
    766                          {
    767                              mLightBarParams[i].time_stamp--;
    768                              
    769                              /* Stay at full brightness for 1.5 ,3,15 seconds */
    770                              if (mLightBarParams[i].time_stamp > 6 && mLightBarParams[i].time_stamp <= 60)
    771                              {   
    772                                  /*Wait for half duty, only reduce the full brightness*/
    773                                  if ( mLightBarParams[i].duty > LIGHT_BAR_DUTY_LOW )
    774                                  {
    775                                      mLightBarParams[i].duty = mLightBarParams[i].duty - 1;
    776                                  }
    777                              }
    778                              else if (mLightBarParams[i].time_stamp > 0 && mLightBarParams[i].time_stamp <= 6)
    779                              {
    780                              if ( mLightBarParams[i].duty != LIGHT_BAR_DUTY_DARK )
    781                              {
    782                                      mLightBarParams[i].duty = mLightBarParams[i].duty - 1;
    783                                  }
    784                              }
    785                              /* LIGHT_BAR_DUTY_HIGH is 0d60, so after 3 sec it become bark */
    786                              else if ( mLightBarParams[i].time_stamp == 0 )
    787                              {
    788                                  mLightBarParams[i].time_stamp = 0;
    789                                  mLightBarParams[i].duty = LIGHT_BAR_DUTY_DARK;
    790                                  mLightBarParams[i].effect = HT68F30_DARK;
    791                              
    792                                  if (i<=MAX_LED_LEVEL_INDEX)/* Only the volume part,no status part*/
    793                                  {
    794                                      /* After FTD, turn on Power light(First one) */
    795                                      mLightBarParams[0].time_stamp = 0;
    796                                      mLightBarParams[0].duty = mLightBar_Duty1[MIN_DUTY1_INDEX];
    797                                      mLightBarParams[0].effect = HT68F30_NORMAL;
    798                                      mLightBarParams[0].changed= TRUE;
    799                                      HT68F30_MuteLED();/*resume mute status*/
    800                                      HT68F30_DemoTimeOutLED();  
    801                                  }
    802                              }
    803                              mLightBarParams[i].changed= TRUE;
    804                          }
    805                              break;
    806                              
    807                          case HT68F30_BREATH:
    808                          {
    809                              mLightBarParams[i].duty = LIGHT_BAR_DUTY(nDuty);
    810                              mLightBarParams[i].changed= TRUE;
    811                          }
    812                              break;
    813                              
    814                          case HT68F30_SCANNING:
    815                          {
    816                              if (i == nScanNum)
    817                              {
    818                                  mLightBarParams[i].duty = mLightBar_Duty1[MAX_DUTY1_INDEX];
    819                              }
    820                              else
    821                              {
    822                                  mLightBarParams[i].duty = LIGHT_BAR_DUTY_DARK;
    823                              }
    824                              mLightBarParams[i].changed= TRUE;
    825                          }
    826                              break;
    827          
    828                          case HT68F30_STEPS:
    829                          {
    830                              if (i < nStepsNum)
    831                              {
    832                                  mLightBarParams[i].duty = mLightBar_Duty1[MAX_DUTY1_INDEX];
    833                              }
    834                              else
    835                              {
    836                                  mLightBarParams[i].duty = LIGHT_BAR_DUTY_DARK;
    837                              }
    838                              mLightBarParams[i].changed= TRUE;
    839                          }
    840                              break;
    841                              
    842                          case HT68F30_FLASHING:
    843                          {
    844                              if (bFlasgingVector ==TRUE)
    845                              {   
    846                                  mLightBarParams[i].duty = mLightBar_Duty1[MAX_DUTY1_INDEX];
    847                              }
    848                              else 
    849                              {
    850                                  mLightBarParams[i].duty = LIGHT_BAR_DUTY_DARK;
    851                              }
    852          
    853                              if(nFlashCount == 0)
    854                              {
    855                                  mLightBarParams[i].time_stamp = 0;
    856                                  mLightBarParams[i].duty = LIGHT_BAR_DUTY_DARK;
    857                                  mLightBarParams[i].effect = HT68F30_DARK;
    858                              
    859                                  if (i<=MAX_LED_LEVEL_INDEX)/* Only the volume part,no status part*/
    860                                  {
    861                                      if (bStandby)
    862                                      {
    863                                          /* After FTD, turn on Power light(First one) */
    864                                          mLightBarParams[0].time_stamp = 0;
    865                                          mLightBarParams[0].duty = mLightBar_Duty1[MIN_DUTY1_INDEX];
    866                                          mLightBarParams[0].effect = HT68F30_NORMAL;
    867                                          mLightBarParams[0].changed= TRUE;
    868                                          HT68F30_MuteLED();/*resume mute status*/
    869                                          HT68F30_DemoTimeOutLED();
    870                                      }
    871                                  }
    872                              }
    873                              
    874                              mLightBarParams[i].changed= TRUE;
    875                          }
    876                              break;
    877                              
    878                          case HT68F30_NORMAL: 
    879                          case HT68F30_DARK:
    880                          default:
    881                             /*Don't need to change duty, but clean the time stamp*/
    882                          
    883                              break;
    884                      }
    885                      
    886                      if (mLightBarParams[i].changed == TRUE)
    887                      {         
    888                          mLightBarParams[i].changed = FALSE;
    889                          HT68F30_WriteI2C_Byte( mLightBarParams[i].light_addr, 
    890                                                 mLightBarParams[i].duty );
    891                      }
    892                  }
    893                  vTaskDelay(TASK_MSEC2TICKS(50)); 
    894              }
    895          }
    896          
    897          static void HT68F30_LightBar_CreateTask( void )
    898          {
    899              if ( xTaskCreate( HT68F30_LightBar_task, 
    900                      ( portCHAR * ) "HT68F30_LightBar_task", 
    901                      (STACK_SIZE), NULL, tskH68F30_PRIORITY,&mHT68F30Parms.HT68F30_TaskHandle) != pdPASS )
    902              {
    903                  TRACE_ERROR((0, "HT68F30_LightBar_task task create failure " ));
    904              }
    905          }
    906          
    907          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  HT68F30_BlinkFadeToDarkConverter
             16 -> HT68F30_CleanALL
        0  HT68F30_BreathClear
              0 -> HT68F30_CleanLED
       16  HT68F30_BreathConverter
             16 -> HT68F30_CleanALL
       12  HT68F30_CleanALL
       12  HT68F30_CleanLED
        0  HT68F30_DarkConverter
        0  HT68F30_DemoTimeOutLED
              0 -> HT68F30_StepsConverter
       32  HT68F30_FadeToDarkConverter
             32 -> HT68F30_CleanALL
       16  HT68F30_Flashing
             16 -> HT68F30_CleanALL
        0  HT68F30_IsControllingLED
        0  HT68F30_LightBarControl
              0 -> HT68F30_WriteI2C_Byte
       24  HT68F30_LightBar_CreateTask
              0 -> Debug_printError
             24 -> xTaskGenericCreate
       24  HT68F30_LightBar_task
             24 -> HT68F30_DemoTimeOutLED
             24 -> HT68F30_MuteLED
             24 -> HT68F30_WriteI2C_Byte
             24 -> vTaskDelay
       24  HT68F30_LightConverter
             24 -> HT68F30_CleanALL
        0  HT68F30_MuteLED
              0 -> HT68F30_BreathConverter
       16  HT68F30_ScanningConverter
             16 -> HT68F30_CleanALL
       20  HT68F30_Set
        0  HT68F30_StepsClear
       16  HT68F30_StepsConverter
             16 -> HT68F30_CleanALL
        0  HT68F30_UpdateDemoTimeOutState
       16  HT68F30_Version
             16 -> Debug_printDebug
             16 -> HT68F30_CleanALL
        0  HT68F30_setStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  ?<Constant "HT68F30_LightBar_task">
      44  ?<Constant "HT68F30_LightBar_task...">
      24  ?<Constant "LED_VOL_LEVEL_NUM=%X">
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
      20  ?Subroutine0
       6  ?Subroutine1
      10  ?Subroutine2
      80  HT68F30_BlinkFadeToDarkConverter
      10  HT68F30_BreathClear
      50  HT68F30_BreathConverter
      78  HT68F30_CleanALL
      60  HT68F30_CleanLED
      44  HT68F30_DarkConverter
      14  HT68F30_DemoTimeOutLED
     120  HT68F30_FadeToDarkConverter
      94  HT68F30_Flashing
      16  HT68F30_IsControllingLED
      18  HT68F30_LightBarControl
      56  HT68F30_LightBar_CreateTask
     444  HT68F30_LightBar_task
      88  HT68F30_LightConverter
      14  HT68F30_MuteLED
      72  HT68F30_ObjCtrl
      50  HT68F30_ScanningConverter
      84  HT68F30_Set
      34  HT68F30_StepsClear
      86  HT68F30_StepsConverter
       6  HT68F30_UpdateDemoTimeOutState
     154  HT68F30_Version
      14  HT68F30_setStatus
       1  LightBar_DemoTimeOut
       8  mHT68F30Parms
     112  mLightBarParams
       4  mLightBar_Duty1
     112  mNewLightBarParams
      13  nFlashCount
          nFlashSpeedTarget
          nFlashSpeed
          bFlasgingVector
          bStandby
          nStepsEndNum
          nScanNum
          nStepsNum
          nScanCount
          nStepsCount
          bBreatheVector
          bScanningVector
          bStepsVector
       4  pLED_ObjCtrl

 
     9 bytes in section .bss
   241 bytes in section .data
    72 bytes in section .rodata
 1 770 bytes in section .text
 
 1 770 bytes of CODE  memory
    72 bytes of CONST memory
   250 bytes of DATA  memory

Errors: none
Warnings: 4

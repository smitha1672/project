###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:25:31 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Utilities\mainstream_v1\stm32f411\EepromDriver.c      #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Utilities\mainstream_v1\stm32f411\EepromDriver.c -D   #
#                    S4051A -D DEBUG -D FREE_RTOS -D STM32F40_41xxx -D        #
#                    USE_STM324xG_EVAL -D USE_STDPERIPH_DRIVER -D             #
#                    __ARM_CORTEX_MX__ -D IAR_ARM_CM4F -D USE_USB_OTG_FS      #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applicati #
#                    on\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Ap #
#                    plication\Obj\ --debug --endian=little --cpu=Cortex-M4   #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\EepromDriver.lst                                      #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\EepromDriver.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Utilities\mainstream_v1\stm32f411\EepromDriver.c
      1          #include "freertos_conf.h"
      2          #include "freertos_task.h"
      3          #include "freertos_typedef.h"
      4          #include "api_typedef.h"
      5          
      6          #include "Config.h"
      7          #include "GPIOMiddleLevel.h"
      8          #include "CardLowLevel.h"
      9          #include "Debug.h"
     10          #include "EepromDriver.h"
     11          #include "I2C1LowLevel.h"
     12          //_________________________________________________________________________
     13          #define DEBUG_EEPROM_WRITE 0
     14          #define configEEPROM_VERIFY_WRITE 0
     15          
     16          /*------------------------ Private Variables ---------------------------------*/
     17          /** The EEPROM PAGE size. The APP can write EEPROM_PAGE_SIZE amount of
     18           *  consecutive bytes.
     19           */
     20          
     21          
     22          /**
     23           * Verify the writing.
     24           *
     25           * @param device EEPROM device ID
     26           * @param address A address to get the data from.
     27           * @param buff  A pointer to the buffer to get the data from.
     28           * @param size  The amount of bytes to verify.
     29           *
     30           * @return      TRUE in case of verify successful. FALSE otherwise.
     31           */
     32          
     33          #if ( configEEPROM_VERIFY_WRITE == 1 )
     34          static bool EepromDriver_verifyWrite(LOGICAL_EEPROM_DEVICE device,
     35                                               uint8 address, uint8 *buff, uint16 size);
     36          #endif
     37          
     38          /*
     39           * Writes a buffer to the EEPROM.
     40           *
     41           * @param device    The EEPROM device ID.
     42           * @param addr  the EEPROM internal address to start the write operation.
     43           * @param buff  A pointer to the buffer to get the data from.
     44           * @param size  The amount of bytes to write.
     45           * @param verify Verify write
     46           *
     47           * @return      TRUE in case of write successful. FALSE otherwise.
     48           */
     49          static bool EepromDriver_writeData(LOGICAL_EEPROM_DEVICE device,
     50                                             uint16 addr,
     51                                             uint8 *buff,
     52                                             uint16 size,
     53                                             bool verify);
     54          
     55          /*
     56           * Read a buffer from the EEPROM.
     57           *
     58           * @param device    The EEPROM device ID.
     59           * @param addr  the EEPROM internal address to start the read operation.
     60           * @param buff  A pointer to the buffer to write the data to.
     61           * @param size  The amount of bytes to read.
     62           *
     63           * @return      TRUE in case of read successful. FALSE otherwise.
     64           */
     65          static bool EepromDriver_readData(LOGICAL_EEPROM_DEVICE device,
     66                                            uint16 addr,
     67                                            uint8 *buff,
     68                                            uint16 size);
     69          
     70          
     71          /** */
     72          static EEPROM_type m_logicalToPhysicalEeprom[LOGICAL_EEPROM_LAST];
     73          
     74          /*------------------------ Public Functions ----------------------------------*/
     75          bool EepromDriver_initialize()
     76          {
     77              int i;
     78              for (i = 0; i < LOGICAL_EEPROM_LAST; ++i)
     79              {
     80                  m_logicalToPhysicalEeprom[i].I2CAddress = EEPROM_UNDEF_ADDRESS;
     81              }
     82          
     83              return TRUE;
     84          }
     85          
     86          /*----------------------------------------------------------------------------*/
     87          bool EepromDriver_mapLogicalToPhysical(LOGICAL_EEPROM_DEVICE device,
     88                                                 uint8 I2CAddr,
     89                                                 uint16 capacity,
     90                                                 uint16 pageSize,
     91                                                 uint8  chunkSize)
     92          {
     93              if (device >= LOGICAL_EEPROM_LAST)
     94              {
     95                  ASSERT_BOOL(TRUE);
     96              }
     97          
     98              m_logicalToPhysicalEeprom[(uint8)device].I2CAddress = I2CAddr;
     99              m_logicalToPhysicalEeprom[(uint8)device].capacity = capacity;
    100              m_logicalToPhysicalEeprom[(uint8)device].pageSize = pageSize;
    101              m_logicalToPhysicalEeprom[(uint8)device].chunkSize = chunkSize;
    102          
    103              return TRUE;
    104          }
    105          /*----------------------------------------------------------------------------*/
    106          bool EepromDriver_write(LOGICAL_EEPROM_DEVICE device,
    107                                  uint16 addr,
    108                                  uint8 *buff,
    109                                  uint16 size,
    110                                  bool verify)
    111          {
    112              bool retVal = TRUE;
    113          
    114              if (App_I2C1_sema_mutex_take() != TRUE)
    115              {
    116                  return FALSE;
    117              }
    118          
    119              /* Write to EEprom */
    120              retVal = EepromDriver_writeData(device, addr, buff, size, verify);
    121          
    122              App_I2C1_sema_mutex_give();
    123              
    124              return retVal;
    125          }
    126          
    127          /*----------------------------------------------------------------------------*/
    128          bool EepromDriver_read(LOGICAL_EEPROM_DEVICE device,
    129                                 uint16 addr,
    130                                 uint8 *buff,
    131                                 uint16 size)
    132          {
    133              bool retVal = TRUE;
    134          
    135              if (App_I2C1_sema_mutex_take() != TRUE)
    136              {
    137                  return FALSE;
    138              }
    139          
    140              /* Read from EEprom */
    141              retVal = EepromDriver_readData(device, addr, buff, size);
    142          
    143              App_I2C1_sema_mutex_give();
    144          
    145              return retVal;
    146          }
    147          
    148          /*----------------------------------------------------------------------------*/
    149          bool EepromDriver_erase(LOGICAL_EEPROM_DEVICE device)
    150          {
    151              uint8 eraseValue = EEPROM_DEVICE_ERASE_VALUE;
    152              bool retVal = TRUE;
    153              int i;
    154          
    155              if (device >= LOGICAL_EEPROM_LAST)
    156              {
    157                  ASSERT_BOOL(TRUE);
    158              }
    159          
    160              if (m_logicalToPhysicalEeprom[device].I2CAddress == EEPROM_UNDEF_ADDRESS)
    161              {
    162                  return FALSE;
    163              }
    164          
    165              if (device >= LOGICAL_EEPROM_LAST)
    166              {
    167                  ASSERT_BOOL(TRUE);
    168              }
    169          
    170              for (i = 0; i < m_logicalToPhysicalEeprom[device].capacity; ++i)
    171              {
    172                  retVal &= EepromDriver_write(device, i, &eraseValue, 1, TRUE);
    173          
    174                  ASSERT(retVal == FALSE);
    175              }
    176          
    177              return retVal;
    178          }
    179          
    180          /*----------------------------------------------------------------------------*/
    181          #if ( DEBUG_EEPROM_WRITE == 1 )	
    182          static bool vI2C_writeSlave(byte control, uint16 address, byte *data, uint16 length, bool longAddr)
    183          {
    184          	int i = 0;
    185          
    186          	for( i = 0; i < length; i++ )
    187          	{
    188          		TRACE_DEBUG((0, "device addr = 0x%X, data[0x0%X] = 0x%X", control, (address + i), *(data + i ) ));
    189          		vTaskDelay( 5 );
    190          	}
    191          
    192          	return TRUE;
    193          }
    194          #endif 
    195          
    196          static bool EepromDriver_writeData(LOGICAL_EEPROM_DEVICE device,
    197                                             uint16 addr,
    198                                             uint8 *buff,
    199                                             uint16 size,
    200                                             bool verify)
    201          {
    202          
    203          	uint8 writeIndexFront = 0;
    204          	uint8 writeIndexRear = size;	
    205          	uint16 address = addr;	
    206          	uint8 deviceAddress = 0;
    207          	uint8 NeedchunkNum = 0;
    208          	uint8 WhichChunk = 0;
    209          	int16 chunkFreeSize = 0;
    210          	uint8 writeSize = 0;
    211          	uint16 offset = 0;
    212          	uint8 chunkSize;
    213          	bool retVal = TRUE;
    214          	uint16 pageSize = 0;
    215          
    216              if (device >= LOGICAL_EEPROM_LAST)
    217              {
    218          		TRACE_ERROR((0, "Assert failed %s[%d]", __FILE__, __LINE__));
    219          		return FALSE;
    220              }
    221          
    222              if (m_logicalToPhysicalEeprom[device].I2CAddress == EEPROM_UNDEF_ADDRESS)
    223              {
    224                  return FALSE;
    225              }
    226          
    227              pageSize = m_logicalToPhysicalEeprom[device].pageSize;
    228              chunkSize = m_logicalToPhysicalEeprom[device].chunkSize;
    229          
    230              /** Check if the address bigger then the eeprom capacity */
    231              if ((addr + size) > m_logicalToPhysicalEeprom[device].capacity )
    232              {
    233          		TRACE_ERROR((0, "Over EEPROM capacity !!"));
    234                  return FALSE;
    235              }
    236          	
    237          	GPIOMiddleLevel_Set( __O_MCU_EEPROM_WP );  //High EEPROM Unprotect so set Low
    238          	
    239          	WhichChunk = ( addr/chunkSize );
    240          	chunkFreeSize =( ( (WhichChunk*chunkSize) + chunkSize ) - addr - size );
    241          
    242          #if ( DEBUG_EEPROM_WRITE == 1 )	
    243          	TRACE_DEBUG((0, "which chunk = %d", WhichChunk ));
    244          	TRACE_DEBUG((0, "chunkFreeSize = %d", chunkFreeSize  ));
    245          #endif 
    246          
    247          	if ( chunkFreeSize < 0 )
    248          	{
    249          		NeedchunkNum = ( (0 - chunkFreeSize)/chunkSize )+( ((0 - chunkFreeSize)%chunkSize) != 0 );
    250          
    251          #if ( DEBUG_EEPROM_WRITE == 1 )		
    252          		TRACE_DEBUG((0, "Need chunk num = %d", NeedchunkNum ));
    253          #endif 
    254          		if ( NeedchunkNum <= 1 )
    255          		{
    256          			writeSize = ( ( (WhichChunk*chunkSize) + chunkSize ) - addr );
    257          
    258          #if ( DEBUG_EEPROM_WRITE == 1 )		
    259          			TRACE_DEBUG((0, "writeSize = %d", writeSize ));
    260          #endif 
    261          			if ( address+writeIndexFront >= pageSize )
    262          			{
    263          				deviceAddress = ( m_logicalToPhysicalEeprom[device].I2CAddress + 2 );
    264          				offset = 0x100;
    265          			}
    266          			else
    267          			{
    268          				deviceAddress = m_logicalToPhysicalEeprom[device].I2CAddress;
    269          				offset = 0;
    270          			}
    271          
    272          			retVal = I2C_writeSlave(deviceAddress, (address+writeIndexFront-offset), (buff+writeIndexFront), writeSize, FALSE, TRUE );
    273          			if ( retVal == TRUE )
    274          			{
    275          				writeIndexFront = ( writeIndexFront + writeSize);
    276          			}
    277          			else
    278          			{
    279          				GPIOMiddleLevel_Clr( __O_MCU_EEPROM_WP );  //High EEPROM Unprotect so set Low
    280          				TRACE_ERROR((0, "EEPROM WRITE failed %s[%d]", __FILE__, __LINE__));
    281          				return retVal;
    282          			}
    283          
    284          			if ( (writeIndexRear - writeIndexFront) > 0 )
    285          			{
    286          				writeSize = writeIndexRear - writeIndexFront;
    287          
    288          				if ( address+writeIndexFront >= pageSize )
    289          				{
    290          					deviceAddress = ( m_logicalToPhysicalEeprom[device].I2CAddress + 2 );
    291          					offset = 0x100;
    292          				}
    293          				else
    294          				{
    295          					deviceAddress = m_logicalToPhysicalEeprom[device].I2CAddress;
    296          					offset = 0;
    297          				}
    298          
    299          				retVal = I2C_writeSlave(deviceAddress, (address+writeIndexFront-offset), (buff+writeIndexFront), writeSize, FALSE, TRUE);
    300          				if ( retVal == TRUE )
    301          				{
    302          					writeIndexFront = (writeIndexFront + writeSize); 
    303          					
    304          #if ( DEBUG_EEPROM_WRITE == 1 )		
    305          					TRACE_DEBUG((0, "writeIndexFront = %d; writeIndexRear = %d", writeIndexFront, writeIndexRear ));
    306          #endif 
    307          				}
    308          				else
    309          				{
    310          					GPIOMiddleLevel_Clr( __O_MCU_EEPROM_WP );  //High EEPROM Unprotect so set Low
    311          					TRACE_ERROR((0, "EEPROM WRITE failed %s[%d]", __FILE__, __LINE__));
    312          					return retVal;
    313          				}
    314          			}
    315          		}
    316          		else if ( NeedchunkNum > 1 )
    317          		{
    318          			writeSize = ( ( (WhichChunk*chunkSize) + chunkSize ) - addr );
    319          
    320          #if ( DEBUG_EEPROM_WRITE == 1 )		
    321          			TRACE_DEBUG((0, "2 writeSize = %d", writeSize ));
    322          #endif 
    323          			if ( address+writeIndexFront >= pageSize )
    324          			{
    325          				deviceAddress = ( m_logicalToPhysicalEeprom[device].I2CAddress + 2 );
    326          				offset = 0x100;
    327          			}
    328          			else
    329          			{
    330          				deviceAddress = m_logicalToPhysicalEeprom[device].I2CAddress;
    331          				offset = 0;
    332          			}
    333          
    334          			retVal = I2C_writeSlave(deviceAddress, (address+writeIndexFront-offset), (buff+writeIndexFront), writeSize, FALSE, TRUE );
    335          			if (  retVal == TRUE )
    336          			{
    337          				writeIndexFront = ( writeIndexFront + writeSize);
    338          				
    339          #if ( DEBUG_EEPROM_WRITE == 1 )		
    340          				TRACE_DEBUG((0, "2writeIndexFront = %d; writeIndexRear = %d", writeIndexFront, writeIndexRear ));
    341          #endif 
    342          			}
    343          			else
    344          			{
    345          				GPIOMiddleLevel_Clr( __O_MCU_EEPROM_WP );  //High EEPROM Unprotect so set Low
    346          				TRACE_ERROR((0, "EEPROM WRITE failed %s[%d]", __FILE__, __LINE__));
    347          				return retVal;
    348          			}
    349          
    350          			do
    351          			{
    352          				if( (writeIndexRear - writeIndexFront)/ chunkSize )
    353          				{
    354          					if ( address+writeIndexFront >= pageSize )
    355          					{
    356          						deviceAddress = ( m_logicalToPhysicalEeprom[device].I2CAddress + 2 );
    357          						offset = 0x100;
    358          					}
    359          					else
    360          					{
    361          						deviceAddress = m_logicalToPhysicalEeprom[device].I2CAddress;
    362          						offset = 0;
    363          					}
    364          
    365          					writeSize = chunkSize;
    366          					retVal = I2C_writeSlave(deviceAddress, (address+writeIndexFront-offset), (buff+writeIndexFront), writeSize, FALSE, TRUE );
    367          					if ( retVal == TRUE )
    368          					{
    369          						writeIndexFront = (writeIndexFront + writeSize);
    370          					}
    371          					else
    372          					{
    373          						GPIOMiddleLevel_Clr( __O_MCU_EEPROM_WP );  //High EEPROM Unprotect so set Low
    374          						TRACE_ERROR((0, "EEPROM WRITE failed %s[%d]", __FILE__, __LINE__));
    375          						return retVal;
    376          					}
    377          				}
    378          				else
    379          				{
    380          					if ( address+writeIndexFront >= pageSize )
    381          					{
    382          						deviceAddress = ( m_logicalToPhysicalEeprom[device].I2CAddress + 2 );
    383          						offset = 0x100;
    384          					}
    385          					else
    386          					{
    387          						deviceAddress = m_logicalToPhysicalEeprom[device].I2CAddress;
    388          						offset = 0;
    389          					}
    390          					
    391          					writeSize = writeIndexRear - writeIndexFront;
    392          					retVal = I2C_writeSlave(deviceAddress, (address+writeIndexFront-offset), (buff+writeIndexFront), writeSize, FALSE, TRUE);
    393          					if ( retVal == TRUE )
    394          					{
    395          						writeIndexFront = (writeIndexFront + writeSize);
    396          					}
    397          					else
    398          					{
    399          						GPIOMiddleLevel_Clr( __O_MCU_EEPROM_WP );  //High EEPROM Unprotect so set Low
    400          						TRACE_ERROR((0, "EEPROM WRITE failed %s[%d]", __FILE__, __LINE__));
    401          						return retVal;
    402          					}
    403          					break;
    404          				}
    405          			}while( writeIndexFront < writeIndexRear );
    406          
    407          #if ( DEBUG_EEPROM_WRITE == 1 )
    408          			TRACE_DEBUG((0, "2 writeIndexFront = %d; writeIndexRear = %d", writeIndexFront, writeIndexRear ));
    409          #endif 
    410          
    411          		}
    412          
    413          	}
    414          	else
    415          	{
    416          		deviceAddress = m_logicalToPhysicalEeprom[device].I2CAddress;	
    417          		retVal = I2C_writeSlave(deviceAddress, (address+writeIndexFront), buff, size, FALSE, TRUE);
    418          		if ( retVal == FALSE )
    419          		{
    420          			GPIOMiddleLevel_Clr( __O_MCU_EEPROM_WP );  //High EEPROM Unprotect so set Low
    421          			TRACE_ERROR((0, "EEPROM WRITE failed %s[%d]", __FILE__, __LINE__));
    422          			return retVal;
    423          		}
    424          	}
    425          
    426          	GPIOMiddleLevel_Clr( __O_MCU_EEPROM_WP );  //High EEPROM Unprotect so set Low
    427              return retVal;
    428          }
    429          
    430          /*----------------------------------------------------------------------------*/
    431          static bool EepromDriver_readData(LOGICAL_EEPROM_DEVICE device,
    432                                            uint16 addr,
    433                                            uint8 *buff,
    434                                            uint16 size)
    435          {
    436              bool retVal = TRUE;
    437              uint8 deviceAddress;
    438              uint16 pageSize;
    439              bool i2c_status;
    440          
    441              if (device >= LOGICAL_EEPROM_LAST)
    442              {
    443                  ASSERT_BOOL(TRUE);
    444              }
    445          
    446              if (m_logicalToPhysicalEeprom[device].I2CAddress == EEPROM_UNDEF_ADDRESS)
    447              {
    448                  return FALSE;
    449              }
    450          
    451              pageSize = m_logicalToPhysicalEeprom[device].pageSize;
    452              deviceAddress = m_logicalToPhysicalEeprom[device].I2CAddress;
    453          
    454              /** Check if the address + size bigger then the eeprom capacity */
    455              if ((addr + size) > m_logicalToPhysicalEeprom[device].capacity)
    456              {
    457                  ASSERT_BOOL(retVal == FALSE);
    458              }
    459          
    460              /** Increase the I2C address according to the page size */
    461              while ((addr - (int16)pageSize) >= 0)
    462              {
    463                  deviceAddress += 2;
    464                  addr -= pageSize;
    465              }
    466          
    467              /** Check if the data to read divided into two different pages */
    468              if ((addr + size) > pageSize)
    469              {
    470                  uint16 readSize = pageSize - addr;
    471          
    472                  /** Reading from more then one page */
    473                  while (size > 0)
    474                  {
    475                      /* Attempt reading data */
    476                      i2c_status = I2C_readSlave(
    477                                       deviceAddress,
    478                                       addr,
    479                                       (byte*)(buff),
    480                                       readSize,
    481                                       FALSE);
    482          
    483                      if (i2c_status != TRUE)
    484                      {
    485                          retVal = FALSE;
    486                      }
    487                      ASSERT(retVal == FALSE);
    488          
    489                      /** For the next loop */
    490                      addr = 0;
    491                      deviceAddress += 2;
    492          
    493                      /** Calculating the amount of data left to read */
    494                      size -= readSize;
    495          
    496                      /** Sets the readSize for the next loop */
    497                      if (size >= pageSize)
    498                      {
    499                          /** More the one page left so in the next time
    500                              we will read the whole page */
    501                          readSize = pageSize;
    502                      }
    503                      else
    504                      {
    505                          /** Just one page left to read, read only the residual*/
    506                          readSize = size;
    507                      }
    508                  }
    509              }
    510              else
    511              {
    512                  /** Normal read opreation */
    513                  /** attempt reading data */
    514                  i2c_status = I2C_readSlave(
    515                                       deviceAddress,
    516                                       addr,
    517                                       (byte*)(buff),
    518                                       size,
    519                                       FALSE);
    520          
    521                  if (i2c_status != TRUE)
    522                  {
    523                      retVal = FALSE;
    524                  }
    525          
    526                  ASSERT(retVal);
    527              }
    528          
    529              return retVal;
    530          }
    531          
    532          /*----------------------------------------------------------------------------*/
    533          bool EepromDriver_print(LOGICAL_EEPROM_DEVICE device, uint16 addr, uint16 size)
    534          {
    535              bool retVal = TRUE;
    536          #ifdef EEPROM_DEBUG_ENABLE
    537              uint8 buff[EEPROM_DEVICE_ITEMS_IN_LINE];
    538              int i;
    539          
    540          
    541              if (device >= LOGICAL_EEPROM_LAST)
    542              {
    543                  ASSERT_BOOL(TRUE);
    544              }
    545          
    546              if (m_logicalToPhysicalEeprom[device].I2CAddress == EEPROM_UNDEF_ADDRESS)
    547              {
    548                  return FALSE;
    549              }
    550          
    551          
    552              if (device >= LOGICAL_EEPROM_LAST)
    553              {
    554                  ASSERT_BOOL(TRUE);
    555              }
    556          
    557              TRACE_DEBUG((0, "------------------------------------------------------------"));
    558              TRACE_DEBUG((0, "        0  |  1   |  2   |  3   |  4   |  5   |  6   |  7  "));
    559          
    560              for (i = 0; i < size; i += EEPROM_DEVICE_ITEMS_IN_LINE)
    561              {
    562                  /** Reading from eeprom */
    563                  retVal &= EepromDriver_read(device,
    564                                              (uint16)(addr + i),
    565                                              buff,
    566                                              (uint16)EEPROM_DEVICE_ITEMS_IN_LINE);
    567          
    568                  ASSERT_BOOL(retVal == FALSE);
    569          
    570                  /** printing one line */
    571                  TRACE_DEBUG((STR_ID_NULL, "| "));
    572                  TRACE_DEBUG((STR_ID_NULL,
    573                               "| %X | 0x%X | 0x%X | 0x%X | 0x%X | 0x%X | 0x%X | 0x%X | 0x%X ",
    574                               (uint8)i,
    575                               buff[0], buff[1], buff[2], buff[3],
    576                               buff[4], buff[5], buff[6], buff[7]));
    577          
    578              }
    579          #endif
    580              return retVal;
    581          }
    582          
    583          /*----------------------------------------------------------------------------*/
    584          uint16 EepromDriver_deviceCapacity(LOGICAL_EEPROM_DEVICE device)
    585          {
    586              if (device >= LOGICAL_EEPROM_LAST)
    587              {
    588                  return 0;
    589              }
    590          
    591              if (m_logicalToPhysicalEeprom[device].I2CAddress == EEPROM_UNDEF_ADDRESS)
    592              {
    593                  return 0;
    594              }
    595          
    596              return m_logicalToPhysicalEeprom[device].capacity;
    597          }
    598          
    599          /*----------------------------------------------------------------------------*/
    600          #if ( configEEPROM_VERIFY_WRITE == 1 )
    601          static bool EepromDriver_verifyWrite(LOGICAL_EEPROM_DEVICE device,
    602                                               uint8 address, uint8 *buff, uint16 size)
    603          {
    604              uint8 data[16];
    605              bool retVal = TRUE;
    606              int i;
    607              int x;
    608              uint16 verify_size;
    609          
    610              if (size < sizeof(data))
    611              {
    612                  verify_size = size;
    613              }
    614              else
    615              {
    616                  verify_size = sizeof(data);
    617              }
    618          
    619              for (i = 0; i < size; i += verify_size)
    620              {
    621                  retVal &= EepromDriver_readData(device,
    622                                                  (address + i),
    623                                                  data,
    624                                                  verify_size);
    625          
    626                  for (x = 0; (x < verify_size) && (x < size); x++)
    627                  {
    628                      if (data[x] != *(buff + i + x))
    629                      {
    630                          retVal &= FALSE;
    631                      }
    632                  }
    633              }
    634          
    635              return retVal;
    636          }
    637          #endif
    638          
    639          
    640          
    641          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  EepromDriver_deviceCapacity
       40  EepromDriver_erase
             40 -> Debug_printError
             40 -> EepromDriver_write
        0  EepromDriver_initialize
       12  EepromDriver_mapLogicalToPhysical
        0  EepromDriver_print
       24  EepromDriver_read
             24 -> App_I2C1_sema_mutex_give
             24 -> App_I2C1_sema_mutex_take
             24 -> EepromDriver_readData
       40  EepromDriver_readData
             40 -> Debug_printError
             40 -> I2C_readSlave
       32  EepromDriver_write
             32 -> App_I2C1_sema_mutex_give
             32 -> App_I2C1_sema_mutex_take
             32 -> EepromDriver_writeData
       56  EepromDriver_writeData
             56 -> Debug_printError
             56 -> GPIOMiddleLevel_Clr
             56 -> GPIOMiddleLevel_Set
             56 -> I2C_writeSlave


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  ?<Constant "Assert failed %s[%d]">
     108  ?<Constant "C:\\Users\\tony.tsou\\De...">
      28  ?<Constant "EEPROM WRITE failed %...">
      24  ?<Constant "Over EEPROM capacity !!">
       4  ??DataTable9
      22  ?Subroutine0
       6  ?Subroutine1
      10  ?Subroutine2
      10  ?Subroutine3
      18  EepromDriver_deviceCapacity
      90  EepromDriver_erase
      12  EepromDriver_initialize
      26  EepromDriver_mapLogicalToPhysical
       4  EepromDriver_print
      44  EepromDriver_read
     180  EepromDriver_readData
      54  EepromDriver_write
     492  EepromDriver_writeData
       8  m_logicalToPhysicalEeprom

 
     8 bytes in section .bss
 1 156 bytes in section .text
 
 1 156 bytes of CODE memory
     8 bytes of DATA memory

Errors: none
Warnings: 1

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:24:16 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\FreeRTOS\Source\tasks.c                     #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\FreeRTOS\Source\tasks.c -D S4051A -D DEBUG  #
#                    -D FREE_RTOS -D STM32F40_41xxx -D USE_STM324xG_EVAL -D   #
#                    USE_STDPERIPH_DRIVER -D __ARM_CORTEX_MX__ -D             #
#                    IAR_ARM_CM4F -D USE_USB_OTG_FS -lcN                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\ #
#                    DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applica #
#                    tion\Obj\ --debug --endian=little --cpu=Cortex-M4 -e     #
#                    --fpu=VFPv4_sp --dlib_config "C:\Program Files           #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\tasks.lst                                             #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\tasks.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Libraries\FreeRTOS\Source\tasks.c
      1          /*
      2              FreeRTOS V8.0.0:rc2 - Copyright (C) 2014 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              ***************************************************************************
      8               *                                                                       *
      9               *    FreeRTOS provides completely free yet professionally developed,    *
     10               *    robust, strictly quality controlled, supported, and cross          *
     11               *    platform software that has become a de facto standard.             *
     12               *                                                                       *
     13               *    Help yourself get started quickly and support the FreeRTOS         *
     14               *    project by purchasing a FreeRTOS tutorial book, reference          *
     15               *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
     16               *                                                                       *
     17               *    Thank you!                                                         *
     18               *                                                                       *
     19              ***************************************************************************
     20          
     21              This file is part of the FreeRTOS distribution.
     22          
     23              FreeRTOS is free software; you can redistribute it and/or modify it under
     24              the terms of the GNU General Public License (version 2) as published by the
     25              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     26          
     27              >>! NOTE: The modification to the GPL is included to allow you to distribute
     28              >>! a combined work that includes FreeRTOS without being obliged to provide
     29              >>! the source code for proprietary components outside of the FreeRTOS
     30              >>! kernel.
     31          
     32              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     33              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     34              FOR A PARTICULAR PURPOSE.  Full license text is available from the following
     35              link: http://www.freertos.org/a00114.html
     36          
     37              1 tab == 4 spaces!
     38          
     39              ***************************************************************************
     40               *                                                                       *
     41               *    Having a problem?  Start by reading the FAQ "My application does   *
     42               *    not run, what could be wrong?"                                     *
     43               *                                                                       *
     44               *    http://www.FreeRTOS.org/FAQHelp.html                               *
     45               *                                                                       *
     46              ***************************************************************************
     47          
     48              http://www.FreeRTOS.org - Documentation, books, training, latest versions,
     49              license and Real Time Engineers Ltd. contact details.
     50          
     51              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     52              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     53              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     54          
     55              http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
     56              Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
     57              licenses offer ticketed support, indemnification and middleware.
     58          
     59              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     60              engineered and independently SIL3 certified version for use in safety and
     61              mission critical applications that require provable dependability.
     62          
     63              1 tab == 4 spaces!
     64          */
     65          
     66          /* Standard includes. */
     67          #include <stdlib.h>
     68          #include <string.h>
     69          
     70          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     71          all the API functions to use the MPU wrappers.  That should only be done when
     72          task.h is included from an application file. */
     73          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     74          
     75          /* FreeRTOS includes. */
     76          #include "FreeRTOS.h"
     77          #include "task.h"
     78          #include "timers.h"
     79          #include "StackMacros.h"
     80          
     81          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     82          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     83          header files above, but not in this file, in order to generate the correct
     84          privileged Vs unprivileged linkage and placement. */
     85          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     86          
     87          #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
     88          	/* At the bottom of this file are two optional functions that can be used
     89          	to generate human readable text from the raw data generated by the
     90          	uxTaskGetSystemState() function.  Note the formatting functions are provided
     91          	for convenience only, and are NOT considered part of the kernel. */
     92          	#include <stdio.h>
     93          #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
     94          
     95          /* Sanity check the configuration. */
     96          #if configUSE_TICKLESS_IDLE != 0
     97          	#if INCLUDE_vTaskSuspend != 1
     98          		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
     99          	#endif /* INCLUDE_vTaskSuspend */
    100          #endif /* configUSE_TICKLESS_IDLE */
    101          
    102          /*
    103           * Defines the size, in words, of the stack allocated to the idle task.
    104           */
    105          #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
    106          
    107          #if( configUSE_PREEMPTION == 0 )
    108          	/* If the cooperative scheduler is being used then a yield should not be
    109          	performed just because a higher priority task has been woken. */
    110          	#define taskYIELD_IF_USING_PREEMPTION()
    111          #else
    112          	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
    113          #endif
    114          
    115          /*
    116           * Task control block.  A task control block (TCB) is allocated for each task,
    117           * and stores task state information, including a pointer to the task's context
    118           * (the task's run time environment, including register values)
    119           */
    120          typedef struct tskTaskControlBlock
    121          {
    122          	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
    123          
    124          	#if ( portUSING_MPU_WRAPPERS == 1 )
    125          		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    126          	#endif
    127          
    128          	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    129          	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
    130          	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
    131          	StackType_t			*pxStack;			/*< Points to the start of the stack. */
    132          	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    133          
    134          	#if ( portSTACK_GROWTH > 0 )
    135          		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
    136          	#endif
    137          
    138          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    139          		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    140          	#endif
    141          
    142          	#if ( configUSE_TRACE_FACILITY == 1 )
    143          		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    144          		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
    145          	#endif
    146          
    147          	#if ( configUSE_MUTEXES == 1 )
    148          		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    149          	#endif
    150          
    151          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    152          		TaskHookFunction_t pxTaskTag;
    153          	#endif
    154          
    155          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
    156          		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
    157          	#endif
    158          
    159          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
    160          		/* Allocate a Newlib reent structure that is specific to this task.
    161          		Note Newlib support has been included by popular demand, but is not
    162          		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
    163          		responsible for resulting newlib operation.  User must be familiar with
    164          		newlib and must provide system-wide implementations of the necessary
    165          		stubs. Be warned that (at the time of writing) the current newlib design
    166          		implements a system-wide malloc() that must be provided with locks. */
    167          		struct 	_reent xNewLib_reent;
    168          	#endif
    169          
    170          } TCB_t;
    171          
    172          /*
    173           * Some kernel aware debuggers require the data the debugger needs access to to
    174           * be global, rather than file scope.
    175           */
    176          #ifdef portREMOVE_STATIC_QUALIFIER
    177          	#define static
    178          #endif
    179          
    180          /*lint -e956 A manual analysis and inspection has been used to determine which
    181          static variables must be declared volatile. */
    182          
    183          PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
    184          
    185          /* Lists for ready and blocked tasks. --------------------*/
    186          PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
    187          PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
    188          PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
    189          PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
    190          PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
    191          PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
    192          
    193          #if ( INCLUDE_vTaskDelete == 1 )
    194          
    195          	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
    196          	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
    197          
    198          #endif
    199          
    200          #if ( INCLUDE_vTaskSuspend == 1 )
    201          
    202          	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
    203          
    204          #endif
    205          
    206          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
    207          
    208          	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
    209          
    210          #endif
    211          
    212          /* Other file private variables. --------------------------------*/
    213          PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
    214          PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
    215          PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
    216          PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
    217          PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
    218          PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
    219          PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
    220          PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
    221          PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
    222          PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= portMAX_DELAY;
    223          
    224          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    225          
    226          	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
    227          	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
    228          
    229          #endif
    230          
    231          /*lint +e956 */
    232          
    233          /* Debugging and trace facilities private variables and macros. ------------*/
    234          
    235          /*
    236           * The value used to fill the stack of a task when the task is created.  This
    237           * is used purely for checking the high water mark for tasks.
    238           */
    239          #define tskSTACK_FILL_BYTE	( 0xa5U )
    240          
    241          /*
    242           * Macros used by vListTask to indicate which state a task is in.
    243           */
    244          #define tskBLOCKED_CHAR		( 'B' )
    245          #define tskREADY_CHAR		( 'R' )
    246          #define tskDELETED_CHAR		( 'D' )
    247          #define tskSUSPENDED_CHAR	( 'S' )
    248          
    249          /*-----------------------------------------------------------*/
    250          
    251          #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
    252          
    253          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
    254          	performed in a generic way that is not optimised to any particular
    255          	microcontroller architecture. */
    256          
    257          	/* uxTopReadyPriority holds the priority of the highest priority ready
    258          	state task. */
    259          	#define taskRECORD_READY_PRIORITY( uxPriority )														\
    260          	{																									\
    261          		if( ( uxPriority ) > uxTopReadyPriority )														\
    262          		{																								\
    263          			uxTopReadyPriority = ( uxPriority );														\
    264          		}																								\
    265          	} /* taskRECORD_READY_PRIORITY */
    266          
    267          	/*-----------------------------------------------------------*/
    268          
    269          	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
    270          	{																									\
    271          		/* Find the highest priority queue that contains ready tasks. */								\
    272          		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
    273          		{																								\
    274          			configASSERT( uxTopReadyPriority );															\
    275          			--uxTopReadyPriority;																		\
    276          		}																								\
    277          																										\
    278          		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
    279          		the	same priority get an equal share of the processor time. */									\
    280          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
    281          	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
    282          
    283          	/*-----------------------------------------------------------*/
    284          
    285          	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
    286          	they are only required when a port optimised method of task selection is
    287          	being used. */
    288          	#define taskRESET_READY_PRIORITY( uxPriority )
    289          	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    290          
    291          #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    292          
    293          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
    294          	performed in a way that is tailored to the particular microcontroller
    295          	architecture being used. */
    296          
    297          	/* A port optimised version is provided.  Call the port defined macros. */
    298          	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    299          
    300          	/*-----------------------------------------------------------*/
    301          
    302          	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
    303          	{																								\
    304          	UBaseType_t uxTopPriority;																		\
    305          																									\
    306          		/* Find the highest priority queue that contains ready tasks. */							\
    307          		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
    308          		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
    309          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
    310          	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
    311          
    312          	/*-----------------------------------------------------------*/
    313          
    314          	/* A port optimised version is provided, call it only if the TCB being reset
    315          	is being referenced from a ready list.  If it is referenced from a delayed
    316          	or suspended list then it won't be in a ready list. */
    317          	#define taskRESET_READY_PRIORITY( uxPriority )													\
    318          	{																								\
    319          		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
    320          		{																							\
    321          			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
    322          		}																							\
    323          	}
    324          
    325          #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    326          
    327          /*-----------------------------------------------------------*/
    328          
    329          /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
    330          count overflows. */
    331          #define taskSWITCH_DELAYED_LISTS()																	\
    332          {																									\
    333          	List_t *pxTemp;																					\
    334          																									\
    335          	/* The delayed tasks list should be empty when the lists are switched. */						\
    336          	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
    337          																									\
    338          	pxTemp = pxDelayedTaskList;																		\
    339          	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
    340          	pxOverflowDelayedTaskList = pxTemp;																\
    341          	xNumOfOverflows++;																				\
    342          	prvResetNextTaskUnblockTime();																	\
    343          }
    344          
    345          /*-----------------------------------------------------------*/
    346          
    347          /*
    348           * Place the task represented by pxTCB into the appropriate ready list for
    349           * the task.  It is inserted at the end of the list.
    350           */
    351          #define prvAddTaskToReadyList( pxTCB )																\
    352          	traceMOVED_TASK_TO_READY_STATE( pxTCB )															\
    353          	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
    354          	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
    355          /*-----------------------------------------------------------*/
    356          
    357          /*
    358           * Several functions take an TaskHandle_t parameter that can optionally be NULL,
    359           * where NULL is used to indicate that the handle of the currently executing
    360           * task should be used in place of the parameter.  This macro simply checks to
    361           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    362           */
    363          #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
    364          
    365          /* The item value of the event list item is normally used to hold the priority
    366          of the task to which it belongs (coded to allow it to be held in reverse
    367          priority order).  However, it is occasionally borrowed for other purposes.  It
    368          is important its value is not updated due to a task priority change while it is
    369          being used for another purpose.  The following bit definition is used to inform
    370          the scheduler that the value should not be changed - in which case it is the
    371          responsibility of whichever module is using the value to ensure it gets set back
    372          to its original value when it is released. */
    373          #if configUSE_16_BIT_TICKS == 1
    374          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
    375          #else
    376          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
    377          #endif
    378          
    379          /* Callback function prototypes. --------------------------*/
    380          #if configCHECK_FOR_STACK_OVERFLOW > 0
    381          	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
    382          #endif
    383          
    384          #if configUSE_TICK_HOOK > 0
    385          	extern void vApplicationTickHook( void );
    386          #endif
    387          
    388          /* File private functions. --------------------------------*/
    389          
    390          /*
    391           * Utility to ready a TCB for a given task.  Mainly just copies the parameters
    392           * into the TCB structure.
    393           */
    394          static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    395          
    396          /*
    397           * Utility to ready all the lists used by the scheduler.  This is called
    398           * automatically upon the creation of the first task.
    399           */
    400          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    401          
    402          /*
    403           * The idle task, which as all tasks is implemented as a never ending loop.
    404           * The idle task is automatically created and added to the ready lists upon
    405           * creation of the first user task.
    406           *
    407           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    408           * language extensions.  The equivalent prototype for this function is:
    409           *
    410           * void prvIdleTask( void *pvParameters );
    411           *
    412           */
    413          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
    414          
    415          /*
    416           * Utility to free all memory allocated by the scheduler to hold a TCB,
    417           * including the stack pointed to by the TCB.
    418           *
    419           * This does not free memory allocated by the task itself (i.e. memory
    420           * allocated by calls to pvPortMalloc from within the tasks application code).
    421           */
    422          #if ( INCLUDE_vTaskDelete == 1 )
    423          
    424          	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
    425          
    426          #endif
    427          
    428          /*
    429           * Used only by the idle task.  This checks to see if anything has been placed
    430           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    431           * and its TCB deleted.
    432           */
    433          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    434          
    435          /*
    436           * The currently executing task is entering the Blocked state.  Add the task to
    437           * either the current or the overflow delayed task list.
    438           */
    439          static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
    440          
    441          /*
    442           * Allocates memory from the heap for a TCB and associated stack.  Checks the
    443           * allocation was successful.
    444           */
    445          static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer ) PRIVILEGED_FUNCTION;
    446          
    447          /*
    448           * Fills an TaskStatus_t structure with information on each task that is
    449           * referenced from the pxList list (which may be a ready list, a delayed list,
    450           * a suspended list, etc.).
    451           *
    452           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    453           * NORMAL APPLICATION CODE.
    454           */
    455          #if ( configUSE_TRACE_FACILITY == 1 )
    456          
    457          	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
    458          
    459          #endif
    460          
    461          /*
    462           * When a task is created, the stack of the task is filled with a known value.
    463           * This function determines the 'high water mark' of the task stack by
    464           * determining how much of the stack remains at the original preset value.
    465           */
    466          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    467          
    468          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
    469          
    470          #endif
    471          
    472          /*
    473           * Return the amount of time, in ticks, that will pass before the kernel will
    474           * next move a task from the Blocked state to the Running state.
    475           *
    476           * This conditional compilation should use inequality to 0, not equality to 1.
    477           * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
    478           * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
    479           * set to a value other than 1.
    480           */
    481          #if ( configUSE_TICKLESS_IDLE != 0 )
    482          
    483          	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
    484          
    485          #endif
    486          
    487          /*
    488           * Set xNextTaskUnblockTime to the time at which the next Blocked state task
    489           * will exit the Blocked state.
    490           */
    491          static void prvResetNextTaskUnblockTime( void );
    492          
    493          /*-----------------------------------------------------------*/
    494          
    495          BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    496          {
    497          BaseType_t xReturn;
    498          TCB_t * pxNewTCB;
    499          
    500          	configASSERT( pxTaskCode );
    501          	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
    502          
    503          	/* Allocate the memory required by the TCB and stack for the new task,
    504          	checking that the allocation was successful. */
    505          	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    506          
    507          	if( pxNewTCB != NULL )
    508          	{
    509          		StackType_t *pxTopOfStack;
    510          
    511          		#if( portUSING_MPU_WRAPPERS == 1 )
    512          			/* Should the task be created in privileged mode? */
    513          			BaseType_t xRunPrivileged;
    514          			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
    515          			{
    516          				xRunPrivileged = pdTRUE;
    517          			}
    518          			else
    519          			{
    520          				xRunPrivileged = pdFALSE;
    521          			}
    522          			uxPriority &= ~portPRIVILEGE_BIT;
    523          		#endif /* portUSING_MPU_WRAPPERS == 1 */
    524          
    525          		/* Calculate the top of stack address.  This depends on whether the
    526          		stack grows from high memory to low (as per the 80x86) or vice versa.
    527          		portSTACK_GROWTH is used to make the result positive or negative as
    528          		required by the port. */
    529          		#if( portSTACK_GROWTH < 0 )
    530          		{
    531          			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    532          			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    533          
    534          			/* Check the alignment of the calculated top of stack is correct. */
    535          			configASSERT( ( ( ( uint32_t ) pxTopOfStack & ( uint32_t ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    536          		}
    537          		#else /* portSTACK_GROWTH */
    538          		{
    539          			pxTopOfStack = pxNewTCB->pxStack;
    540          
    541          			/* Check the alignment of the stack buffer is correct. */
    542          			configASSERT( ( ( ( uint32_t ) pxNewTCB->pxStack & ( uint32_t ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    543          
    544          			/* If we want to use stack checking on architectures that use
    545          			a positive stack growth direction then we also need to store the
    546          			other extreme of the stack space. */
    547          			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    548          		}
    549          		#endif /* portSTACK_GROWTH */
    550          
    551          		/* Setup the newly allocated TCB with the initial state of the task. */
    552          		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    553          
    554          		/* Initialize the TCB stack to look as if the task was already running,
    555          		but had been interrupted by the scheduler.  The return address is set
    556          		to the start of the task function. Once the stack has been initialised
    557          		the	top of stack variable is updated. */
    558          		#if( portUSING_MPU_WRAPPERS == 1 )
    559          		{
    560          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
    561          		}
    562          		#else /* portUSING_MPU_WRAPPERS */
    563          		{
    564          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    565          		}
    566          		#endif /* portUSING_MPU_WRAPPERS */
    567          
    568          		if( ( void * ) pxCreatedTask != NULL )
    569          		{
    570          			/* Pass the TCB out - in an anonymous way.  The calling function/
    571          			task can use this as a handle to delete the task later if
    572          			required.*/
    573          			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    574          		}
    575          		else
    576          		{
    577          			mtCOVERAGE_TEST_MARKER();
    578          		}
    579          
    580          		/* Ensure interrupts don't access the task lists while they are being
    581          		updated. */
    582          		taskENTER_CRITICAL();
    583          		{
    584          			uxCurrentNumberOfTasks++;
    585          			if( pxCurrentTCB == NULL )
    586          			{
    587          				/* There are no other tasks, or all the other tasks are in
    588          				the suspended state - make this the current task. */
    589          				pxCurrentTCB =  pxNewTCB;
    590          
    591          				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    592          				{
    593          					/* This is the first task to be created so do the preliminary
    594          					initialisation required.  We will not recover if this call
    595          					fails, but we will report the failure. */
    596          					prvInitialiseTaskLists();
    597          				}
    598          				else
    599          				{
    600          					mtCOVERAGE_TEST_MARKER();
    601          				}
    602          			}
    603          			else
    604          			{
    605          				/* If the scheduler is not already running, make this task the
    606          				current task if it is the highest priority task to be created
    607          				so far. */
    608          				if( xSchedulerRunning == pdFALSE )
    609          				{
    610          					if( pxCurrentTCB->uxPriority <= uxPriority )
    611          					{
    612          						pxCurrentTCB = pxNewTCB;
    613          					}
    614          					else
    615          					{
    616          						mtCOVERAGE_TEST_MARKER();
    617          					}
    618          				}
    619          				else
    620          				{
    621          					mtCOVERAGE_TEST_MARKER();
    622          				}
    623          			}
    624          
    625          			uxTaskNumber++;
    626          
    627          			#if ( configUSE_TRACE_FACILITY == 1 )
    628          			{
    629          				/* Add a counter into the TCB for tracing only. */
    630          				pxNewTCB->uxTCBNumber = uxTaskNumber;
    631          			}
    632          			#endif /* configUSE_TRACE_FACILITY */
    633          			traceTASK_CREATE( pxNewTCB );
    634          
    635          			prvAddTaskToReadyList( pxNewTCB );
    636          
    637          			xReturn = pdPASS;
    638          			portSETUP_TCB( pxNewTCB );
    639          		}
    640          		taskEXIT_CRITICAL();
    641          	}
    642          	else
    643          	{
    644          		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    645          		traceTASK_CREATE_FAILED();
    646          	}
    647          
    648          	if( xReturn == pdPASS )
    649          	{
    650          		if( xSchedulerRunning != pdFALSE )
    651          		{
    652          			/* If the created task is of a higher priority than the current task
    653          			then it should run now. */
    654          			if( pxCurrentTCB->uxPriority < uxPriority )
    655          			{
    656          				taskYIELD_IF_USING_PREEMPTION();
    657          			}
    658          			else
    659          			{
    660          				mtCOVERAGE_TEST_MARKER();
    661          			}
    662          		}
    663          		else
    664          		{
    665          			mtCOVERAGE_TEST_MARKER();
    666          		}
    667          	}
    668          
    669          	return xReturn;
    670          }
    671          /*-----------------------------------------------------------*/
    672          
    673          #if ( INCLUDE_vTaskDelete == 1 )
    674          
    675          	void vTaskDelete( TaskHandle_t xTaskToDelete )
    676          	{
    677          	TCB_t *pxTCB;
    678          
    679          		taskENTER_CRITICAL();
    680          		{
    681          			/* If null is passed in here then it is the calling task that is
    682          			being deleted. */
    683          			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    684          
    685          			/* Remove task from the ready list and place in the	termination list.
    686          			This will stop the task from be scheduled.  The idle task will check
    687          			the termination list and free up any memory allocated by the
    688          			scheduler for the TCB and stack. */
    689          			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    690          			{
    691          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    692          			}
    693          			else
    694          			{
    695          				mtCOVERAGE_TEST_MARKER();
    696          			}
    697          
    698          			/* Is the task waiting on an event also? */
    699          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    700          			{
    701          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    702          			}
    703          			else
    704          			{
    705          				mtCOVERAGE_TEST_MARKER();
    706          			}
    707          
    708          			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    709          
    710          			/* Increment the ucTasksDeleted variable so the idle task knows
    711          			there is a task that has been deleted and that it should therefore
    712          			check the xTasksWaitingTermination list. */
    713          			++uxTasksDeleted;
    714          
    715          			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
    716          			can detect that the task lists need re-generating. */
    717          			uxTaskNumber++;
    718          
    719          			traceTASK_DELETE( pxTCB );
    720          		}
    721          		taskEXIT_CRITICAL();
    722          
    723          		/* Force a reschedule if it is the currently running task that has just
    724          		been deleted. */
    725          		if( xSchedulerRunning != pdFALSE )
    726          		{
    727          			if( pxTCB == pxCurrentTCB )
    728          			{
    729          				configASSERT( uxSchedulerSuspended == 0 );
    730          
    731          				/* The pre-delete hook is primarily for the Windows simulator,
    732          				in which Windows specific clean up operations are performed,
    733          				after which it is not possible to yield away from this task -
    734          				hence xYieldPending is used to latch that a context switch is
    735          				required. */
    736          				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
    737          				portYIELD_WITHIN_API();
    738          			}
    739          			else
    740          			{
    741          				/* Reset the next expected unblock time in case it referred to
    742          				the task that has just been deleted. */
    743          				prvResetNextTaskUnblockTime();
    744          			}
    745          		}
    746          	}
    747          
    748          #endif /* INCLUDE_vTaskDelete */
    749          /*-----------------------------------------------------------*/
    750          
    751          #if ( INCLUDE_vTaskDelayUntil == 1 )
    752          
    753          	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
    754          	{
    755          	TickType_t xTimeToWake;
    756          	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    757          
    758          		configASSERT( pxPreviousWakeTime );
    759          		configASSERT( ( xTimeIncrement > 0U ) );
    760          		configASSERT( uxSchedulerSuspended == 0 );
    761          
    762          		vTaskSuspendAll();
    763          		{
    764          			/* Minor optimisation.  The tick count cannot change in this
    765          			block. */
    766          			const TickType_t xConstTickCount = xTickCount;
    767          
    768          			/* Generate the tick time at which the task wants to wake. */
    769          			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    770          
    771          			if( xConstTickCount < *pxPreviousWakeTime )
    772          			{
    773          				/* The tick count has overflowed since this function was
    774          				lasted called.  In this case the only time we should ever
    775          				actually delay is if the wake time has also	overflowed,
    776          				and the wake time is greater than the tick time.  When this
    777          				is the case it is as if neither time had overflowed. */
    778          				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    779          				{
    780          					xShouldDelay = pdTRUE;
    781          				}
    782          				else
    783          				{
    784          					mtCOVERAGE_TEST_MARKER();
    785          				}
    786          			}
    787          			else
    788          			{
    789          				/* The tick time has not overflowed.  In this case we will
    790          				delay if either the wake time has overflowed, and/or the
    791          				tick time is less than the wake time. */
    792          				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    793          				{
    794          					xShouldDelay = pdTRUE;
    795          				}
    796          				else
    797          				{
    798          					mtCOVERAGE_TEST_MARKER();
    799          				}
    800          			}
    801          
    802          			/* Update the wake time ready for the next call. */
    803          			*pxPreviousWakeTime = xTimeToWake;
    804          
    805          			if( xShouldDelay != pdFALSE )
    806          			{
    807          				traceTASK_DELAY_UNTIL();
    808          
    809          				/* We must remove ourselves from the ready list before adding
    810          				ourselves to the blocked list as the same list item is used for
    811          				both lists. */
    812          				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    813          				{
    814          					/* The current task must be in a ready list, so there is
    815          					no need to check, and the port reset macro can be called
    816          					directly. */
    817          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    818          				}
    819          				else
    820          				{
    821          					mtCOVERAGE_TEST_MARKER();
    822          				}
    823          
    824          				prvAddCurrentTaskToDelayedList( xTimeToWake );
    825          			}
    826          			else
    827          			{
    828          				mtCOVERAGE_TEST_MARKER();
    829          			}
    830          		}
    831          		xAlreadyYielded = xTaskResumeAll();
    832          
    833          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    834          		have put ourselves to sleep. */
    835          		if( xAlreadyYielded == pdFALSE )
    836          		{
    837          			portYIELD_WITHIN_API();
    838          		}
    839          		else
    840          		{
    841          			mtCOVERAGE_TEST_MARKER();
    842          		}
    843          	}
    844          
    845          #endif /* INCLUDE_vTaskDelayUntil */
    846          /*-----------------------------------------------------------*/
    847          
    848          #if ( INCLUDE_vTaskDelay == 1 )
    849          
    850          	void vTaskDelay( const TickType_t xTicksToDelay )
    851          	{
    852          	TickType_t xTimeToWake;
    853          	BaseType_t xAlreadyYielded = pdFALSE;
    854          
    855          
    856          		/* A delay time of zero just forces a reschedule. */
    857          		if( xTicksToDelay > ( TickType_t ) 0U )
    858          		{
    859          			configASSERT( uxSchedulerSuspended == 0 );
    860          			vTaskSuspendAll();
    861          			{
    862          				traceTASK_DELAY();
    863          
    864          				/* A task that is removed from the event list while the
    865          				scheduler is suspended will not get placed in the ready
    866          				list or removed from the blocked list until the scheduler
    867          				is resumed.
    868          
    869          				This task cannot be in an event list as it is the currently
    870          				executing task. */
    871          
    872          				/* Calculate the time to wake - this may overflow but this is
    873          				not a problem. */
    874          				xTimeToWake = xTickCount + xTicksToDelay;
    875          
    876          				/* We must remove ourselves from the ready list before adding
    877          				ourselves to the blocked list as the same list item is used for
    878          				both lists. */
    879          				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    880          				{
    881          					/* The current task must be in a ready list, so there is
    882          					no need to check, and the port reset macro can be called
    883          					directly. */
    884          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    885          				}
    886          				else
    887          				{
    888          					mtCOVERAGE_TEST_MARKER();
    889          				}
    890          				prvAddCurrentTaskToDelayedList( xTimeToWake );
    891          			}
    892          			xAlreadyYielded = xTaskResumeAll();
    893          		}
    894          		else
    895          		{
    896          			mtCOVERAGE_TEST_MARKER();
    897          		}
    898          
    899          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    900          		have put ourselves to sleep. */
    901          		if( xAlreadyYielded == pdFALSE )
    902          		{
    903          			portYIELD_WITHIN_API();
    904          		}
    905          		else
    906          		{
    907          			mtCOVERAGE_TEST_MARKER();
    908          		}
    909          	}
    910          
    911          #endif /* INCLUDE_vTaskDelay */
    912          /*-----------------------------------------------------------*/
    913          
    914          #if ( INCLUDE_eTaskGetState == 1 )
    915          
    916          	eTaskState eTaskGetState( TaskHandle_t xTask )
    917          	{
    918          	eTaskState eReturn;
    919          	List_t *pxStateList;
    920          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    921          
    922          		configASSERT( pxTCB );
    923          
    924          		if( pxTCB == pxCurrentTCB )
    925          		{
    926          			/* The task calling this function is querying its own state. */
    927          			eReturn = eRunning;
    928          		}
    929          		else
    930          		{
    931          			taskENTER_CRITICAL();
    932          			{
    933          				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
    934          			}
    935          			taskEXIT_CRITICAL();
    936          
    937          			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
    938          			{
    939          				/* The task being queried is referenced from one of the Blocked
    940          				lists. */
    941          				eReturn = eBlocked;
    942          			}
    943          
    944          			#if ( INCLUDE_vTaskSuspend == 1 )
    945          				else if( pxStateList == &xSuspendedTaskList )
    946          				{
    947          					/* The task being queried is referenced from the suspended
    948          					list.  Is it genuinely suspended or is it block
    949          					indefinitely? */
    950          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
    951          					{
    952          						eReturn = eSuspended;
    953          					}
    954          					else
    955          					{
    956          						eReturn = eBlocked;
    957          					}
    958          				}
    959          			#endif
    960          
    961          			#if ( INCLUDE_vTaskDelete == 1 )
    962          				else if( pxStateList == &xTasksWaitingTermination )
    963          				{
    964          					/* The task being queried is referenced from the deleted
    965          					tasks list. */
    966          					eReturn = eDeleted;
    967          				}
    968          			#endif
    969          
    970          			else
    971          			{
    972          				/* If the task is not in any other state, it must be in the
    973          				Ready (including pending ready) state. */
    974          				eReturn = eReady;
    975          			}
    976          		}
    977          
    978          		return eReturn;
    979          	}
    980          
    981          #endif /* INCLUDE_eTaskGetState */
    982          /*-----------------------------------------------------------*/
    983          
    984          #if ( INCLUDE_uxTaskPriorityGet == 1 )
    985          
    986          	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
    987          	{
    988          	TCB_t *pxTCB;
    989          	UBaseType_t uxReturn;
    990          
    991          		taskENTER_CRITICAL();
    992          		{
    993          			/* If null is passed in here then we are changing the
    994          			priority of the calling function. */
    995          			pxTCB = prvGetTCBFromHandle( xTask );
    996          			uxReturn = pxTCB->uxPriority;
    997          		}
    998          		taskEXIT_CRITICAL();
    999          
   1000          		return uxReturn;
   1001          	}
   1002          
   1003          #endif /* INCLUDE_uxTaskPriorityGet */
   1004          /*-----------------------------------------------------------*/
   1005          
   1006          #if ( INCLUDE_vTaskPrioritySet == 1 )
   1007          
   1008          	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
   1009          	{
   1010          	TCB_t *pxTCB;
   1011          	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
   1012          	BaseType_t xYieldRequired = pdFALSE;
   1013          
   1014          		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
   1015          
   1016          		/* Ensure the new priority is valid. */
   1017          		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   1018          		{
   1019          			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   1020          		}
   1021          		else
   1022          		{
   1023          			mtCOVERAGE_TEST_MARKER();
   1024          		}
   1025          
   1026          		taskENTER_CRITICAL();
   1027          		{
   1028          			/* If null is passed in here then it is the priority of the calling
   1029          			task that is being changed. */
   1030          			pxTCB = prvGetTCBFromHandle( xTask );
   1031          
   1032          			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
   1033          
   1034          			#if ( configUSE_MUTEXES == 1 )
   1035          			{
   1036          				uxCurrentBasePriority = pxTCB->uxBasePriority;
   1037          			}
   1038          			#else
   1039          			{
   1040          				uxCurrentBasePriority = pxTCB->uxPriority;
   1041          			}
   1042          			#endif
   1043          
   1044          			if( uxCurrentBasePriority != uxNewPriority )
   1045          			{
   1046          				/* The priority change may have readied a task of higher
   1047          				priority than the calling task. */
   1048          				if( uxNewPriority > uxCurrentBasePriority )
   1049          				{
   1050          					if( pxTCB != pxCurrentTCB )
   1051          					{
   1052          						/* The priority of a task other than the currently
   1053          						running task is being raised.  Is the priority being
   1054          						raised above that of the running task? */
   1055          						if( uxNewPriority >= pxCurrentTCB->uxPriority )
   1056          						{
   1057          							xYieldRequired = pdTRUE;
   1058          						}
   1059          						else
   1060          						{
   1061          							mtCOVERAGE_TEST_MARKER();
   1062          						}
   1063          					}
   1064          					else
   1065          					{
   1066          						/* The priority of the running task is being raised,
   1067          						but the running task must already be the highest
   1068          						priority task able to run so no yield is required. */
   1069          					}
   1070          				}
   1071          				else if( pxTCB == pxCurrentTCB )
   1072          				{
   1073          					/* Setting the priority of the running task down means
   1074          					there may now be another task of higher priority that
   1075          					is ready to execute. */
   1076          					xYieldRequired = pdTRUE;
   1077          				}
   1078          				else
   1079          				{
   1080          					/* Setting the priority of any other task down does not
   1081          					require a yield as the running task must be above the
   1082          					new priority of the task being modified. */
   1083          				}
   1084          
   1085          				/* Remember the ready list the task might be referenced from
   1086          				before its uxPriority member is changed so the
   1087          				taskRESET_READY_PRIORITY() macro can function correctly. */
   1088          				uxPriorityUsedOnEntry = pxTCB->uxPriority;
   1089          
   1090          				#if ( configUSE_MUTEXES == 1 )
   1091          				{
   1092          					/* Only change the priority being used if the task is not
   1093          					currently using an inherited priority. */
   1094          					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   1095          					{
   1096          						pxTCB->uxPriority = uxNewPriority;
   1097          					}
   1098          					else
   1099          					{
   1100          						mtCOVERAGE_TEST_MARKER();
   1101          					}
   1102          
   1103          					/* The base priority gets set whatever. */
   1104          					pxTCB->uxBasePriority = uxNewPriority;
   1105          				}
   1106          				#else
   1107          				{
   1108          					pxTCB->uxPriority = uxNewPriority;
   1109          				}
   1110          				#endif
   1111          
   1112          				/* Only reset the event list item value if the value is not
   1113          				being used for anything else. */
   1114          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   1115          				{
   1116          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1117          				}
   1118          				else
   1119          				{
   1120          					mtCOVERAGE_TEST_MARKER();
   1121          				}
   1122          
   1123          				/* If the task is in the blocked or suspended list we need do
   1124          				nothing more than change it's priority variable. However, if
   1125          				the task is in a ready list it needs to be removed and placed
   1126          				in the list appropriate to its new priority. */
   1127          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   1128          				{
   1129          					/* The task is currently in its ready list - remove before adding
   1130          					it to it's new ready list.  As we are in a critical section we
   1131          					can do this even if the scheduler is suspended. */
   1132          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   1133          					{
   1134          						/* It is known that the task is in its ready list so
   1135          						there is no need to check again and the port level
   1136          						reset macro can be called directly. */
   1137          						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
   1138          					}
   1139          					else
   1140          					{
   1141          						mtCOVERAGE_TEST_MARKER();
   1142          					}
   1143          					prvAddTaskToReadyList( pxTCB );
   1144          				}
   1145          				else
   1146          				{
   1147          					mtCOVERAGE_TEST_MARKER();
   1148          				}
   1149          
   1150          				if( xYieldRequired == pdTRUE )
   1151          				{
   1152          					taskYIELD_IF_USING_PREEMPTION();
   1153          				}
   1154          				else
   1155          				{
   1156          					mtCOVERAGE_TEST_MARKER();
   1157          				}
   1158          
   1159          				/* Remove compiler warning about unused variables when the port
   1160          				optimised task selection is not being used. */
   1161          				( void ) uxPriorityUsedOnEntry;
   1162          			}
   1163          		}
   1164          		taskEXIT_CRITICAL();
   1165          	}
   1166          
   1167          #endif /* INCLUDE_vTaskPrioritySet */
   1168          /*-----------------------------------------------------------*/
   1169          
   1170          #if ( INCLUDE_vTaskSuspend == 1 )
   1171          
   1172          	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
   1173          	{
   1174          	TCB_t *pxTCB;
   1175          
   1176          		taskENTER_CRITICAL();
   1177          		{
   1178          			/* If null is passed in here then it is the running task that is
   1179          			being suspended. */
   1180          			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   1181          
   1182          			traceTASK_SUSPEND( pxTCB );
   1183          
   1184          			/* Remove task from the ready/delayed list and place in the
   1185          			suspended list. */
   1186          			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   1187          			{
   1188          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1189          			}
   1190          			else
   1191          			{
   1192          				mtCOVERAGE_TEST_MARKER();
   1193          			}
   1194          
   1195          			/* Is the task waiting on an event also? */
   1196          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1197          			{
   1198          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1199          			}
   1200          			else
   1201          			{
   1202          				mtCOVERAGE_TEST_MARKER();
   1203          			}
   1204          
   1205          			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
   1206          		}
   1207          		taskEXIT_CRITICAL();
   1208          
   1209          		if( pxTCB == pxCurrentTCB )
   1210          		{
   1211          			if( xSchedulerRunning != pdFALSE )
   1212          			{
   1213          				/* The current task has just been suspended. */
   1214          				configASSERT( uxSchedulerSuspended == 0 );
   1215          				portYIELD_WITHIN_API();
   1216          			}
   1217          			else
   1218          			{
   1219          				/* The scheduler is not running, but the task that was pointed
   1220          				to by pxCurrentTCB has just been suspended and pxCurrentTCB
   1221          				must be adjusted to point to a different task. */
   1222          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   1223          				{
   1224          					/* No other tasks are ready, so set pxCurrentTCB back to
   1225          					NULL so when the next task is created pxCurrentTCB will
   1226          					be set to point to it no matter what its relative priority
   1227          					is. */
   1228          					pxCurrentTCB = NULL;
   1229          				}
   1230          				else
   1231          				{
   1232          					vTaskSwitchContext();
   1233          				}
   1234          			}
   1235          		}
   1236          		else
   1237          		{
   1238          			if( xSchedulerRunning != pdFALSE )
   1239          			{
   1240          				/* A task other than the currently running task was suspended,
   1241          				reset the next expected unblock time in case it referred to the
   1242          				task that is now in the Suspended state. */
   1243          				prvResetNextTaskUnblockTime();
   1244          			}
   1245          			else
   1246          			{
   1247          				mtCOVERAGE_TEST_MARKER();
   1248          			}
   1249          		}
   1250          	}
   1251          
   1252          #endif /* INCLUDE_vTaskSuspend */
   1253          /*-----------------------------------------------------------*/
   1254          
   1255          #if ( INCLUDE_vTaskSuspend == 1 )
   1256          
   1257          	BaseType_t xTaskIsTaskSuspended( const TaskHandle_t xTask )
   1258          	{
   1259          	BaseType_t xReturn = pdFALSE;
   1260          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
   1261          
   1262          		/* It does not make sense to check if the calling task is suspended. */
   1263          		configASSERT( xTask );
   1264          
   1265          		/* Is the task we are attempting to resume actually in the
   1266          		suspended list? */
   1267          		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
   1268          		{
   1269          			/* Has the task already been resumed from within an ISR? */
   1270          			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   1271          			{
   1272          				/* Is it in the suspended list because it is in the
   1273          				Suspended state?  It is possible to be in the suspended
   1274          				list because it is blocked on a task with no timeout
   1275          				specified. */
   1276          				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
   1277          				{
   1278          					xReturn = pdTRUE;
   1279          				}
   1280          				else
   1281          				{
   1282          					mtCOVERAGE_TEST_MARKER();
   1283          				}
   1284          			}
   1285          			else
   1286          			{
   1287          				mtCOVERAGE_TEST_MARKER();
   1288          			}
   1289          		}
   1290          		else
   1291          		{
   1292          			mtCOVERAGE_TEST_MARKER();
   1293          		}
   1294          
   1295          		return xReturn;
   1296          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1297          
   1298          #endif /* INCLUDE_vTaskSuspend */
   1299          /*-----------------------------------------------------------*/
   1300          
   1301          #if ( INCLUDE_vTaskSuspend == 1 )
   1302          
   1303          	void vTaskResume( TaskHandle_t xTaskToResume )
   1304          	{
   1305          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1306          
   1307          		/* It does not make sense to resume the calling task. */
   1308          		configASSERT( xTaskToResume );
   1309          
   1310          		/* The parameter cannot be NULL as it is impossible to resume the
   1311          		currently executing task. */
   1312          		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   1313          		{
   1314          			taskENTER_CRITICAL();
   1315          			{
   1316          				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   1317          				{
   1318          					traceTASK_RESUME( pxTCB );
   1319          
   1320          					/* As we are in a critical section we can access the ready
   1321          					lists even if the scheduler is suspended. */
   1322          					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
   1323          					prvAddTaskToReadyList( pxTCB );
   1324          
   1325          					/* We may have just resumed a higher priority task. */
   1326          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1327          					{
   1328          						/* This yield may not cause the task just resumed to run,
   1329          						but will leave the lists in the correct state for the
   1330          						next yield. */
   1331          						taskYIELD_IF_USING_PREEMPTION();
   1332          					}
   1333          					else
   1334          					{
   1335          						mtCOVERAGE_TEST_MARKER();
   1336          					}
   1337          				}
   1338          				else
   1339          				{
   1340          					mtCOVERAGE_TEST_MARKER();
   1341          				}
   1342          			}
   1343          			taskEXIT_CRITICAL();
   1344          		}
   1345          		else
   1346          		{
   1347          			mtCOVERAGE_TEST_MARKER();
   1348          		}
   1349          	}
   1350          
   1351          #endif /* INCLUDE_vTaskSuspend */
   1352          
   1353          /*-----------------------------------------------------------*/
   1354          
   1355          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1356          
   1357          	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
   1358          	{
   1359          	BaseType_t xYieldRequired = pdFALSE;
   1360          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1361          	UBaseType_t uxSavedInterruptStatus;
   1362          
   1363          		configASSERT( xTaskToResume );
   1364          
   1365          		/* RTOS ports that support interrupt nesting have the concept of a
   1366          		maximum	system call (or maximum API call) interrupt priority.
   1367          		Interrupts that are	above the maximum system call priority are keep
   1368          		permanently enabled, even when the RTOS kernel is in a critical section,
   1369          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1370          		is defined in FreeRTOSConfig.h then
   1371          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1372          		failure if a FreeRTOS API function is called from an interrupt that has
   1373          		been assigned a priority above the configured maximum system call
   1374          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1375          		from interrupts	that have been assigned a priority at or (logically)
   1376          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1377          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1378          		simple as possible.  More information (albeit Cortex-M specific) is
   1379          		provided on the following link:
   1380          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1381          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1382          
   1383          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1384          		{
   1385          			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   1386          			{
   1387          				traceTASK_RESUME_FROM_ISR( pxTCB );
   1388          
   1389          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1390          				{
   1391          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1392          					{
   1393          						xYieldRequired = pdTRUE;
   1394          					}
   1395          					else
   1396          					{
   1397          						mtCOVERAGE_TEST_MARKER();
   1398          					}
   1399          
   1400          					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
   1401          					prvAddTaskToReadyList( pxTCB );
   1402          				}
   1403          				else
   1404          				{
   1405          					/* We cannot access the delayed or ready lists, so will hold this
   1406          					task pending until the scheduler is resumed, at which point a
   1407          					yield will be performed if necessary. */
   1408          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   1409          				}
   1410          			}
   1411          			else
   1412          			{
   1413          				mtCOVERAGE_TEST_MARKER();
   1414          			}
   1415          		}
   1416          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1417          
   1418          		return xYieldRequired;
   1419          	}
   1420          
   1421          #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
   1422          /*-----------------------------------------------------------*/
   1423          
   1424          void vTaskStartScheduler( void )
   1425          {
   1426          BaseType_t xReturn;
   1427          
   1428          	/* Add the idle task at the lowest priority. */
   1429          	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1430          	{
   1431          		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
   1432          		be returned by the xTaskGetIdleTaskHandle() function. */
   1433          		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1434          	}
   1435          	#else
   1436          	{
   1437          		/* Create the idle task without storing its handle. */
   1438          		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1439          	}
   1440          	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
   1441          
   1442          	#if ( configUSE_TIMERS == 1 )
   1443          	{
   1444          		if( xReturn == pdPASS )
   1445          		{
   1446          			xReturn = xTimerCreateTimerTask();
   1447          		}
   1448          		else
   1449          		{
   1450          			mtCOVERAGE_TEST_MARKER();
   1451          		}
   1452          	}
   1453          	#endif /* configUSE_TIMERS */
   1454          
   1455          	if( xReturn == pdPASS )
   1456          	{
   1457          		/* Interrupts are turned off here, to ensure a tick does not occur
   1458          		before or during the call to xPortStartScheduler().  The stacks of
   1459          		the created tasks contain a status word with interrupts switched on
   1460          		so interrupts will automatically get re-enabled when the first task
   1461          		starts to run. */
   1462          		portDISABLE_INTERRUPTS();
   1463          
   1464          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   1465          		{
   1466          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   1467          			structure specific to the task that will run first. */
   1468          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   1469          		}
   1470          		#endif /* configUSE_NEWLIB_REENTRANT */
   1471          
   1472          		xSchedulerRunning = pdTRUE;
   1473          		xTickCount = ( TickType_t ) 0U;
   1474          
   1475          		/* If configGENERATE_RUN_TIME_STATS is defined then the following
   1476          		macro must be defined to configure the timer/counter used to generate
   1477          		the run time counter time base. */
   1478          		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   1479          
   1480          		/* Setting up the timer tick is hardware specific and thus in the
   1481          		portable interface. */
   1482          		if( xPortStartScheduler() != pdFALSE )
   1483          		{
   1484          			/* Should not reach here as if the scheduler is running the
   1485          			function will not return. */
   1486          		}
   1487          		else
   1488          		{
   1489          			/* Should only reach here if a task calls xTaskEndScheduler(). */
   1490          		}
   1491          	}
   1492          	else
   1493          	{
   1494          		/* This line will only be reached if the kernel could not be started,
   1495          		because there was not enough FreeRTOS heap to create the idle task
   1496          		or the timer task. */
   1497          		configASSERT( xReturn );
   1498          	}
   1499          }
   1500          /*-----------------------------------------------------------*/
   1501          
   1502          void vTaskEndScheduler( void )
   1503          {
   1504          	/* Stop the scheduler interrupts and call the portable scheduler end
   1505          	routine so the original ISRs can be restored if necessary.  The port
   1506          	layer must ensure interrupts enable	bit is left in the correct state. */
   1507          	portDISABLE_INTERRUPTS();
   1508          	xSchedulerRunning = pdFALSE;
   1509          	vPortEndScheduler();
   1510          }
   1511          /*----------------------------------------------------------*/
   1512          
   1513          void vTaskSuspendAll( void )
   1514          {
   1515          	/* A critical section is not required as the variable is of type
   1516          	BaseType_t.  Please read Richard Barry's reply in the following link to a
   1517          	post in the FreeRTOS support forum before reporting this as a bug! -
   1518          	http://goo.gl/wu4acr */
   1519          	++uxSchedulerSuspended;
   1520          }
   1521          /*----------------------------------------------------------*/
   1522          
   1523          #if ( configUSE_TICKLESS_IDLE != 0 )
   1524          
   1525          	static TickType_t prvGetExpectedIdleTime( void )
   1526          	{
   1527          	TickType_t xReturn;
   1528          
   1529          		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
   1530          		{
   1531          			xReturn = 0;
   1532          		}
   1533          		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
   1534          		{
   1535          			/* There are other idle priority tasks in the ready state.  If
   1536          			time slicing is used then the very next tick interrupt must be
   1537          			processed. */
   1538          			xReturn = 0;
   1539          		}
   1540          		else
   1541          		{
   1542          			xReturn = xNextTaskUnblockTime - xTickCount;
   1543          		}
   1544          
   1545          		return xReturn;
   1546          	}
   1547          
   1548          #endif /* configUSE_TICKLESS_IDLE */
   1549          /*----------------------------------------------------------*/
   1550          
   1551          BaseType_t xTaskResumeAll( void )
   1552          {
   1553          TCB_t *pxTCB;
   1554          BaseType_t xAlreadyYielded = pdFALSE;
   1555          
   1556          	/* If uxSchedulerSuspended is zero then this function does not match a
   1557          	previous call to vTaskSuspendAll(). */
   1558          	configASSERT( uxSchedulerSuspended );
   1559          
   1560          	/* It is possible that an ISR caused a task to be removed from an event
   1561          	list while the scheduler was suspended.  If this was the case then the
   1562          	removed task will have been added to the xPendingReadyList.  Once the
   1563          	scheduler has been resumed it is safe to move all the pending ready
   1564          	tasks from this list into their appropriate ready list. */
   1565          	taskENTER_CRITICAL();
   1566          	{
   1567          		--uxSchedulerSuspended;
   1568          
   1569          		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1570          		{
   1571          			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   1572          			{
   1573          				/* Move any readied tasks from the pending list into the
   1574          				appropriate ready list. */
   1575          				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   1576          				{
   1577          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   1578          					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1579          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   1580          					prvAddTaskToReadyList( pxTCB );
   1581          
   1582          					/* If we have moved a task that has a priority higher than
   1583          					the current task then we should yield. */
   1584          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1585          					{
   1586          						xYieldPending = pdTRUE;
   1587          					}
   1588          					else
   1589          					{
   1590          						mtCOVERAGE_TEST_MARKER();
   1591          					}
   1592          				}
   1593          
   1594          				/* If any ticks occurred while the scheduler was suspended then
   1595          				they should be processed now.  This ensures the tick count does
   1596          				not	slip, and that any delayed tasks are resumed at the correct
   1597          				time. */
   1598          				if( uxPendedTicks > ( UBaseType_t ) 0U )
   1599          				{
   1600          					while( uxPendedTicks > ( UBaseType_t ) 0U )
   1601          					{
   1602          						if( xTaskIncrementTick() != pdFALSE )
   1603          						{
   1604          							xYieldPending = pdTRUE;
   1605          						}
   1606          						else
   1607          						{
   1608          							mtCOVERAGE_TEST_MARKER();
   1609          						}
   1610          						--uxPendedTicks;
   1611          					}
   1612          				}
   1613          				else
   1614          				{
   1615          					mtCOVERAGE_TEST_MARKER();
   1616          				}
   1617          
   1618          				if( xYieldPending == pdTRUE )
   1619          				{
   1620          					#if( configUSE_PREEMPTION != 0 )
   1621          					{
   1622          						xAlreadyYielded = pdTRUE;
   1623          					}
   1624          					#endif
   1625          					taskYIELD_IF_USING_PREEMPTION();
   1626          				}
   1627          				else
   1628          				{
   1629          					mtCOVERAGE_TEST_MARKER();
   1630          				}
   1631          			}
   1632          		}
   1633          		else
   1634          		{
   1635          			mtCOVERAGE_TEST_MARKER();
   1636          		}
   1637          	}
   1638          	taskEXIT_CRITICAL();
   1639          
   1640          	return xAlreadyYielded;
   1641          }
   1642          /*-----------------------------------------------------------*/
   1643          
   1644          TickType_t xTaskGetTickCount( void )
   1645          {
   1646          TickType_t xTicks;
   1647          
   1648          	/* Critical section required if running on a 16 bit processor. */
   1649          	taskENTER_CRITICAL();
   1650          	{
   1651          		xTicks = xTickCount;
   1652          	}
   1653          	taskEXIT_CRITICAL();
   1654          
   1655          	return xTicks;
   1656          }
   1657          /*-----------------------------------------------------------*/
   1658          
   1659          TickType_t xTaskGetTickCountFromISR( void )
   1660          {
   1661          TickType_t xReturn;
   1662          UBaseType_t uxSavedInterruptStatus;
   1663          
   1664          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1665          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1666          	above the maximum system call priority are kept permanently enabled, even
   1667          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1668          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1669          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1670          	failure if a FreeRTOS API function is called from an interrupt that has been
   1671          	assigned a priority above the configured maximum system call priority.
   1672          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1673          	that have been assigned a priority at or (logically) below the maximum
   1674          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1675          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1676          	More information (albeit Cortex-M specific) is provided on the following
   1677          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1678          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1679          
   1680          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1681          	xReturn = xTickCount;
   1682          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1683          
   1684          	return xReturn;
   1685          }
   1686          /*-----------------------------------------------------------*/
   1687          
   1688          UBaseType_t uxTaskGetNumberOfTasks( void )
   1689          {
   1690          	/* A critical section is not required because the variables are of type
   1691          	BaseType_t. */
   1692          	return uxCurrentNumberOfTasks;
   1693          }
   1694          /*-----------------------------------------------------------*/
   1695          
   1696          #if ( INCLUDE_pcTaskGetTaskName == 1 )
   1697          
   1698          	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery )
   1699          	{
   1700          	TCB_t *pxTCB;
   1701          
   1702          		/* If null is passed in here then the name of the calling task is being queried. */
   1703          		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   1704          		configASSERT( pxTCB );
   1705          		return &( pxTCB->pcTaskName[ 0 ] );
   1706          	}
   1707          
   1708          #endif /* INCLUDE_pcTaskGetTaskName */
   1709          /*-----------------------------------------------------------*/
   1710          
   1711          #if ( configUSE_TRACE_FACILITY == 1 )
   1712          
   1713          	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
   1714          	{
   1715          	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
   1716          
   1717          		vTaskSuspendAll();
   1718          		{
   1719          			/* Is there a space in the array for each task in the system? */
   1720          			if( uxArraySize >= uxCurrentNumberOfTasks )
   1721          			{
   1722          				/* Fill in an TaskStatus_t structure with information on each
   1723          				task in the Ready state. */
   1724          				do
   1725          				{
   1726          					uxQueue--;
   1727          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   1728          
   1729          				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1730          
   1731          				/* Fill in an TaskStatus_t structure with information on each
   1732          				task in the Blocked state. */
   1733          				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
   1734          				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
   1735          
   1736          				#if( INCLUDE_vTaskDelete == 1 )
   1737          				{
   1738          					/* Fill in an TaskStatus_t structure with information on
   1739          					each task that has been deleted but not yet cleaned up. */
   1740          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   1741          				}
   1742          				#endif
   1743          
   1744          				#if ( INCLUDE_vTaskSuspend == 1 )
   1745          				{
   1746          					/* Fill in an TaskStatus_t structure with information on
   1747          					each task in the Suspended state. */
   1748          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   1749          				}
   1750          				#endif
   1751          
   1752          				#if ( configGENERATE_RUN_TIME_STATS == 1)
   1753          				{
   1754          					if( pulTotalRunTime != NULL )
   1755          					{
   1756          						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   1757          							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
   1758          						#else
   1759          							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   1760          						#endif
   1761          					}
   1762          				}
   1763          				#else
   1764          				{
   1765          					if( pulTotalRunTime != NULL )
   1766          					{
   1767          						*pulTotalRunTime = 0;
   1768          					}
   1769          				}
   1770          				#endif
   1771          			}
   1772          			else
   1773          			{
   1774          				mtCOVERAGE_TEST_MARKER();
   1775          			}
   1776          		}
   1777          		( void ) xTaskResumeAll();
   1778          
   1779          		return uxTask;
   1780          	}
   1781          
   1782          #endif /* configUSE_TRACE_FACILITY */
   1783          /*----------------------------------------------------------*/
   1784          
   1785          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1786          
   1787          	TaskHandle_t xTaskGetIdleTaskHandle( void )
   1788          	{
   1789          		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
   1790          		started, then xIdleTaskHandle will be NULL. */
   1791          		configASSERT( ( xIdleTaskHandle != NULL ) );
   1792          		return xIdleTaskHandle;
   1793          	}
   1794          
   1795          #endif /* INCLUDE_xTaskGetIdleTaskHandle */
   1796          /*----------------------------------------------------------*/
   1797          
   1798          /* This conditional compilation should use inequality to 0, not equality to 1.
   1799          This is to ensure vTaskStepTick() is available when user defined low power mode
   1800          implementations require configUSE_TICKLESS_IDLE to be set to a value other than
   1801          1. */
   1802          #if ( configUSE_TICKLESS_IDLE != 0 )
   1803          
   1804          	void vTaskStepTick( const TickType_t xTicksToJump )
   1805          	{
   1806          		/* Correct the tick count value after a period during which the tick
   1807          		was suppressed.  Note this does *not* call the tick hook function for
   1808          		each stepped tick. */
   1809          		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
   1810          		xTickCount += xTicksToJump;
   1811          		traceINCREASE_TICK_COUNT( xTicksToJump );
   1812          	}
   1813          
   1814          #endif /* configUSE_TICKLESS_IDLE */
   1815          /*----------------------------------------------------------*/
   1816          
   1817          BaseType_t xTaskIncrementTick( void )
   1818          {
   1819          TCB_t * pxTCB;
   1820          TickType_t xItemValue;
   1821          BaseType_t xSwitchRequired = pdFALSE;
   1822          
   1823          	/* Called by the portable layer each time a tick interrupt occurs.
   1824          	Increments the tick then checks to see if the new tick value will cause any
   1825          	tasks to be unblocked. */
   1826          	traceTASK_INCREMENT_TICK( xTickCount );
   1827          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1828          	{
   1829          		/* Increment the RTOS tick, switching the delayed and overflowed
   1830          		delayed lists if it wraps to 0. */
   1831          		++xTickCount;
   1832          
   1833          		{
   1834          			/* Minor optimisation.  The tick count cannot change in this
   1835          			block. */
   1836          			const TickType_t xConstTickCount = xTickCount;
   1837          
   1838          			if( xConstTickCount == ( TickType_t ) 0U )
   1839          			{
   1840          				taskSWITCH_DELAYED_LISTS();
   1841          			}
   1842          			else
   1843          			{
   1844          				mtCOVERAGE_TEST_MARKER();
   1845          			}
   1846          
   1847          			/* See if this tick has made a timeout expire.  Tasks are stored in
   1848          			the	queue in the order of their wake time - meaning once one task
   1849          			has been found whose block time has not expired there is no need to
   1850          			look any further	down the list. */
   1851          			if( xConstTickCount >= xNextTaskUnblockTime )
   1852          			{
   1853          				for( ;; )
   1854          				{
   1855          					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1856          					{
   1857          						/* The delayed list is empty.  Set xNextTaskUnblockTime
   1858          						to the maximum possible value so it is extremely
   1859          						unlikely that the
   1860          						if( xTickCount >= xNextTaskUnblockTime ) test will pass
   1861          						next time through. */
   1862          						xNextTaskUnblockTime = portMAX_DELAY;
   1863          						break;
   1864          					}
   1865          					else
   1866          					{
   1867          						/* The delayed list is not empty, get the value of the
   1868          						item at the head of the delayed list.  This is the time
   1869          						at which the task at the head of the delayed list must
   1870          						be removed from the Blocked state. */
   1871          						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   1872          						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   1873          
   1874          						if( xConstTickCount < xItemValue )
   1875          						{
   1876          							/* It is not time to unblock this item yet, but the
   1877          							item value is the time at which the task at the head
   1878          							of the blocked list must be removed from the Blocked
   1879          							state -	so record the item value in
   1880          							xNextTaskUnblockTime. */
   1881          							xNextTaskUnblockTime = xItemValue;
   1882          							break;
   1883          						}
   1884          						else
   1885          						{
   1886          							mtCOVERAGE_TEST_MARKER();
   1887          						}
   1888          
   1889          						/* It is time to remove the item from the Blocked state. */
   1890          						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   1891          
   1892          						/* Is the task waiting on an event also?  If so remove
   1893          						it from the event list. */
   1894          						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1895          						{
   1896          							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1897          						}
   1898          						else
   1899          						{
   1900          							mtCOVERAGE_TEST_MARKER();
   1901          						}
   1902          
   1903          						/* Place the unblocked task into the appropriate ready
   1904          						list. */
   1905          						prvAddTaskToReadyList( pxTCB );
   1906          
   1907          						/* A task being unblocked cannot cause an immediate
   1908          						context switch if preemption is turned off. */
   1909          						#if (  configUSE_PREEMPTION == 1 )
   1910          						{
   1911          							/* Preemption is on, but a context switch should
   1912          							only be performed if the unblocked task has a
   1913          							priority that is equal to or higher than the
   1914          							currently executing task. */
   1915          							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1916          							{
   1917          								xSwitchRequired = pdTRUE;
   1918          							}
   1919          							else
   1920          							{
   1921          								mtCOVERAGE_TEST_MARKER();
   1922          							}
   1923          						}
   1924          						#endif /* configUSE_PREEMPTION */
   1925          					}
   1926          				}
   1927          			}
   1928          		}
   1929          
   1930          		/* Tasks of equal priority to the currently running task will share
   1931          		processing time (time slice) if preemption is on, and the application
   1932          		writer has not explicitly turned time slicing off. */
   1933          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
   1934          		{
   1935          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   1936          			{
   1937          				xSwitchRequired = pdTRUE;
   1938          			}
   1939          			else
   1940          			{
   1941          				mtCOVERAGE_TEST_MARKER();
   1942          			}
   1943          		}
   1944          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
   1945          
   1946          		#if ( configUSE_TICK_HOOK == 1 )
   1947          		{
   1948          			/* Guard against the tick hook being called when the pended tick
   1949          			count is being unwound (when the scheduler is being unlocked). */
   1950          			if( uxPendedTicks == ( UBaseType_t ) 0U )
   1951          			{
   1952          				vApplicationTickHook();
   1953          			}
   1954          			else
   1955          			{
   1956          				mtCOVERAGE_TEST_MARKER();
   1957          			}
   1958          		}
   1959          		#endif /* configUSE_TICK_HOOK */
   1960          	}
   1961          	else
   1962          	{
   1963          		++uxPendedTicks;
   1964          
   1965          		/* The tick hook gets called at regular intervals, even if the
   1966          		scheduler is locked. */
   1967          		#if ( configUSE_TICK_HOOK == 1 )
   1968          		{
   1969          			vApplicationTickHook();
   1970          		}
   1971          		#endif
   1972          	}
   1973          
   1974          	#if ( configUSE_PREEMPTION == 1 )
   1975          	{
   1976          		if( xYieldPending != pdFALSE )
   1977          		{
   1978          			xSwitchRequired = pdTRUE;
   1979          		}
   1980          		else
   1981          		{
   1982          			mtCOVERAGE_TEST_MARKER();
   1983          		}
   1984          	}
   1985          	#endif /* configUSE_PREEMPTION */
   1986          
   1987          	return xSwitchRequired;
   1988          }
   1989          /*-----------------------------------------------------------*/
   1990          
   1991          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1992          
   1993          	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
   1994          	{
   1995          	TCB_t *xTCB;
   1996          
   1997          		/* If xTask is NULL then it is the task hook of the calling task that is
   1998          		getting set. */
   1999          		if( xTask == NULL )
   2000          		{
   2001          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2002          		}
   2003          		else
   2004          		{
   2005          			xTCB = ( TCB_t * ) xTask;
   2006          		}
   2007          
   2008          		/* Save the hook function in the TCB.  A critical section is required as
   2009          		the value can be accessed from an interrupt. */
   2010          		taskENTER_CRITICAL();
   2011          			xTCB->pxTaskTag = pxHookFunction;
   2012          		taskEXIT_CRITICAL();
   2013          	}
   2014          
   2015          #endif /* configUSE_APPLICATION_TASK_TAG */
   2016          /*-----------------------------------------------------------*/
   2017          
   2018          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2019          
   2020          	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
   2021          	{
   2022          	TCB_t *xTCB;
   2023          	TaskHookFunction_t xReturn;
   2024          
   2025          		/* If xTask is NULL then we are setting our own task hook. */
   2026          		if( xTask == NULL )
   2027          		{
   2028          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2029          		}
   2030          		else
   2031          		{
   2032          			xTCB = ( TCB_t * ) xTask;
   2033          		}
   2034          
   2035          		/* Save the hook function in the TCB.  A critical section is required as
   2036          		the value can be accessed from an interrupt. */
   2037          		taskENTER_CRITICAL();
   2038          		{
   2039          			xReturn = xTCB->pxTaskTag;
   2040          		}
   2041          		taskEXIT_CRITICAL();
   2042          
   2043          		return xReturn;
   2044          	}
   2045          
   2046          #endif /* configUSE_APPLICATION_TASK_TAG */
   2047          /*-----------------------------------------------------------*/
   2048          
   2049          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2050          
   2051          	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
   2052          	{
   2053          	TCB_t *xTCB;
   2054          	BaseType_t xReturn;
   2055          
   2056          		/* If xTask is NULL then we are calling our own task hook. */
   2057          		if( xTask == NULL )
   2058          		{
   2059          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2060          		}
   2061          		else
   2062          		{
   2063          			xTCB = ( TCB_t * ) xTask;
   2064          		}
   2065          
   2066          		if( xTCB->pxTaskTag != NULL )
   2067          		{
   2068          			xReturn = xTCB->pxTaskTag( pvParameter );
   2069          		}
   2070          		else
   2071          		{
   2072          			xReturn = pdFAIL;
   2073          		}
   2074          
   2075          		return xReturn;
   2076          	}
   2077          
   2078          #endif /* configUSE_APPLICATION_TASK_TAG */
   2079          /*-----------------------------------------------------------*/
   2080          
   2081          void vTaskSwitchContext( void )
   2082          {
   2083          	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   2084          	{
   2085          		/* The scheduler is currently suspended - do not allow a context
   2086          		switch. */
   2087          		xYieldPending = pdTRUE;
   2088          	}
   2089          	else
   2090          	{
   2091          		xYieldPending = pdFALSE;
   2092          		traceTASK_SWITCHED_OUT();
   2093          
   2094          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2095          		{
   2096          				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   2097          					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
   2098          				#else
   2099          					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   2100          				#endif
   2101          
   2102          				/* Add the amount of time the task has been running to the
   2103          				accumulated	time so far.  The time the task started running was
   2104          				stored in ulTaskSwitchedInTime.  Note that there is no overflow
   2105          				protection here	so count values are only valid until the timer
   2106          				overflows.  The guard against negative values is to protect
   2107          				against suspect run time stat counter implementations - which
   2108          				are provided by the application, not the kernel. */
   2109          				if( ulTotalRunTime > ulTaskSwitchedInTime )
   2110          				{
   2111          					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   2112          				}
   2113          				else
   2114          				{
   2115          					mtCOVERAGE_TEST_MARKER();
   2116          				}
   2117          				ulTaskSwitchedInTime = ulTotalRunTime;
   2118          		}
   2119          		#endif /* configGENERATE_RUN_TIME_STATS */
   2120          
   2121          		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
   2122          		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
   2123          
   2124          		taskSELECT_HIGHEST_PRIORITY_TASK();
   2125          
   2126          		traceTASK_SWITCHED_IN();
   2127          
   2128          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2129          		{
   2130          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   2131          			structure specific to this task. */
   2132          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   2133          		}
   2134          		#endif /* configUSE_NEWLIB_REENTRANT */
   2135          	}
   2136          }
   2137          /*-----------------------------------------------------------*/
   2138          
   2139          void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
   2140          {
   2141          TickType_t xTimeToWake;
   2142          
   2143          	configASSERT( pxEventList );
   2144          
   2145          	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
   2146          	SCHEDULER SUSPENDED. */
   2147          
   2148          	/* Place the event list item of the TCB in the appropriate event list.
   2149          	This is placed in the list in priority order so the highest priority task
   2150          	is the first to be woken by the event. */
   2151          	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2152          
   2153          	/* We must remove ourselves from the ready list before adding ourselves
   2154          	to the blocked list as the same list item is used for both lists.  We have
   2155          	exclusive access to the ready lists as the scheduler is locked. */
   2156          	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   2157          	{
   2158          		/* The current task must be in a ready list, so there is no need to
   2159          		check, and the port reset macro can be called directly. */
   2160          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2161          	}
   2162          	else
   2163          	{
   2164          		mtCOVERAGE_TEST_MARKER();
   2165          	}
   2166          
   2167          	#if ( INCLUDE_vTaskSuspend == 1 )
   2168          	{
   2169          		if( xTicksToWait == portMAX_DELAY )
   2170          		{
   2171          			/* Add ourselves to the suspended task list instead of a delayed task
   2172          			list to ensure we are not woken by a timing event.  We will block
   2173          			indefinitely. */
   2174          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   2175          		}
   2176          		else
   2177          		{
   2178          			/* Calculate the time at which the task should be woken if the event does
   2179          			not occur.  This may overflow but this doesn't matter. */
   2180          			xTimeToWake = xTickCount + xTicksToWait;
   2181          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2182          		}
   2183          	}
   2184          	#else /* INCLUDE_vTaskSuspend */
   2185          	{
   2186          			/* Calculate the time at which the task should be woken if the event does
   2187          			not occur.  This may overflow but this doesn't matter. */
   2188          			xTimeToWake = xTickCount + xTicksToWait;
   2189          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2190          	}
   2191          	#endif /* INCLUDE_vTaskSuspend */
   2192          }
   2193          /*-----------------------------------------------------------*/
   2194          
   2195          void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
   2196          {
   2197          TickType_t xTimeToWake;
   2198          
   2199          	configASSERT( pxEventList );
   2200          
   2201          	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
   2202          	SCHEDULER SUSPENDED. */
   2203          
   2204          	/* Store the item value in the event list item. */
   2205          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   2206          
   2207          	/* Place the event list item of the TCB at the end of the appropriate event
   2208          	list. */
   2209          	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2210          
   2211          	/* The task must be removed from the ready list before it is added to the
   2212          	blocked list.  Exclusive access can be assured to the ready list as the
   2213          	scheduler is locked. */
   2214          	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   2215          	{
   2216          		/* The current task must be in a ready list, so there is no need to
   2217          		check, and the port reset macro can be called directly. */
   2218          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2219          	}
   2220          	else
   2221          	{
   2222          		mtCOVERAGE_TEST_MARKER();
   2223          	}
   2224          
   2225          	#if ( INCLUDE_vTaskSuspend == 1 )
   2226          	{
   2227          		if( xTicksToWait == portMAX_DELAY )
   2228          		{
   2229          			/* Add the task to the suspended task list instead of a delayed task
   2230          			list to ensure it is not woken by a timing event.  It will block
   2231          			indefinitely. */
   2232          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   2233          		}
   2234          		else
   2235          		{
   2236          			/* Calculate the time at which the task should be woken if the event does
   2237          			not occur.  This may overflow but this doesn't matter. */
   2238          			xTimeToWake = xTickCount + xTicksToWait;
   2239          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2240          		}
   2241          	}
   2242          	#else /* INCLUDE_vTaskSuspend */
   2243          	{
   2244          			/* Calculate the time at which the task should be woken if the event does
   2245          			not occur.  This may overflow but this doesn't matter. */
   2246          			xTimeToWake = xTickCount + xTicksToWait;
   2247          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2248          	}
   2249          	#endif /* INCLUDE_vTaskSuspend */
   2250          }
   2251          /*-----------------------------------------------------------*/
   2252          
   2253          #if configUSE_TIMERS == 1
   2254          
   2255          	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
   2256          	{
   2257          	TickType_t xTimeToWake;
   2258          
   2259          		configASSERT( pxEventList );
   2260          
   2261          		/* This function should not be called by application code hence the
   2262          		'Restricted' in its name.  It is not part of the public API.  It is
   2263          		designed for use by kernel code, and has special calling requirements -
   2264          		it should be called from a critical section. */
   2265          
   2266          
   2267          		/* Place the event list item of the TCB in the appropriate event list.
   2268          		In this case it is assume that this is the only task that is going to
   2269          		be waiting on this event list, so the faster vListInsertEnd() function
   2270          		can be used in place of vListInsert. */
   2271          		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2272          
   2273          		/* We must remove this task from the ready list before adding it to the
   2274          		blocked list as the same list item is used for both lists.  This
   2275          		function is called form a critical section. */
   2276          		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   2277          		{
   2278          			/* The current task must be in a ready list, so there is no need to
   2279          			check, and the port reset macro can be called directly. */
   2280          			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2281          		}
   2282          		else
   2283          		{
   2284          			mtCOVERAGE_TEST_MARKER();
   2285          		}
   2286          
   2287          		/* Calculate the time at which the task should be woken if the event does
   2288          		not occur.  This may overflow but this doesn't matter. */
   2289          		xTimeToWake = xTickCount + xTicksToWait;
   2290          
   2291          		traceTASK_DELAY_UNTIL();
   2292          		prvAddCurrentTaskToDelayedList( xTimeToWake );
   2293          	}
   2294          
   2295          #endif /* configUSE_TIMERS */
   2296          /*-----------------------------------------------------------*/
   2297          
   2298          BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
   2299          {
   2300          TCB_t *pxUnblockedTCB;
   2301          BaseType_t xReturn;
   2302          
   2303          	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
   2304          	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
   2305          
   2306          	/* The event list is sorted in priority order, so we can remove the
   2307          	first in the list, remove the TCB from the delayed list, and add
   2308          	it to the ready list.
   2309          
   2310          	If an event is for a queue that is locked then this function will never
   2311          	get called - the lock count on the queue will get modified instead.  This
   2312          	means we can always expect exclusive access to the event list here.
   2313          
   2314          	This function assumes that a check has already been made to ensure that
   2315          	pxEventList is not empty. */
   2316          	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   2317          	configASSERT( pxUnblockedTCB );
   2318          	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   2319          
   2320          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2321          	{
   2322          		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   2323          		prvAddTaskToReadyList( pxUnblockedTCB );
   2324          	}
   2325          	else
   2326          	{
   2327          		/* The delayed and ready lists cannot be accessed, so hold this task
   2328          		pending until the scheduler is resumed. */
   2329          		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   2330          	}
   2331          
   2332          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   2333          	{
   2334          		/* Return true if the task removed from the event list has
   2335          		a higher priority than the calling task.  This allows
   2336          		the calling task to know if it should force a context
   2337          		switch now. */
   2338          		xReturn = pdTRUE;
   2339          
   2340          		/* Mark that a yield is pending in case the user is not using the
   2341          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   2342          		xYieldPending = pdTRUE;
   2343          	}
   2344          	else
   2345          	{
   2346          		xReturn = pdFALSE;
   2347          	}
   2348          
   2349          	return xReturn;
   2350          }
   2351          /*-----------------------------------------------------------*/
   2352          
   2353          BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
   2354          {
   2355          TCB_t *pxUnblockedTCB;
   2356          BaseType_t xReturn;
   2357          
   2358          	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
   2359          	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
   2360          
   2361          	/* Store the new item value in the event list. */
   2362          	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   2363          
   2364          	/* Remove the TCB from the delayed list, and add it to the ready list. */
   2365          
   2366          	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
   2367          	configASSERT( pxUnblockedTCB );
   2368          	( void ) uxListRemove( pxEventListItem );
   2369          
   2370          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2371          	{
   2372          		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   2373          		prvAddTaskToReadyList( pxUnblockedTCB );
   2374          	}
   2375          	else
   2376          	{
   2377          		/* Cannot access the delayed or ready lists, so will hold this task
   2378          		pending until the scheduler is resumed. */
   2379          		vListInsertEnd( &( xPendingReadyList ), pxEventListItem );
   2380          	}
   2381          
   2382          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   2383          	{
   2384          		/* Return true if the task removed from the event list has
   2385          		a higher priority than the calling task.  This allows
   2386          		the calling task to know if it should force a context
   2387          		switch now. */
   2388          		xReturn = pdTRUE;
   2389          
   2390          		/* Mark that a yield is pending in case the user is not using the
   2391          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   2392          		xYieldPending = pdTRUE;
   2393          	}
   2394          	else
   2395          	{
   2396          		xReturn = pdFALSE;
   2397          	}
   2398          
   2399          	return xReturn;
   2400          }
   2401          /*-----------------------------------------------------------*/
   2402          
   2403          void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
   2404          {
   2405          	configASSERT( pxTimeOut );
   2406          	pxTimeOut->xOverflowCount = xNumOfOverflows;
   2407          	pxTimeOut->xTimeOnEntering = xTickCount;
   2408          }
   2409          /*-----------------------------------------------------------*/
   2410          
   2411          BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
   2412          {
   2413          BaseType_t xReturn;
   2414          
   2415          	configASSERT( pxTimeOut );
   2416          	configASSERT( pxTicksToWait );
   2417          
   2418          	taskENTER_CRITICAL();
   2419          	{
   2420          		/* Minor optimisation.  The tick count cannot change in this block. */
   2421          		const TickType_t xConstTickCount = xTickCount;
   2422          
   2423          		#if ( INCLUDE_vTaskSuspend == 1 )
   2424          			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
   2425          			the maximum block time then the task should block indefinitely, and
   2426          			therefore never time out. */
   2427          			if( *pxTicksToWait == portMAX_DELAY )
   2428          			{
   2429          				xReturn = pdFALSE;
   2430          			}
   2431          			else /* We are not blocking indefinitely, perform the checks below. */
   2432          		#endif
   2433          
   2434          		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   2435          		{
   2436          			/* The tick count is greater than the time at which vTaskSetTimeout()
   2437          			was called, but has also overflowed since vTaskSetTimeOut() was called.
   2438          			It must have wrapped all the way around and gone past us again. This
   2439          			passed since vTaskSetTimeout() was called. */
   2440          			xReturn = pdTRUE;
   2441          		}
   2442          		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
   2443          		{
   2444          			/* Not a genuine timeout. Adjust parameters for time remaining. */
   2445          			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
   2446          			vTaskSetTimeOutState( pxTimeOut );
   2447          			xReturn = pdFALSE;
   2448          		}
   2449          		else
   2450          		{
   2451          			xReturn = pdTRUE;
   2452          		}
   2453          	}
   2454          	taskEXIT_CRITICAL();
   2455          
   2456          	return xReturn;
   2457          }
   2458          /*-----------------------------------------------------------*/
   2459          
   2460          void vTaskMissedYield( void )
   2461          {
   2462          	xYieldPending = pdTRUE;
   2463          }
   2464          /*-----------------------------------------------------------*/
   2465          
   2466          #if ( configUSE_TRACE_FACILITY == 1 )
   2467          
   2468          	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
   2469          	{
   2470          	UBaseType_t uxReturn;
   2471          	TCB_t *pxTCB;
   2472          
   2473          		if( xTask != NULL )
   2474          		{
   2475          			pxTCB = ( TCB_t * ) xTask;
   2476          			uxReturn = pxTCB->uxTaskNumber;
   2477          		}
   2478          		else
   2479          		{
   2480          			uxReturn = 0U;
   2481          		}
   2482          
   2483          		return uxReturn;
   2484          	}
   2485          
   2486          #endif /* configUSE_TRACE_FACILITY */
   2487          /*-----------------------------------------------------------*/
   2488          
   2489          #if ( configUSE_TRACE_FACILITY == 1 )
   2490          
   2491          	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
   2492          	{
   2493          	TCB_t *pxTCB;
   2494          
   2495          		if( xTask != NULL )
   2496          		{
   2497          			pxTCB = ( TCB_t * ) xTask;
   2498          			pxTCB->uxTaskNumber = uxHandle;
   2499          		}
   2500          	}
   2501          
   2502          #endif /* configUSE_TRACE_FACILITY */
   2503          
   2504          /*
   2505           * -----------------------------------------------------------
   2506           * The Idle task.
   2507           * ----------------------------------------------------------
   2508           *
   2509           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   2510           * language extensions.  The equivalent prototype for this function is:
   2511           *
   2512           * void prvIdleTask( void *pvParameters );
   2513           *
   2514           */
   2515          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   2516          {
   2517          	/* Stop warnings. */
   2518          	( void ) pvParameters;
   2519          
   2520          	for( ;; )
   2521          	{
   2522          		/* See if any tasks have been deleted. */
   2523          		prvCheckTasksWaitingTermination();
   2524          
   2525          		#if ( configUSE_PREEMPTION == 0 )
   2526          		{
   2527          			/* If we are not using preemption we keep forcing a task switch to
   2528          			see if any other task has become available.  If we are using
   2529          			preemption we don't need to do this as any task becoming available
   2530          			will automatically get the processor anyway. */
   2531          			taskYIELD();
   2532          		}
   2533          		#endif /* configUSE_PREEMPTION */
   2534          
   2535          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   2536          		{
   2537          			/* When using preemption tasks of equal priority will be
   2538          			timesliced.  If a task that is sharing the idle priority is ready
   2539          			to run then the idle task should yield before the end of the
   2540          			timeslice.
   2541          
   2542          			A critical region is not required here as we are just reading from
   2543          			the list, and an occasional incorrect value will not matter.  If
   2544          			the ready list at the idle priority contains more than one task
   2545          			then a task other than the idle task is ready to execute. */
   2546          			    if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   2547          			{
   2548          				taskYIELD();
   2549          			}
   2550          			else
   2551          			{
   2552          				mtCOVERAGE_TEST_MARKER();
   2553          			}
   2554          		}
   2555          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
   2556          
   2557          		#if ( configUSE_IDLE_HOOK == 1 )
   2558          		{
   2559          			extern void vApplicationIdleHook( void );
   2560          
   2561          			/* Call the user defined function from within the idle task.  This
   2562          			allows the application designer to add background functionality
   2563          			without the overhead of a separate task.
   2564          			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   2565          			CALL A FUNCTION THAT MIGHT BLOCK. */
   2566          			vApplicationIdleHook();
   2567          		}
   2568          		#endif /* configUSE_IDLE_HOOK */
   2569          
   2570          		/* This conditional compilation should use inequality to 0, not equality
   2571          		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
   2572          		user defined low power mode	implementations require
   2573          		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
   2574          		#if ( configUSE_TICKLESS_IDLE != 0 )
   2575          		{
   2576          		TickType_t xExpectedIdleTime;
   2577          
   2578          			/* It is not desirable to suspend then resume the scheduler on
   2579          			each iteration of the idle task.  Therefore, a preliminary
   2580          			test of the expected idle time is performed without the
   2581          			scheduler suspended.  The result here is not necessarily
   2582          			valid. */
   2583          			xExpectedIdleTime = prvGetExpectedIdleTime();
   2584          
   2585          			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2586          			{
   2587          				vTaskSuspendAll();
   2588          				{
   2589          					/* Now the scheduler is suspended, the expected idle
   2590          					time can be sampled again, and this time its value can
   2591          					be used. */
   2592          					configASSERT( xNextTaskUnblockTime >= xTickCount );
   2593          					xExpectedIdleTime = prvGetExpectedIdleTime();
   2594          
   2595          					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2596          					{
   2597          						traceLOW_POWER_IDLE_BEGIN();
   2598          						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
   2599          						traceLOW_POWER_IDLE_END();
   2600          					}
   2601          					else
   2602          					{
   2603          						mtCOVERAGE_TEST_MARKER();
   2604          					}
   2605          				}
   2606          				( void ) xTaskResumeAll();
   2607          			}
   2608          			else
   2609          			{
   2610          				mtCOVERAGE_TEST_MARKER();
   2611          			}
   2612          		}
   2613          		#endif /* configUSE_TICKLESS_IDLE */
   2614          	}
   2615          }
   2616          /*-----------------------------------------------------------*/
   2617          
   2618          #if configUSE_TICKLESS_IDLE != 0
   2619          
   2620          	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
   2621          	{
   2622          	eSleepModeStatus eReturn = eStandardSleep;
   2623          
   2624          		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
   2625          		{
   2626          			/* A task was made ready while the scheduler was suspended. */
   2627          			eReturn = eAbortSleep;
   2628          		}
   2629          		else if( xYieldPending != pdFALSE )
   2630          		{
   2631          			/* A yield was pended while the scheduler was suspended. */
   2632          			eReturn = eAbortSleep;
   2633          		}
   2634          		else
   2635          		{
   2636          			#if configUSE_TIMERS == 0
   2637          			{
   2638          				/* The idle task exists in addition to the application tasks. */
   2639          				const UBaseType_t uxNonApplicationTasks = 1;
   2640          
   2641          				/* If timers are not being used and all the tasks are in the
   2642          				suspended list (which might mean they have an infinite block
   2643          				time rather than actually being suspended) then it is safe to
   2644          				turn all clocks off and just wait for external interrupts. */
   2645          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
   2646          				{
   2647          					eReturn = eNoTasksWaitingTimeout;
   2648          				}
   2649          				else
   2650          				{
   2651          					mtCOVERAGE_TEST_MARKER();
   2652          				}
   2653          			}
   2654          			#endif /* configUSE_TIMERS */
   2655          		}
   2656          
   2657          		return eReturn;
   2658          	}
   2659          #endif /* configUSE_TICKLESS_IDLE */
   2660          /*-----------------------------------------------------------*/
   2661          
   2662          static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2663          {
   2664          UBaseType_t x;
   2665          
   2666          	/* Store the task name in the TCB. */
   2667          	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   2668          	{
   2669          		pxTCB->pcTaskName[ x ] = pcName[ x ];
   2670          
   2671          		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
   2672          		configMAX_TASK_NAME_LEN characters just in case the memory after the
   2673          		string is not accessible (extremely unlikely). */
   2674          		if( pcName[ x ] == 0x00 )
   2675          		{
   2676          			break;
   2677          		}
   2678          		else
   2679          		{
   2680          			mtCOVERAGE_TEST_MARKER();
   2681          		}
   2682          	}
   2683          
   2684          	/* Ensure the name string is terminated in the case that the string length
   2685          	was greater or equal to configMAX_TASK_NAME_LEN. */
   2686          	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   2687          
   2688          	/* This is used as an array index so must ensure it's not too large.  First
   2689          	remove the privilege bit if one is present. */
   2690          	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   2691          	{
   2692          		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   2693          	}
   2694          	else
   2695          	{
   2696          		mtCOVERAGE_TEST_MARKER();
   2697          	}
   2698          
   2699          	pxTCB->uxPriority = uxPriority;
   2700          	#if ( configUSE_MUTEXES == 1 )
   2701          	{
   2702          		pxTCB->uxBasePriority = uxPriority;
   2703          	}
   2704          	#endif /* configUSE_MUTEXES */
   2705          
   2706          	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   2707          	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   2708          
   2709          	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
   2710          	back to	the containing TCB from a generic item in a list. */
   2711          	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   2712          
   2713          	/* Event lists are always in priority order. */
   2714          	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2715          	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   2716          
   2717          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2718          	{
   2719          		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
   2720          	}
   2721          	#endif /* portCRITICAL_NESTING_IN_TCB */
   2722          
   2723          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2724          	{
   2725          		pxTCB->pxTaskTag = NULL;
   2726          	}
   2727          	#endif /* configUSE_APPLICATION_TASK_TAG */
   2728          
   2729          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2730          	{
   2731          		pxTCB->ulRunTimeCounter = 0UL;
   2732          	}
   2733          	#endif /* configGENERATE_RUN_TIME_STATS */
   2734          
   2735          	#if ( portUSING_MPU_WRAPPERS == 1 )
   2736          	{
   2737          		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
   2738          	}
   2739          	#else /* portUSING_MPU_WRAPPERS */
   2740          	{
   2741          		( void ) xRegions;
   2742          		( void ) usStackDepth;
   2743          	}
   2744          	#endif /* portUSING_MPU_WRAPPERS */
   2745          
   2746          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2747          	{
   2748          		/* Initialise this task's Newlib reent structure. */
   2749          		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
   2750          	}
   2751          	#endif /* configUSE_NEWLIB_REENTRANT */
   2752          }
   2753          /*-----------------------------------------------------------*/
   2754          
   2755          #if ( portUSING_MPU_WRAPPERS == 1 )
   2756          
   2757          	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
   2758          	{
   2759          	TCB_t *pxTCB;
   2760          
   2761          		/* If null is passed in here then we are deleting ourselves. */
   2762          		pxTCB = prvGetTCBFromHandle( xTaskToModify );
   2763          
   2764                  vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   2765          	}
   2766          
   2767          #endif /* portUSING_MPU_WRAPPERS */
   2768          /*-----------------------------------------------------------*/
   2769          
   2770          static void prvInitialiseTaskLists( void )
   2771          {
   2772          UBaseType_t uxPriority;
   2773          
   2774          	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   2775          	{
   2776          		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   2777          	}
   2778          
   2779          	vListInitialise( &xDelayedTaskList1 );
   2780          	vListInitialise( &xDelayedTaskList2 );
   2781          	vListInitialise( &xPendingReadyList );
   2782          
   2783          	#if ( INCLUDE_vTaskDelete == 1 )
   2784          	{
   2785          		vListInitialise( &xTasksWaitingTermination );
   2786          	}
   2787          	#endif /* INCLUDE_vTaskDelete */
   2788          
   2789          	#if ( INCLUDE_vTaskSuspend == 1 )
   2790          	{
   2791          		vListInitialise( &xSuspendedTaskList );
   2792          	}
   2793          	#endif /* INCLUDE_vTaskSuspend */
   2794          
   2795          	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   2796          	using list2. */
   2797          	pxDelayedTaskList = &xDelayedTaskList1;
   2798          	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   2799          }
   2800          /*-----------------------------------------------------------*/
   2801          
   2802          static void prvCheckTasksWaitingTermination( void )
   2803          {
   2804          	#if ( INCLUDE_vTaskDelete == 1 )
   2805          	{
   2806          		BaseType_t xListIsEmpty;
   2807          
   2808          		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
   2809          		too often in the idle task. */
   2810          		while( uxTasksDeleted > ( UBaseType_t ) 0U )
   2811          		{
   2812          			vTaskSuspendAll();
   2813          				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   2814          			( void ) xTaskResumeAll();
   2815          
   2816          			if( xListIsEmpty == pdFALSE )
   2817          			{
   2818          				TCB_t *pxTCB;
   2819          
   2820          				taskENTER_CRITICAL();
   2821          				{
   2822          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   2823          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   2824          					--uxCurrentNumberOfTasks;
   2825          					--uxTasksDeleted;
   2826          				}
   2827          				taskEXIT_CRITICAL();
   2828          
   2829          				prvDeleteTCB( pxTCB );
   2830          			}
   2831          			else
   2832          			{
   2833          				mtCOVERAGE_TEST_MARKER();
   2834          			}
   2835          		}
   2836          	}
   2837          	#endif /* vTaskDelete */
   2838          }
   2839          /*-----------------------------------------------------------*/
   2840          
   2841          static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
   2842          {
   2843          	/* The list item will be inserted in wake time order. */
   2844          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   2845          
   2846          	if( xTimeToWake < xTickCount )
   2847          	{
   2848          		/* Wake time has overflowed.  Place this item in the overflow list. */
   2849          		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   2850          	}
   2851          	else
   2852          	{
   2853          		/* The wake time has not overflowed, so the current block list is used. */
   2854          		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   2855          
   2856          		/* If the task entering the blocked state was placed at the head of the
   2857          		list of blocked tasks then xNextTaskUnblockTime needs to be updated
   2858          		too. */
   2859          		if( xTimeToWake < xNextTaskUnblockTime )
   2860          		{
   2861          			xNextTaskUnblockTime = xTimeToWake;
   2862          		}
   2863          		else
   2864          		{
   2865          			mtCOVERAGE_TEST_MARKER();
   2866          		}
   2867          	}
   2868          }
   2869          /*-----------------------------------------------------------*/
   2870          
   2871          static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
   2872          {
   2873          TCB_t *pxNewTCB;
   2874          
   2875          	/* Allocate space for the TCB.  Where the memory comes from depends on
   2876          	the implementation of the port malloc function. */
   2877          	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
   2878          
   2879          	if( pxNewTCB != NULL )
   2880          	{
   2881          		/* Allocate space for the stack used by the task being created.
   2882          		The base of the stack memory stored in the TCB so the task can
   2883          		be deleted later if required. */
   2884          		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2885          
   2886          		if( pxNewTCB->pxStack == NULL )
   2887          		{
   2888          			/* Could not allocate the stack.  Delete the allocated TCB. */
   2889          			vPortFree( pxNewTCB );
   2890          			pxNewTCB = NULL;
   2891          		}
   2892          		else
   2893          		{
   2894          			/* Avoid dependency on memset() if it is not required. */
   2895          			#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   2896          			{
   2897          				/* Just to help debugging. */
   2898          				( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
   2899          			}
   2900          			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
   2901          		}
   2902          	}
   2903          
   2904          	return pxNewTCB;
   2905          }
   2906          /*-----------------------------------------------------------*/
   2907          
   2908          #if ( configUSE_TRACE_FACILITY == 1 )
   2909          
   2910          	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
   2911          	{
   2912          	volatile TCB_t *pxNextTCB, *pxFirstTCB;
   2913          	UBaseType_t uxTask = 0;
   2914          
   2915          		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   2916          		{
   2917          			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   2918          
   2919          			/* Populate an TaskStatus_t structure within the
   2920          			pxTaskStatusArray array for each task that is referenced from
   2921          			pxList.  See the definition of TaskStatus_t in task.h for the
   2922          			meaning of each TaskStatus_t structure member. */
   2923          			do
   2924          			{
   2925          				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   2926          
   2927          				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
   2928          				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
   2929          				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
   2930          				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
   2931          				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
   2932          
   2933          				#if ( configUSE_MUTEXES == 1 )
   2934          				{
   2935          					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
   2936          				}
   2937          				#else
   2938          				{
   2939          					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
   2940          				}
   2941          				#endif
   2942          
   2943          				#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2944          				{
   2945          					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
   2946          				}
   2947          				#else
   2948          				{
   2949          					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
   2950          				}
   2951          				#endif
   2952          
   2953          				#if ( portSTACK_GROWTH > 0 )
   2954          				{
   2955          					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
   2956          				}
   2957          				#else
   2958          				{
   2959          					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
   2960          				}
   2961          				#endif
   2962          
   2963          				uxTask++;
   2964          
   2965          			} while( pxNextTCB != pxFirstTCB );
   2966          		}
   2967          		else
   2968          		{
   2969          			mtCOVERAGE_TEST_MARKER();
   2970          		}
   2971          
   2972          		return uxTask;
   2973          	}
   2974          
   2975          #endif /* configUSE_TRACE_FACILITY */
   2976          /*-----------------------------------------------------------*/
   2977          
   2978          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   2979          
   2980          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
   2981          	{
   2982          	uint32_t ulCount = 0U;
   2983          
   2984          		while( *pucStackByte == tskSTACK_FILL_BYTE )
   2985          		{
   2986          			pucStackByte -= portSTACK_GROWTH;
   2987          			ulCount++;
   2988          		}
   2989          
   2990          		ulCount /= ( uint32_t ) sizeof( StackType_t );
   2991          
   2992          		return ( uint16_t ) ulCount;
   2993          	}
   2994          
   2995          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
   2996          /*-----------------------------------------------------------*/
   2997          
   2998          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   2999          
   3000          	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
   3001          	{
   3002          	TCB_t *pxTCB;
   3003          	uint8_t *pucEndOfStack;
   3004          	UBaseType_t uxReturn;
   3005          
   3006          		pxTCB = prvGetTCBFromHandle( xTask );
   3007          
   3008          		#if portSTACK_GROWTH < 0
   3009          		{
   3010          			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
   3011          		}
   3012          		#else
   3013          		{
   3014          			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
   3015          		}
   3016          		#endif
   3017          
   3018          		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
   3019          
   3020          		return uxReturn;
   3021          	}
   3022          
   3023          #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
   3024          /*-----------------------------------------------------------*/
   3025          
   3026          #if ( INCLUDE_vTaskDelete == 1 )
   3027          
   3028          	static void prvDeleteTCB( TCB_t *pxTCB )
   3029          	{
   3030          		/* This call is required specifically for the TriCore port.  It must be
   3031          		above the vPortFree() calls.  The call is also used by ports/demos that
   3032          		want to allocate and clean RAM statically. */
   3033          		portCLEAN_UP_TCB( pxTCB );
   3034          
   3035          		/* Free up the memory allocated by the scheduler for the task.  It is up to
   3036          		the task to free any memory allocated at the application level. */
   3037          		vPortFreeAligned( pxTCB->pxStack );
   3038          		vPortFree( pxTCB );
   3039          	}
   3040          
   3041          #endif /* INCLUDE_vTaskDelete */
   3042          /*-----------------------------------------------------------*/
   3043          
   3044          static void prvResetNextTaskUnblockTime( void )
   3045          {
   3046          TCB_t *pxTCB;
   3047          
   3048          	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   3049          	{
   3050          		/* The new current delayed list is empty.  Set
   3051          		xNextTaskUnblockTime to the maximum possible value so it is
   3052          		extremely unlikely that the
   3053          		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
   3054          		there is an item in the delayed list. */
   3055          		xNextTaskUnblockTime = portMAX_DELAY;
   3056          	}
   3057          	else
   3058          	{
   3059          		/* The new current delayed list is not empty, get the value of
   3060          		the item at the head of the delayed list.  This is the time at
   3061          		which the task at the head of the delayed list should be removed
   3062          		from the Blocked state. */
   3063          		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   3064          		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
   3065          	}
   3066          }
   3067          /*-----------------------------------------------------------*/
   3068          
   3069          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
   3070          
   3071          	TaskHandle_t xTaskGetCurrentTaskHandle( void )
   3072          	{
   3073          	TaskHandle_t xReturn;
   3074          
   3075          		/* A critical section is not required as this is not called from
   3076          		an interrupt and the current TCB will always be the same for any
   3077          		individual execution thread. */
   3078          		xReturn = pxCurrentTCB;
   3079          
   3080          		return xReturn;
   3081          	}
   3082          
   3083          #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
   3084          /*-----------------------------------------------------------*/
   3085          
   3086          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   3087          
   3088          	BaseType_t xTaskGetSchedulerState( void )
   3089          	{
   3090          	BaseType_t xReturn;
   3091          
   3092          		if( xSchedulerRunning == pdFALSE )
   3093          		{
   3094          			xReturn = taskSCHEDULER_NOT_STARTED;
   3095          		}
   3096          		else
   3097          		{
   3098          			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   3099          			{
   3100          				xReturn = taskSCHEDULER_RUNNING;
   3101          			}
   3102          			else
   3103          			{
   3104          				xReturn = taskSCHEDULER_SUSPENDED;
   3105          			}
   3106          		}
   3107          
   3108          		return xReturn;
   3109          	}
   3110          
   3111          #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
   3112          /*-----------------------------------------------------------*/
   3113          
   3114          #if ( configUSE_MUTEXES == 1 )
   3115          
   3116          	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
   3117          	{
   3118          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3119          
   3120          		/* If the mutex was given back by an interrupt while the queue was
   3121          		locked then the mutex holder might now be NULL. */
   3122          		if( pxMutexHolder != NULL )
   3123          		{
   3124          			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   3125          			{
   3126          				/* Adjust the mutex holder state to account for its new
   3127          				priority.  Only reset the event list item value if the value is
   3128          				not	being used for anything else. */
   3129          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   3130          				{
   3131          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3132          				}
   3133          				else
   3134          				{
   3135          					mtCOVERAGE_TEST_MARKER();
   3136          				}
   3137          
   3138          				/* If the task being modified is in the ready state it will need to
   3139          				be moved into a new list. */
   3140          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   3141          				{
   3142          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3143          					{
   3144          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   3145          					}
   3146          					else
   3147          					{
   3148          						mtCOVERAGE_TEST_MARKER();
   3149          					}
   3150          
   3151          					/* Inherit the priority before being moved into the new list. */
   3152          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   3153          					prvAddTaskToReadyList( pxTCB );
   3154          				}
   3155          				else
   3156          				{
   3157          					/* Just inherit the priority. */
   3158          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   3159          				}
   3160          
   3161          				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
   3162          			}
   3163          			else
   3164          			{
   3165          				mtCOVERAGE_TEST_MARKER();
   3166          			}
   3167          		}
   3168          		else
   3169          		{
   3170          			mtCOVERAGE_TEST_MARKER();
   3171          		}
   3172          	}
   3173          
   3174          #endif /* configUSE_MUTEXES */
   3175          /*-----------------------------------------------------------*/
   3176          
   3177          #if ( configUSE_MUTEXES == 1 )
   3178          
   3179          	void vTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
   3180          	{
   3181          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3182          
   3183          		if( pxMutexHolder != NULL )
   3184          		{
   3185          			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   3186          			{
   3187          				/* We must be the running task to be able to give the mutex back.
   3188          				Remove ourselves from the ready list we currently appear in. */
   3189          				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3190          				{
   3191          					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   3192          				}
   3193          				else
   3194          				{
   3195          					mtCOVERAGE_TEST_MARKER();
   3196          				}
   3197          
   3198          				/* Disinherit the priority before adding the task into the new
   3199          				ready list. */
   3200          				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   3201          				pxTCB->uxPriority = pxTCB->uxBasePriority;
   3202          
   3203          				/* Only reset the event list item value if the value is not
   3204          				being used for anything else. */
   3205          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   3206          				{
   3207          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3208          				}
   3209          				else
   3210          				{
   3211          					mtCOVERAGE_TEST_MARKER();
   3212          				}
   3213          				prvAddTaskToReadyList( pxTCB );
   3214          			}
   3215          			else
   3216          			{
   3217          				mtCOVERAGE_TEST_MARKER();
   3218          			}
   3219          		}
   3220          		else
   3221          		{
   3222          			mtCOVERAGE_TEST_MARKER();
   3223          		}
   3224          	}
   3225          
   3226          #endif /* configUSE_MUTEXES */
   3227          /*-----------------------------------------------------------*/
   3228          
   3229          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   3230          
   3231          	void vTaskEnterCritical( void )
   3232          	{
   3233          		portDISABLE_INTERRUPTS();
   3234          
   3235          		if( xSchedulerRunning != pdFALSE )
   3236          		{
   3237          			( pxCurrentTCB->uxCriticalNesting )++;
   3238          		}
   3239          		else
   3240          		{
   3241          			mtCOVERAGE_TEST_MARKER();
   3242          		}
   3243          	}
   3244          
   3245          #endif /* portCRITICAL_NESTING_IN_TCB */
   3246          /*-----------------------------------------------------------*/
   3247          
   3248          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   3249          
   3250          	void vTaskExitCritical( void )
   3251          	{
   3252          		if( xSchedulerRunning != pdFALSE )
   3253          		{
   3254          			if( pxCurrentTCB->uxCriticalNesting > 0U )
   3255          			{
   3256          				( pxCurrentTCB->uxCriticalNesting )--;
   3257          
   3258          				if( pxCurrentTCB->uxCriticalNesting == 0U )
   3259          				{
   3260          					portENABLE_INTERRUPTS();
   3261          				}
   3262          				else
   3263          				{
   3264          					mtCOVERAGE_TEST_MARKER();
   3265          				}
   3266          			}
   3267          			else
   3268          			{
   3269          				mtCOVERAGE_TEST_MARKER();
   3270          			}
   3271          		}
   3272          		else
   3273          		{
   3274          			mtCOVERAGE_TEST_MARKER();
   3275          		}
   3276          	}
   3277          
   3278          #endif /* portCRITICAL_NESTING_IN_TCB */
   3279          /*-----------------------------------------------------------*/
   3280          
   3281          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
   3282          
   3283          	void vTaskList( char * pcWriteBuffer )
   3284          	{
   3285          	TaskStatus_t *pxTaskStatusArray;
   3286          	volatile UBaseType_t uxArraySize, x;
   3287          	char cStatus;
   3288          
   3289          		/*
   3290          		 * PLEASE NOTE:
   3291          		 *
   3292          		 * This function is provided for convenience only, and is used by many
   3293          		 * of the demo applications.  Do not consider it to be part of the
   3294          		 * scheduler.
   3295          		 *
   3296          		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
   3297          		 * uxTaskGetSystemState() output into a human readable table that
   3298          		 * displays task names, states and stack usage.
   3299          		 *
   3300          		 * vTaskList() has a dependency on the sprintf() C library function that
   3301          		 * might bloat the code size, use a lot of stack, and provide different
   3302          		 * results on different platforms.  An alternative, tiny, third party,
   3303          		 * and limited functionality implementation of sprintf() is provided in
   3304          		 * many of the FreeRTOS/Demo sub-directories in a file called
   3305          		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
   3306          		 * snprintf() implementation!).
   3307          		 *
   3308          		 * It is recommended that production systems call uxTaskGetSystemState()
   3309          		 * directly to get access to raw stats data, rather than indirectly
   3310          		 * through a call to vTaskList().
   3311          		 */
   3312          
   3313          
   3314          		/* Make sure the write buffer does not contain a string. */
   3315          		*pcWriteBuffer = 0x00;
   3316          
   3317          		/* Take a snapshot of the number of tasks in case it changes while this
   3318          		function is executing. */
   3319          		uxArraySize = uxCurrentNumberOfTasks;
   3320          
   3321          		/* Allocate an array index for each task. */
   3322          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   3323          
   3324          		if( pxTaskStatusArray != NULL )
   3325          		{
   3326          			/* Generate the (binary) data. */
   3327          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   3328          
   3329          			/* Create a human readable table from the binary data. */
   3330          			for( x = 0; x < uxArraySize; x++ )
   3331          			{
   3332          				switch( pxTaskStatusArray[ x ].eCurrentState )
   3333          				{
   3334          				case eReady:		cStatus = tskREADY_CHAR;
   3335          									break;
   3336          
   3337          				case eBlocked:		cStatus = tskBLOCKED_CHAR;
   3338          									break;
   3339          
   3340          				case eSuspended:	cStatus = tskSUSPENDED_CHAR;
   3341          									break;
   3342          
   3343          				case eDeleted:		cStatus = tskDELETED_CHAR;
   3344          									break;
   3345          
   3346          				default:			/* Should not get here, but it is included
   3347          									to prevent static checking errors. */
   3348          									cStatus = 0x00;
   3349          									break;
   3350          				}
   3351          
   3352          				sprintf( pcWriteBuffer, "%s\t\t%c\t%u\t%u\t%u\r\n", pxTaskStatusArray[ x ].pcTaskName, cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
   3353          				pcWriteBuffer += strlen( pcWriteBuffer );
   3354          			}
   3355          
   3356          			/* Free the array again. */
   3357          			vPortFree( pxTaskStatusArray );
   3358          		}
   3359          		else
   3360          		{
   3361          			mtCOVERAGE_TEST_MARKER();
   3362          		}
   3363          	}
   3364          
   3365          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
   3366          /*----------------------------------------------------------*/
   3367          
   3368          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
   3369          
   3370          	void vTaskGetRunTimeStats( char *pcWriteBuffer )
   3371          	{
   3372          	TaskStatus_t *pxTaskStatusArray;
   3373          	volatile UBaseType_t uxArraySize, x;
   3374          	uint32_t ulTotalTime, ulStatsAsPercentage;
   3375          
   3376          		/*
   3377          		 * PLEASE NOTE:
   3378          		 *
   3379          		 * This function is provided for convenience only, and is used by many
   3380          		 * of the demo applications.  Do not consider it to be part of the
   3381          		 * scheduler.
   3382          		 *
   3383          		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
   3384          		 * of the uxTaskGetSystemState() output into a human readable table that
   3385          		 * displays the amount of time each task has spent in the Running state
   3386          		 * in both absolute and percentage terms.
   3387          		 *
   3388          		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
   3389          		 * function that might bloat the code size, use a lot of stack, and
   3390          		 * provide different results on different platforms.  An alternative,
   3391          		 * tiny, third party, and limited functionality implementation of
   3392          		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
   3393          		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
   3394          		 * a full snprintf() implementation!).
   3395          		 *
   3396          		 * It is recommended that production systems call uxTaskGetSystemState()
   3397          		 * directly to get access to raw stats data, rather than indirectly
   3398          		 * through a call to vTaskGetRunTimeStats().
   3399          		 */
   3400          
   3401          		/* Make sure the write buffer does not contain a string. */
   3402          		*pcWriteBuffer = 0x00;
   3403          
   3404          		/* Take a snapshot of the number of tasks in case it changes while this
   3405          		function is executing. */
   3406          		uxArraySize = uxCurrentNumberOfTasks;
   3407          
   3408          		/* Allocate an array index for each task. */
   3409          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   3410          
   3411          		if( pxTaskStatusArray != NULL )
   3412          		{
   3413          			/* Generate the (binary) data. */
   3414          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   3415          
   3416          			/* For percentage calculations. */
   3417          			ulTotalTime /= 100UL;
   3418          
   3419          			/* Avoid divide by zero errors. */
   3420          			if( ulTotalTime > 0 )
   3421          			{
   3422          				/* Create a human readable table from the binary data. */
   3423          				for( x = 0; x < uxArraySize; x++ )
   3424          				{
   3425          					/* What percentage of the total run time has the task used?
   3426          					This will always be rounded down to the nearest integer.
   3427          					ulTotalRunTimeDiv100 has already been divided by 100. */
   3428          					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   3429          
   3430          					if( ulStatsAsPercentage > 0UL )
   3431          					{
   3432          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   3433          						{
   3434          							sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
   3435          						}
   3436          						#else
   3437          						{
   3438          							/* sizeof( int ) == sizeof( long ) so a smaller
   3439          							printf() library can be used. */
   3440          							sprintf( pcWriteBuffer, "%s\t\t%u\t\t%u%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
   3441          						}
   3442          						#endif
   3443          					}
   3444          					else
   3445          					{
   3446          						/* If the percentage is zero here then the task has
   3447          						consumed less than 1% of the total run time. */
   3448          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   3449          						{
   3450          							sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
   3451          						}
   3452          						#else
   3453          						{
   3454          							/* sizeof( int ) == sizeof( long ) so a smaller
   3455          							printf() library can be used. */
   3456          							sprintf( pcWriteBuffer, "%s\t\t%u\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
   3457          						}
   3458          						#endif
   3459          					}
   3460          
   3461          					pcWriteBuffer += strlen( pcWriteBuffer );
   3462          				}
   3463          			}
   3464          			else
   3465          			{
   3466          				mtCOVERAGE_TEST_MARKER();
   3467          			}
   3468          
   3469          			/* Free the array again. */
   3470          			vPortFree( pxTaskStatusArray );
   3471          		}
   3472          		else
   3473          		{
   3474          			mtCOVERAGE_TEST_MARKER();
   3475          		}
   3476          	}
   3477          
   3478          #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
   3479          /*-----------------------------------------------------------*/
   3480          
   3481          TickType_t uxTaskResetEventItemValue( void )
   3482          {
   3483          TickType_t uxReturn;
   3484          
   3485          	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   3486          
   3487          	/* Reset the event list item to its normal value - so it can be used with
   3488          	queues and semaphores. */
   3489          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3490          
   3491          	return uxReturn;
   3492          }
   3493          /*-----------------------------------------------------------*/
   3494          
   3495          #ifdef FREERTOS_MODULE_TEST
   3496          	#include "tasks_test_access_functions.h"
   3497          #endif
   3498          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  prvAddCurrentTaskToDelayedList
              0 -> vListInsert
             16 -> vListInsert
       16  prvIdleTask
             16 -> uxListRemove
             16 -> vPortEnterCritical
             16 -> vPortExitCritical
             16 -> vPortFree
             16 -> vPortYield
             16 -> xTaskResumeAll
        0  prvResetNextTaskUnblockTime
        0  uxTaskGetNumberOfTasks
        8  uxTaskPriorityGet
              8 -> vPortEnterCritical
              8 -> vPortExitCritical
        0  uxTaskResetEventItemValue
       16  vTaskDelay
             16 -> prvAddCurrentTaskToDelayedList
             16 -> ulPortSetInterruptMask
             16 -> uxListRemove
              0 -> vPortYield
             16 -> xTaskResumeAll
        8  vTaskDelayUntil
              8 -> prvAddCurrentTaskToDelayedList
              8 -> ulPortSetInterruptMask
              8 -> uxListRemove
              8 -> vPortYield
              8 -> xTaskResumeAll
       16  vTaskDelete
              0 -> prvResetNextTaskUnblockTime
             16 -> ulPortSetInterruptMask
             16 -> uxListRemove
             16 -> vListInsertEnd
             16 -> vPortEnterCritical
             16 -> vPortExitCritical
              0 -> vPortYield
        8  vTaskEndScheduler
              8 -> ulPortSetInterruptMask
              0 -> vPortEndScheduler
        0  vTaskMissedYield
       16  vTaskPlaceOnEventList
              0 -> prvAddCurrentTaskToDelayedList
             16 -> ulPortSetInterruptMask
             16 -> uxListRemove
             16 -> vListInsert
              0 -> vListInsertEnd
       16  vTaskPlaceOnEventListRestricted
              0 -> prvAddCurrentTaskToDelayedList
             16 -> ulPortSetInterruptMask
             16 -> uxListRemove
             16 -> vListInsertEnd
       16  vTaskPlaceOnUnorderedEventList
              0 -> prvAddCurrentTaskToDelayedList
             16 -> ulPortSetInterruptMask
             16 -> uxListRemove
              0 -> vListInsertEnd
             16 -> vListInsertEnd
        8  vTaskPriorityDisinherit
              8 -> uxListRemove
              0 -> vListInsertEnd
       16  vTaskPriorityInherit
             16 -> uxListRemove
              0 -> vListInsertEnd
       24  vTaskPrioritySet
             24 -> ulPortSetInterruptMask
             24 -> uxListRemove
             24 -> vListInsertEnd
             24 -> vPortEnterCritical
              0 -> vPortExitCritical
             24 -> vPortYield
       16  vTaskResume
             16 -> ulPortSetInterruptMask
             16 -> uxListRemove
             16 -> vListInsertEnd
             16 -> vPortEnterCritical
              0 -> vPortExitCritical
             16 -> vPortYield
             16 -> xTaskIsTaskSuspended
        8  vTaskSetTimeOutState
              8 -> ulPortSetInterruptMask
       24  vTaskStartScheduler
             24 -> ulPortSetInterruptMask
              0 -> xPortStartScheduler
             24 -> xTaskGenericCreate
             24 -> xTimerCreateTimerTask
       16  vTaskSuspend
             16 -> prvResetNextTaskUnblockTime
             16 -> ulPortSetInterruptMask
             16 -> uxListRemove
             16 -> vListInsertEnd
             16 -> vPortEnterCritical
             16 -> vPortExitCritical
              0 -> vPortYield
             16 -> vTaskSwitchContext
        0  vTaskSuspendAll
        8  vTaskSwitchContext
              8 -> ulPortSetInterruptMask
       16  xTaskCheckForTimeOut
             16 -> ulPortSetInterruptMask
             16 -> vPortEnterCritical
             16 -> vPortExitCritical
             16 -> vTaskSetTimeOutState
       40  xTaskGenericCreate
             40 -> pvPortMalloc
             40 -> pxPortInitialiseStack
             40 -> ulPortSetInterruptMask
             40 -> vListInitialise
             40 -> vListInitialiseItem
             40 -> vListInsertEnd
             40 -> vPortEnterCritical
             40 -> vPortExitCritical
             40 -> vPortFree
             40 -> vPortYield
        0  xTaskGetCurrentTaskHandle
        0  xTaskGetSchedulerState
        8  xTaskGetTickCount
              8 -> vPortEnterCritical
              8 -> vPortExitCritical
        8  xTaskGetTickCountFromISR
              8 -> ulPortSetInterruptMask
              8 -> vPortClearInterruptMask
              8 -> vPortValidateInterruptPriority
       32  xTaskIncrementTick
             32 -> prvResetNextTaskUnblockTime
             32 -> ulPortSetInterruptMask
             32 -> uxListRemove
             32 -> vListInsertEnd
        8  xTaskIsTaskSuspended
              8 -> ulPortSetInterruptMask
       16  xTaskRemoveFromEventList
             16 -> ulPortSetInterruptMask
             16 -> uxListRemove
             16 -> vListInsertEnd
       24  xTaskRemoveFromUnorderedEventList
             24 -> ulPortSetInterruptMask
             24 -> uxListRemove
             24 -> vListInsertEnd
       24  xTaskResumeAll
             24 -> ulPortSetInterruptMask
             24 -> uxListRemove
             24 -> vListInsertEnd
             24 -> vPortEnterCritical
             24 -> vPortExitCritical
             24 -> vPortYield
             24 -> xTaskIncrementTick
       24  xTaskResumeFromISR
             24 -> ulPortSetInterruptMask
             24 -> uxListRemove
             24 -> vListInsertEnd
             24 -> vPortClearInterruptMask
             24 -> vPortValidateInterruptPriority
             24 -> xTaskIsTaskSuspended


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "IDLE">
       4  ??DataTable35
       4  ??DataTable35_1
      18  ?Subroutine0
       8  ?Subroutine1
      14  ?Subroutine10
      10  ?Subroutine2
      14  ?Subroutine3
       6  ?Subroutine4
       6  ?Subroutine5
      10  ?Subroutine6
       8  ?Subroutine7
      14  ?Subroutine8
       6  ?Subroutine9
      50  prvAddCurrentTaskToDelayedList
      88  prvIdleTask
      26  prvResetNextTaskUnblockTime
     128  pxCurrentTCB
          pxReadyTasksLists
          uxTopReadyPriority
       8  uxTaskGetNumberOfTasks
      20  uxTaskPriorityGet
      20  uxTaskResetEventItemValue
      54  vTaskDelay
      94  vTaskDelayUntil
      74  vTaskDelete
      22  vTaskEndScheduler
       8  vTaskMissedYield
      40  vTaskPlaceOnEventList
      32  vTaskPlaceOnEventListRestricted
      48  vTaskPlaceOnUnorderedEventList
      62  vTaskPriorityDisinherit
      88  vTaskPriorityInherit
     138  vTaskPrioritySet
      88  vTaskResume
      22  vTaskSetTimeOutState
      82  vTaskStartScheduler
      90  vTaskSuspend
      12  vTaskSuspendAll
      88  vTaskSwitchContext
     148  xPendingReadyList
          xTasksWaitingTermination
          pxDelayedTaskList
          pxOverflowDelayedTaskList
          uxTasksDeleted
          xSuspendedTaskList
          uxCurrentNumberOfTasks
          xTickCount
          xSchedulerRunning
          uxSchedulerSuspended
          uxPendedTicks
          xYieldPending
          xNumOfOverflows
          uxTaskNumber
          xNextTaskUnblockTime
          xDelayedTaskList1
          xDelayedTaskList2
      84  xTaskCheckForTimeOut
     348  xTaskGenericCreate
       6  xTaskGetCurrentTaskHandle
      22  xTaskGetSchedulerState
      12  xTaskGetTickCount
      24  xTaskGetTickCountFromISR
     192  xTaskIncrementTick
      40  xTaskIsTaskSuspended
      78  xTaskRemoveFromEventList
      80  xTaskRemoveFromUnorderedEventList
     156  xTaskResumeAll
     102  xTaskResumeFromISR

 
   128 bytes in section .bss
   148 bytes in section .data
 2 528 bytes in section .text
 
 2 528 bytes of CODE memory
   276 bytes of DATA memory

Errors: none
Warnings: none

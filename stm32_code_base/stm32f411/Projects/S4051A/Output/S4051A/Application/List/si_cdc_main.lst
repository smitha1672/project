###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     11/Nov/2014  19:24:05 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\sii953x\component\cdc\si_cdc_ma #
#                    in.c                                                     #
#    Command line =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Libraries\AMT_Drivers\sii953x\component\cdc\si_cdc_ma #
#                    in.c -D S4051A -D DEBUG -D FREE_RTOS -D STM32F40_41xxx   #
#                    -D USE_STM324xG_EVAL -D USE_STDPERIPH_DRIVER -D          #
#                    __ARM_CORTEX_MX__ -D IAR_ARM_CM4F -D USE_USB_OTG_FS      #
#                    -lcN C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Applicati #
#                    on\List\ -o C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\Output\S4051A\Ap #
#                    plication\Obj\ --debug --endian=little --cpu=Cortex-M4   #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\inc\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\Include\ -I          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\ -I         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\inc\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\USB_HD\ #
#                    src\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2 #
#                    \DevCode\2\Projects\S4051A\EWARM\..\App_SRC\SERVICES\wav #
#                    ePlayer\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\App_SRC\Managers #
#                    \ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\De #
#                    vCode\2\Projects\S4051A\EWARM\..\App_SRC\Dispatchers\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMSIS\Inc #
#                    lude\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K #
#                    2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\CMS #
#                    IS\Device\ST\STM32F4xx\Include\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32F4xx_St #
#                    dPeriph_Driver\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\FreeRTOS\Source\portable\IAR\ARM_CM4F\ -I     #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\FreeRTOS\Sou #
#                    rce\include\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librar #
#                    ies\FreeRTOS\Source\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\STM32_USB_OTG_Driver\inc\ -I                 #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB_De #
#                    vice_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\STM32_USB #
#                    _HOST_Library\Core\inc\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\Third_Party\ #
#                    efsl\inc\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\ #
#                    15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilities #
#                    \Third_Party\fat_fs\inc\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Utilities\mainstream_v #
#                    1\stm32f411\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projec #
#                    ts\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Utilit #
#                    ies\mainstream_v1\stm32f411\it\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    EXT_FLASH\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects #
#                    \15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Librarie #
#                    s\AMT_Drivers\TAS5727\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\TAS5711\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    TAS5707\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\TAS5713\ -I C:\Users\tony.tsou\Desktop\AmTRA #
#                    N\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\. #
#                    .\Libraries\AMT_Drivers\CS49844\ -I                      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    CS8422\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15 #
#                    _K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\A #
#                    MT_Drivers\CS5346\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\OTI3368\ -I                        #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    HT68F30\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\1 #
#                    5_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Libraries\ #
#                    AMT_Drivers\BTM640\ -I C:\Users\tony.tsou\Desktop\AmTRAN #
#                    \Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\.. #
#                    \Libraries\AMT_Drivers\sii953x\application\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_ipv\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cbus\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cdc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_cec\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_arc\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_diag\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_msw\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\application\app_osd\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ -I C:\Users\tony.tsou\Desktop\AmTRAN\ #
#                    Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\ #
#                    Libraries\AMT_Drivers\sii953x\component\tx\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\repeater_avr\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\video_tables\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\audio_rx\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\edid_tx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\debugger_hdmigear\ -I                  #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cbus\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\component\rtpi\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cdc\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\cec_manager\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\component\thx\ -I                            #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\ipv\ -I C:\Users\tony.tsou\Desktop\AmT #
#                    RAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\.. #
#                    \..\Libraries\AMT_Drivers\sii953x\component\osd\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_switch\ -I                         #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\component\cec_system_audio_control\ -I           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\ -I C:\Users\tony.tsou\Desktop\AmTRAN\Pro #
#                    jects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\..\..\Lib #
#                    raries\AMT_Drivers\sii953x\driver\audio_mix_drv\ -I      #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\sii953x_drv\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cra_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\matrix_sw_drv\ #
#                     -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\Dev #
#                    Code\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Driv #
#                    ers\sii953x\driver\nvram_sram_drv\ -I                    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\audio_rx_drv\  #
#                    -I C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevC #
#                    ode\2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drive #
#                    rs\sii953x\driver\repeater_avr_drv\ -I                   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\gpio_drv\ -I                              #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\tpg_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\cbus_drv\ -I   #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\cpi_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\arc_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\driver\osd_drv\ -I C:\Users\tony.tsou\Desktop\Am #
#                    TRAN\Projects\15_K2\DevCode\2\Projects\S4051A\EWARM\..\. #
#                    .\..\Libraries\AMT_Drivers\sii953x\driver\ipv_drv\ -I    #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\ir_remote\ -I                       #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\eeprom\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\timer\ -I                           #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\hal\i2c\ -I                             #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\osal\timer\ -I                          #
#                    C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\..\..\Libraries\AMT_Drivers\ #
#                    sii953x\platform\board\ -Ohz -I "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Li #
#                    st\si_cdc_main.lst                                       #
#    Object file  =  C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode #
#                    \2\Projects\S4051A\EWARM\..\Output\S4051A\Application\Ob #
#                    j\si_cdc_main.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\tony.tsou\Desktop\AmTRAN\Projects\15_K2\DevCode\2\Libraries\AMT_Drivers\sii953x\component\cdc\si_cdc_main.c
      1          //************************************************************************************************
      2          //! @file     si_cdc_main.c
      3          //! @brief    Top level CDC API
      4          //
      5          //
      6          // No part of this work may be reproduced, modified, distributed,
      7          // transmitted, transcribed, or translated into any language or computer
      8          // format, in any form or by any means without written permission of
      9          // Silicon Image, Inc., 1060 East Arques Avenue, Sunnyvale, California 94085
     10          //
     11          // Copyright 2010, Silicon Image, Inc.  All rights reserved.
     12          //************************************************************************************************/
     13          
     14          #include "si_common.h"
     15          #include "si_cdc_component.h"
     16          #include "si_cdc_internal.h"
     17          
     18          #ifndef CDC_PC_SIMULATION
     19          #include <string.h>    
     20          #else
     21          #include "stdio.h"
     22          #include "memory.h"
     23          #include "debug_print.h"
     24          #endif
     25          
     26          
     27          //-------------------------------------------------------------------------------------------------
     28          // Global Data
     29          //-------------------------------------------------------------------------------------------------
     30          
     31          #ifdef CDC_PC_SIMULATION
     32          uint8_t  g_halMsgLevel = CDC_MSG_DBG;
     33          #endif
     34          
     35          //-------------------------------------------------------------------------------------------------
     36          // Local Service Function Prototypes
     37          //-------------------------------------------------------------------------------------------------
     38          
     39          static void CdcAliveTimerSet(uint8_t minTimeSec, uint8_t maxTimeSec);
     40          static void CdcLostDeviceDisconnect(uint16_t physAddr);
     41          
     42          
     43          //-------------------------------------------------------------------------------------------------
     44          // Top Level API Functions
     45          //-------------------------------------------------------------------------------------------------
     46          
     47          
     48          
     49          //-------------------------------------------------------------------------------------------------
     50          //! @brief      Initialize the Instance Record and fills its fields related to
     51          //!             device capabilities and non-volatile configuration.
     52          //!
     53          //!             Alternatively, the Instance Record can be addressed and set
     54          //!             directly.
     55          //!
     56          //! @param[in]  physAddr - physical address of this device,
     57          //! @param[in]  pIoPorts - pointer to I/O configuration structure,
     58          //! @param[in]  hecCapability  - true if the device supports HEC functionality
     59          //! @param[in]  hostCapability - true if the device can be a special service provider (host)
     60          //! @param[in]  extNetCapability - true if the device has external network connection
     61          //-------------------------------------------------------------------------------------------------
     62          
     63          void SiiCdcConfig(uint16_t physAddr, CdcIoConfig_t *pIoPorts,  
     64                         bool_t hecCapability, bool_t hostCapability, bool_t extNetCapability)
     65          {
     66              CdcHecInstanceRecordReset(); // Initialize all Instance Record fields and free all allocated memory
     67          
     68              pCdc->physAddr = physAddr;                             // set PA of this device
     69              memcpy(&pCdc->ports, pIoPorts, sizeof(CdcIoConfig_t)); // set device I/O configuration
     70          
     71              pCdc->deviceStatus.hecFuncState = hecCapability ? CDC_HEC_STATE_INACTIVE : CDC_HEC_FUNC_NOT_SUPPORTED;
     72              pCdc->deviceStatus.hostFuncState= hostCapability ? CDC_HOST_STATE_INACTIVE : CDC_HOST_NOT_SUPPORTED;
     73              pCdc->deviceStatus.encFuncState = extNetCapability ? CDC_ENC_STATE_INACTIVE : CDC_ENC_NOT_SUPPORTED;
     74          
     75              // Broadcast "Capability Notification" message
     76              CdcHecReportStateSend(0xFFFF, CDC_REPORT_STATE_SHORT_MODE);
     77              CdcDiscoveryDataArrange(); // update discovered and reachable device list
     78          }
     79          
     80          
     81          //-------------------------------------------------------------------------------------------------
     82          //! @brief      Enables or Disables HEC Support function of this Device
     83          //!
     84          //! @param[in]  isEnabled - true enables HEC support capability
     85          //-------------------------------------------------------------------------------------------------
     86          
     87          void SiiCdcDeviceHecSupEnable(const bool_t isEnabled)
     88          {
     89              uint8_t oldState = pCdc->deviceStatus.hecFuncState;
     90          
     91              if (isEnabled && (oldState == CDC_HEC_FUNC_NOT_SUPPORTED))
     92              {
     93                  pCdc->deviceStatus.hecFuncState = CDC_HEC_STATE_INACTIVE;       
     94                  // don't change HEC state if already enabled (either Inactive or Active)
     95              }
     96              else if (!isEnabled)
     97              {
     98                  SiiCdcDeviceDisconnect(true,0,0,0); // disconnect all active HECs
     99                  pCdc->deviceStatus.hecFuncState = CDC_HEC_FUNC_NOT_SUPPORTED;        
    100              }
    101          
    102              if (pCdc->deviceStatus.hecFuncState != oldState)
    103              {
    104                  // Broadcast "Capability Notification" message
    105                  // only if the state has been changed
    106                  CdcHecReportStateSend(0xFFFF, 0);
    107                  CdcDiscoveryDataArrange(); // update discovered and reachable device list        
    108              }
    109          }
    110          
    111          
    112          //-------------------------------------------------------------------------------------------------
    113          //! @brief      Sets new Host Capability state of this Device
    114          //!
    115          //! @param[in]  state - new Host capability state
    116          //-------------------------------------------------------------------------------------------------
    117          
    118          void SiiCdcDeviceHostStateSet(const CdcHostFuncState_t state)
    119          {
    120          
    121              if (pCdc->deviceStatus.hostFuncState != state)
    122              {
    123                  pCdc->deviceStatus.hostFuncState = state;
    124                  // Broadcast "Capability Notification" message
    125                  // only if the state has been changed
    126                  CdcHecReportStateSend(0xFFFF, 0);           
    127                  CdcDiscoveryDataArrange(); // update discovered and reachable device list
    128              }
    129          }
    130          
    131          
    132          //-------------------------------------------------------------------------------------------------
    133          //! @brief      Sets new External Network Capability state of this Device
    134          //!
    135          //! @param[in]  state - new External Network capability state
    136          //-------------------------------------------------------------------------------------------------
    137          
    138          void SiiCdcDeviceEncStateSet(const CdcEncFuncState_t state)
    139          {
    140          
    141              if (pCdc->deviceStatus.encFuncState != state)
    142              {
    143                  pCdc->deviceStatus.encFuncState = state;
    144                  // Broadcast "Capability Notification" message
    145                  // only if the state has been changed
    146                  CdcHecReportStateSend(0xFFFF, 0); 
    147                  CdcDiscoveryDataArrange(); // update discovered and reachable device list
    148              }
    149          }
    150          
    151          
    152          //-------------------------------------------------------------------------------------------------
    153          //! @brief      Enables or Disables HEC Support function on I/O ports
    154          //!
    155          //! @param[in]  isOutput       - true, if output port is addressed
    156          //! @param[in]  inputPortIndex - input port index (zero-based)
    157          //! @param[in]  isEnabled      - boolean flag
    158          //-------------------------------------------------------------------------------------------------
    159          
    160          void SiiCdcPortHecSupEnable(const bool_t isOutput, const uint8_t inputPortIndex, const bool_t isEnabled)
    161          {
    162              bool_t    isChanged = false;
    163              uint16_t  physAddr;
    164          
    165              if ((isOutput == true) && (pCdc->ports.numberOfOutputs != 0))
    166              {
    167                  if (pCdc->ports.output.hecSupport != isEnabled)
    168                  {
    169                      // before disabling output, deactivate affected AHECs
    170                      if (!isEnabled) 
    171                      {
    172                          physAddr = CdcAdjacentPhysAddrGet(pCdc->physAddr, true, 0);
    173                          if (physAddr != 0xFFFF)
    174                          {
    175                              CdcLostDeviceDisconnect(physAddr);
    176                          }
    177                      }
    178                      
    179                      pCdc->ports.output.hecSupport = isEnabled;
    180                      isChanged = true;
    181                  }
    182              }
    183              else if ((isOutput == false) && (pCdc->ports.numberOfInputs > inputPortIndex)) // inputs
    184              {
    185                  if (pCdc->ports.input[inputPortIndex].hecSupport != isEnabled)
    186                  {
    187                      // before disabling input, deactivate affected AHECs
    188                      if (!isEnabled) 
    189                      {
    190                          physAddr = CdcAdjacentPhysAddrGet(pCdc->physAddr, false, inputPortIndex);
    191                          if (physAddr != 0xFFFF)
    192                          {
    193                              CdcLostDeviceDisconnect(physAddr);
    194                          }
    195                      }
    196                      
    197                      pCdc->ports.input[inputPortIndex].hecSupport = isEnabled;
    198                      isChanged = true;
    199                  }
    200              }
    201              
    202              if (isChanged)
    203              {
    204                  // Broadcast "Capability Notification" message
    205                  // only if the state has been changed
    206                  CdcHecReportStateSend(0xFFFF, 0);          
    207                  CdcDiscoveryDataArrange(); // update discovered and reachable device list
    208              }
    209          }
    210            
    211              
    212          //-------------------------------------------------------------------------------------------------
    213          //! @brief      Resets all tasks
    214          //-------------------------------------------------------------------------------------------------
    215          
    216          void SiiCdcTaskInit(void)
    217          {        
    218              pCdc->cdcTaskFlags = 0;
    219              pCdc->cdcTaskMask = CDC_TASK_MASK_ALL_UNMASKED; // all tasks are unmasked by default
    220          
    221              // Reset time counters
    222              CdcTimeCounterReset(&pCdc->cdcTaskTimeCount);
    223              CdcTimeCounterReset(&pCdc->aliveNtfDelayCount);
    224              CdcTimeCounterReset(&pCdc->cdcDiscoveryTimeCount);
    225              
    226          
    227              // Reset task states
    228              pCdc->cdcTaskState = CDC_TASK_EMPTY_STATE_NONE;     
    229          
    230              Mrand(pCdc->physAddr); // seed the random numbers generator
    231          
    232              pCdc->sysTimerCountCurMs = 0;
    233              pCdc->sysTimerCountPrvMs = 0;
    234          }
    235          
    236          
    237          //-------------------------------------------------------------------------------------------------
    238          //! @brief      Sets random initial delay time
    239          //!
    240          //! @param[in]  minTimeSec - lower boundary of a time (in seconds)
    241          //! @param[in]  maxTimeSec - upper boundary of a time (in seconds)
    242          //-------------------------------------------------------------------------------------------------
    243          
    244          static void CdcAliveTimerSet(uint8_t minTimeSec, uint8_t maxTimeSec)
    245          {
    246              if (minTimeSec <= maxTimeSec)
    247              {
    248                  // Initial delay of AliveNotification messages (Tmin...Tmax randomly chosen)
    249                  CdcTimeCounterSet(CDC_TIME_SEC2TCK(minTimeSec + Mrand(0) % (maxTimeSec - minTimeSec + 1)), &pCdc->aliveNtfDelayCount);
    250              }
    251          }
    252          
    253          
    254          //-------------------------------------------------------------------------------------------------
    255          //! @brief      If no HEC devices, disable HEC hardware.
    256          //-------------------------------------------------------------------------------------------------
    257          
    258          static void CdcHecDisableCheck(void)
    259          {
    260              if (pCdc->numberOfHecs == 0) // not participating in any HEC
    261              {
    262                   // Deactivate HEC function
    263                   if (CdcEhdmiHwEnable(false))
    264                   {
    265                      if (pCdc->deviceStatus.hecFuncState != CDC_HEC_NOT_SUPPORTED)  
    266                      {
    267                          pCdc->deviceStatus.hecFuncState = CDC_HEC_STATE_INACTIVE; 
    268                      }
    269                   }
    270              } 
    271          }
    272          
    273          
    274          //-------------------------------------------------------------------------------------------------
    275          //! @brief      Auxiliary function for Base Service
    276          //!
    277          //!             Adds new device into Found Host List in response to CDCOP_HEC_REPORT_STATE message
    278          //!
    279          //! @param[in]  pCdcMessage         - pointer to CDC message structure
    280          //! @param[in]  initiatorPhysAddr   - physical address of the new device
    281          //-------------------------------------------------------------------------------------------------
    282          
    283          static void CdcHecAddNewDeviceToHostList(SiiCpiData_t *pCdcMessage, uint16_t initiatorPhysAddr)
    284          {
    285          
    286              if ((pCdc->numberOfAllHosts < CDC_NUMBER_OF_FOUND_HOSTS_MAX) &&        // There is space in the device list
    287                  (((pCdcMessage->args[5] >> 6) & 0x03) != CDC_HEC_FUNC_NOT_SUPPORTED) && // HEC function is available  
    288                  ((pCdcMessage->args[5] & 0x03) == CDC_ERRCODE_NO_ERROR)) // the ReportState has no indication of a error
    289              {
    290                  // add new device to the list
    291                  pCdc->cdcFoundHostsList[pCdc->numberOfAllHosts].physAddr = initiatorPhysAddr;
    292                  pCdc->cdcFoundHostsList[pCdc->numberOfAllHosts].hostInfo.portHecCapBits = 0x7FFF & ((pCdcMessage->args[6] << 8) | pCdcMessage->args[7]);
    293                  pCdc->cdcFoundHostsList[pCdc->numberOfAllHosts].devStat.hecFuncState  = ((pCdcMessage->args[5] >> 6) & 0x03);                                      
    294                  pCdc->cdcFoundHostsList[pCdc->numberOfAllHosts].devStat.hostFuncState = ((pCdcMessage->args[5] >> 4) & 0x03); 
    295                  pCdc->cdcFoundHostsList[pCdc->numberOfAllHosts].devStat.encFuncState  = ((pCdcMessage->args[5] >> 2) & 0x03);                                  
    296                  pCdc->cdcFoundHostsList[pCdc->numberOfAllHosts].devStat.cdcErrorState =  (pCdcMessage->args[5] & 0x03);                                      
    297          
    298                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Device PA = %04x added to found Hosts list\n", initiatorPhysAddr);
    299                  
    300                  pCdc->numberOfAllHosts++;
    301              }
    302          }
    303          
    304          
    305          //-------------------------------------------------------------------------------------------------
    306          //! @brief      Launch discovery process
    307          //!
    308          //!             When done, create a list of found devices
    309          //!
    310          //! @return     Feedback message to the caller (Task status or error reports)
    311          //-------------------------------------------------------------------------------------------------
    312          
    313          static uint8_t CdcTaskDiscover(void)
    314          {
    315              uint8_t cdcFeedbackMsg = CDC_FB_MSG_NONE;
    316              
    317              
    318              switch(pCdc->cdcTaskState)
    319              {
    320                  case CDC_TASK_EMPTY_STATE_NONE: // all tasks shall start from empty state
    321                          pCdc->cdcTaskMask = CDC_TASK_HOSTS_SEARCH; // mask out other tasks until this one is done
    322                          pCdc->cdcTaskState = CDC_TASK_FIND_STATE_DISCOVERY_START;
    323                       
    324                          // set Discovery repetition timer
    325                          CdcTimeCounterSet(CDC_TIME_SEC2TCK(CDC_MIN_DISCOVERY_REP_TIME_SEC), &pCdc->cdcDiscoveryTimeCount);
    326                          // don't break here to save time and go ahead to the fist step
    327                          
    328                  case CDC_TASK_FIND_STATE_DISCOVERY_START: // First stage: Sending out a discovery message
    329                          CdcHecDiscoverSend();
    330                          pCdc->numberOfFoundHosts = 0; // reset counter of found devices (ENC or Host capable)
    331                          pCdc->numberOfAllHosts = 0;   // reset counter of all found devices
    332                          pCdc->cdcTaskState = CDC_TASK_FIND_STATE_GATHER_RESPONSES; // next stage
    333                          DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_FIND]: Started gathering responses\n");
    334                          CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RESPONSE_TIME_MS), &pCdc->cdcTaskTimeCount);
    335                          CdcTimeCounterSet(CDC_TIME_SEC2TCK(CDC_MAX_MONITORING_TIME_SEC), &pCdc->cdcTotalMonTimeCount);
    336                          break;
    337                  
    338                  case CDC_TASK_FIND_STATE_GATHER_RESPONSES: // Stage: collect responses from all devices
    339                          // wait until all devices respond
    340                          // criteria: timeout since the last response
    341              
    342                          // Set recall timer to maximum in order to allow the task counters to set it to a new value
    343                          CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);
    344                          
    345                          CdcTimeCounterUpdate(&pCdc->cdcTaskTimeCount);
    346                          CdcTimeCounterUpdate(&pCdc->cdcTotalMonTimeCount);
    347                          if (CdcIsTimeCounterExpired(&pCdc->cdcTaskTimeCount) || CdcIsTimeCounterExpired(&pCdc->cdcTotalMonTimeCount))
    348                          {   // if timer expired
    349                              pCdc->cdcTaskState = CDC_TASK_FIND_STATE_REPORT_RESULTS;  // next stage
    350                              DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_FIND]: Stopped gathering responses\n");
    351                          }
    352                          break;
    353              
    354                  case CDC_TASK_FIND_STATE_REPORT_RESULTS: // Last stage
    355                          // Identify all found HOST or ENC capable devices that aren't reachable from this device
    356                          // then cleanup and rearrange the list to leave only capable & reachable devices
    357                          CdcDiscoveryDataArrange();
    358              
    359                          // event message to the caller
    360                          cdcFeedbackMsg = CDC_FB_MSG_HST_SEARCH_DONE;
    361                          pCdc->cdcTaskFlags &= ~CDC_TASK_HOSTS_SEARCH; // stop the task
    362                          pCdc->cdcTaskState = CDC_TASK_EMPTY_STATE_NONE;  // reset stage                    
    363                          pCdc->cdcTaskMask = CDC_TASK_MASK_ALL_UNMASKED;  // reset task mask as this task is done
    364                          break;
    365              
    366                  default:
    367          				 break;
    368              }
    369          
    370              return  cdcFeedbackMsg;
    371          }
    372          
    373          
    374          //-------------------------------------------------------------------------------------------------
    375          //! @brief      Activate one or more HECs
    376          //!
    377          //!             Sends InquireState message to all PHECs and
    378          //!             checks if the PHECs have responded, then update PHECs status
    379          //!             to VHEC. Initiate activation of all VHECs and check if the
    380          //!             VHECs have responded, then update VHECs status to AHEC
    381          //!
    382          //! @return     Feedback message to the caller (Task status or error reports)
    383          //-------------------------------------------------------------------------------------------------
    384          
    385          static uint8_t CdcTaskConnect(void)
    386          {
    387              uint8_t     cdcFeedbackMsg = CDC_FB_MSG_NONE;
    388              uint16_t    firstPhysAddr;
    389              uint16_t    lastPhysAddr;
    390              bool_t      tmpCond;
    391              uint8_t     activatorExcludeFactor;
    392              uint8_t     i;
    393          
    394              switch(pCdc->cdcTaskState)
    395              {
    396                  case CDC_TASK_EMPTY_STATE_NONE: // all tasks shall start from empty state
    397                          pCdc->cdcTaskMask = CDC_TASK_CONNECT; // mask out other tasks until this one is done
    398                          pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_INIT;
    399                          // don't break here to save time and go ahead to the fist step
    400                  
    401                  case CDC_TASK_CONNECT_STATE_INIT:
    402                          pCdc->currentHecIdx = 0;   // initialize HEC index
    403                          pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_INQUIRE_START; // next stage
    404                          pCdc->connectSettings.hecActDelayed = 0;   // reset number of delayed multi-HEC SetState messages
    405                          pCdc->connectSettings.isEndOfList = false; // reset End of VHEC List flag
    406                          //break;
    407                          
    408                  case CDC_TASK_CONNECT_STATE_INQUIRE_START: // First stage: Sending out InquireState messages for PHECs
    409                          // find first PHEC in the HEC records and start activation of it
    410                          while (pCdc->currentHecIdx < CDC_NUMBER_OF_HECS_MAX)
    411                          {
    412                              if ((pCdc->aHec[pCdc->currentHecIdx].status.isInUse == true) && 
    413                                  (pCdc->aHec[pCdc->currentHecIdx].status.channelState == CDC_PHEC))
    414                              {
    415                                  // Found a PHEC; begin activation process. Increment the current HEC index when done
    416                                  CdcHecInquireStateSend(pCdc->currentHecIdx);
    417                                  CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RESPONSE_TIME_MS), &pCdc->cdcTaskTimeCount);                            
    418                                  CdcTimeCounterSet(CDC_TIME_SEC2TCK(CDC_MAX_MONITORING_TIME_SEC), &pCdc->cdcTotalMonTimeCount);
    419                                  pCdc->verifiedDevNum[0] = 0; // reset counter of verified devices
    420                                  pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_GATHER_INQ_REP; // next stage
    421                                  break; 
    422                              }
    423                              pCdc->currentHecIdx++;
    424                          }
    425                   
    426                          if (pCdc->cdcTaskState == CDC_TASK_CONNECT_STATE_GATHER_INQ_REP) // if found new PHEC
    427                          {                        
    428                              DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: Started gathering responses for PHEC %d\n", (int) pCdc->currentHecIdx);
    429                          }
    430                          else // no new PHEC was found
    431                          {
    432          
    433                              if (pCdc->connectSettings.isMultHecMode && (pCdc->connectSettings.hecActDelayed > 0))
    434                              {
    435                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: End of PHEC list found\n");
    436                                  pCdc->connectSettings.isEndOfList = true;
    437                                  pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_ACTIVATE_START; // send last activation command                            
    438                              }
    439                              else // single HEC activation mode
    440                              {
    441                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: No new PHEC found. Task finished\n");
    442                                  pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_REPORT_RESULTS; // stop the task                            
    443                              }
    444                          }
    445                          break;
    446          
    447                  case CDC_TASK_CONNECT_STATE_GATHER_INQ_REP:
    448                          // wait until all devices respond
    449                          // criteria: timeout since the last response or arrival of the last verified report 
    450          
    451                          // Set recall timer to maximum in order to allow the task counters to set it to a new value
    452                          CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);
    453          
    454                          CdcTimeCounterUpdate(&pCdc->cdcTaskTimeCount);
    455                          CdcTimeCounterUpdate(&pCdc->cdcTotalMonTimeCount);
    456                          
    457                          firstPhysAddr = pCdc->aHec[pCdc->currentHecIdx].firstDevPhysAddr;
    458                          lastPhysAddr  = pCdc->aHec[pCdc->currentHecIdx].lastDevPhysAddr; 
    459                          
    460                          // Exclude activator (this device) from the HEC lengh formula, if it's a part of the HEC
    461                          activatorExcludeFactor = CdcIsDeviceBelongsToHec(firstPhysAddr, lastPhysAddr, pCdc->physAddr) ? 1 : 0;
    462          
    463                          tmpCond = (pCdc->verifiedDevNum[0] == (CdcHecLengthGet(firstPhysAddr, lastPhysAddr) - activatorExcludeFactor)); // "-1" means activator exclusion
    464                          if (CdcIsTimeCounterExpired(&pCdc->cdcTaskTimeCount) || CdcIsTimeCounterExpired(&pCdc->cdcTotalMonTimeCount) || tmpCond)
    465                          {   // if timer expired or all device responses have been collected
    466                              DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: Stopped gathering InquireState responses\n");
    467                              
    468                              if (tmpCond)
    469                              {
    470                                  pCdc->aHec[pCdc->currentHecIdx].status.channelState = CDC_VHEC;
    471                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: HEC %d status has changed to VHEC.\n", (int) pCdc->currentHecIdx);
    472                               
    473                                  pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_ACTIVATE_START; // next stage
    474                              }
    475                              else
    476                              {
    477                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: PHEC %d wasn't verified. Removed.\n", (int) pCdc->currentHecIdx);
    478                                  // Remove the failed PHEC
    479                                  CdcHecDescriptorRemove(pCdc->currentHecIdx);
    480                                  pCdc->currentHecIdx++; // step to next HEC
    481                                  pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_INQUIRE_START; // move to another PHEC search                        
    482                              }
    483          
    484                              // minimize the time of the next call
    485                              CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MIN_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);
    486                          }
    487                          break;
    488          
    489                  case CDC_TASK_CONNECT_STATE_ACTIVATE_START:
    490                          if (pCdc->connectSettings.isMultHecMode)
    491                          {
    492                              // Issue multi-HEC activation command, if there are 4 HECs to activate or the End of HEC list is reached
    493                              if ((pCdc->connectSettings.hecActDelayed >= 3) || (pCdc->connectSettings.isEndOfList))
    494                              {
    495                                  if (!pCdc->connectSettings.isEndOfList) // new HEC has to be added
    496                                  {
    497                                      pCdc->delayedHecIdx[pCdc->connectSettings.hecActDelayed++] = pCdc->currentHecIdx; // put current HEC into the list
    498                                  }
    499          
    500                                  if (pCdc->connectSettings.hecActDelayed > 0)
    501                                  {
    502                                      CdcHecSetStateSend(CDC_HEC_ACTIVE, pCdc->connectSettings.hecActDelayed, pCdc->delayedHecIdx);
    503                                      DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: Started gathering responses for VHECs in multi-HEC mode\n");
    504                                  }
    505                              }
    506                              else // delay the activation, memorize delayed HEC index
    507                              {
    508                                  pCdc->delayedHecIdx[pCdc->connectSettings.hecActDelayed] = pCdc->currentHecIdx++;
    509                                  pCdc->connectSettings.hecActDelayed++;
    510                                  pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_INQUIRE_START; // move to another PHEC search 
    511                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: Activation delayed for %d VHECs\n", (int) pCdc->connectSettings.hecActDelayed);
    512                                  break;
    513                              }
    514                          }
    515                          else
    516                          {
    517                              // Issue single-HEC activation command
    518                              CdcHecSetStateSend(CDC_HEC_ACTIVE, 1, &pCdc->currentHecIdx);
    519                              DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: Started gathering responses for VHEC %d\n", (int) pCdc->currentHecIdx);
    520                          }
    521                          
    522                          CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RESPONSE_TIME_MS), &pCdc->cdcTaskTimeCount);                   
    523                          CdcTimeCounterSet(CDC_TIME_SEC2TCK(CDC_MAX_MONITORING_TIME_SEC), &pCdc->cdcTotalMonTimeCount);
    524                          
    525                          for (i = 0; i < 4; i++)
    526                          {
    527                              pCdc->verifiedDevNum[i] = 0; // reset counters of verified devices
    528                          }
    529                          pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_GATHER_ACT_REP; // next stage
    530                          break;
    531                          
    532                  case CDC_TASK_CONNECT_STATE_GATHER_ACT_REP:
    533                          // wait until all devices respond
    534                          // criteria: timeout since the last response or arrival of the last verified report 
    535          
    536                          // Set recall timer to maximum in order to allow the task counters to set it to a new value
    537                          CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);
    538                          
    539                          CdcTimeCounterUpdate(&pCdc->cdcTaskTimeCount);                    
    540                          CdcTimeCounterUpdate(&pCdc->cdcTotalMonTimeCount);
    541          
    542                          if (pCdc->connectSettings.isMultHecMode)
    543                          {
    544                              tmpCond = false;
    545                              for (i = 0; i < pCdc->connectSettings.hecActDelayed; i++)
    546                              {
    547                                  // Exclude activator (this device) from the HEC length formula, if it's a part of the HEC
    548                                  activatorExcludeFactor = CdcIsDeviceBelongsToHec(pCdc->aHec[pCdc->delayedHecIdx[i]].firstDevPhysAddr, 
    549                                                                                   pCdc->aHec[pCdc->delayedHecIdx[i]].lastDevPhysAddr, 
    550                                                                                   pCdc->physAddr) ? 1 : 0;                        
    551          
    552                                  tmpCond &= (pCdc->verifiedDevNum[i] == 
    553                                              (CdcHecLengthGet(pCdc->aHec[pCdc->delayedHecIdx[i]].firstDevPhysAddr, 
    554                                                               pCdc->aHec[pCdc->delayedHecIdx[i]].lastDevPhysAddr) - activatorExcludeFactor));// "-1" means activator exclusion
    555                              }
    556          
    557                              if (CdcIsTimeCounterExpired(&pCdc->cdcTaskTimeCount) || CdcIsTimeCounterExpired(&pCdc->cdcTotalMonTimeCount) || tmpCond)
    558                              {
    559                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: Stopped gathering Activation responses in Multi-HEC mode\n");
    560                                  
    561                                  // Change current HEC status to AHEC if all devices in the HEC are verified to be active
    562                                  // do it for all HECs in the list
    563                                  for (i = 0; i < pCdc->connectSettings.hecActDelayed; i++)
    564                                  {
    565                                      // Exclude activator (this device) from the HEC lengh formula, if it's a part of the HEC
    566                                      activatorExcludeFactor = CdcIsDeviceBelongsToHec(pCdc->aHec[pCdc->delayedHecIdx[i]].firstDevPhysAddr, 
    567                                                                                       pCdc->aHec[pCdc->delayedHecIdx[i]].lastDevPhysAddr, 
    568                                                                                       pCdc->physAddr) ? 1 : 0;                        
    569                                      
    570                                      tmpCond = (pCdc->verifiedDevNum[i] == 
    571                                                 (CdcHecLengthGet(pCdc->aHec[pCdc->delayedHecIdx[i]].firstDevPhysAddr, 
    572                                                                  pCdc->aHec[pCdc->delayedHecIdx[i]].lastDevPhysAddr) - activatorExcludeFactor));// "-1" means activator exclusion
    573                                      if (tmpCond) // all devices in this HEC have responded positively
    574                                      {
    575                                          bool_t isHwEnabledOk = true;
    576                                          
    577                                          // Activate eHDMI function
    578                                          if (pCdc->deviceStatus.hecFuncState < CDC_HEC_STATE_ACTIVE)
    579                                          {
    580                                              isHwEnabledOk = CdcEhdmiHwEnable(true);
    581                                              if (isHwEnabledOk)
    582                                              {
    583                                                  pCdc->deviceStatus.hecFuncState = CDC_HEC_STATE_ACTIVE;
    584                                                  CdcAliveTimerSet(10, 50); // start first AliveNotification message in 10-50 seconds
    585                                              }
    586                                          }
    587                                          
    588                                          if (isHwEnabledOk)
    589                                          {
    590                                              CdcAliveDeviceListAdd(pCdc->delayedHecIdx[i]); // add HEC devices (but Activator) to the Alive List
    591                                              pCdc->aHec[pCdc->delayedHecIdx[i]].status.channelState = CDC_AHEC;
    592                                              DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: HEC %d status has changed to AHEC.\n", (int) pCdc->delayedHecIdx[i]);
    593                                              pCdc->delayedHecIdx[i] = 0xFF; // mark as empty
    594                                          }
    595                                          
    596                                      }
    597                                      else
    598                                      {
    599                                          DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: VHEC %d wasn't activated. Will be deactivated.\n", (int) pCdc->delayedHecIdx[i]);
    600                                          // Leave values pCdc->delayedHecIdx[i] of failed HECs intact
    601                                          // to be used on clean-up stage
    602                                      }
    603                                  }
    604          
    605                                  // clean up failed HECs, if any
    606                                  pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_REMOVE_FAILED;
    607          
    608                                  // minimize the time of the next call
    609                                  CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MIN_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);                            
    610                               }
    611                              
    612                          }
    613                          else // single HEC connection mode
    614                          {
    615                              firstPhysAddr = pCdc->aHec[pCdc->currentHecIdx].firstDevPhysAddr;
    616                              lastPhysAddr  = pCdc->aHec[pCdc->currentHecIdx].lastDevPhysAddr; 
    617          
    618                              // Exclude activator (this device) from the HEC lengh formula, if it's a part of the HEC
    619                              activatorExcludeFactor = CdcIsDeviceBelongsToHec(firstPhysAddr, lastPhysAddr, pCdc->physAddr) ? 1 : 0;                    
    620                              
    621                              tmpCond = (pCdc->verifiedDevNum[0] == (CdcHecLengthGet(firstPhysAddr, lastPhysAddr) - activatorExcludeFactor)); // "-1" means activator exclusion
    622                              if (CdcIsTimeCounterExpired(&pCdc->cdcTaskTimeCount) || tmpCond)
    623                              {
    624                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: Stopped gathering Activation responses\n");
    625                                  // Change current HEC status to AHEC if all devices in the HEC are verified to be active
    626                                   if (tmpCond) 
    627                                   {
    628                                      bool_t isHwEnabledOk = true;
    629                                      
    630                                      // Activate eHDMI function
    631                                      if (pCdc->deviceStatus.hecFuncState < CDC_HEC_STATE_ACTIVE)
    632                                      {
    633                                          isHwEnabledOk = CdcEhdmiHwEnable(true);
    634                                          if (isHwEnabledOk)
    635                                          {
    636                                              pCdc->deviceStatus.hecFuncState = CDC_HEC_STATE_ACTIVE;
    637                                              CdcAliveTimerSet(10, 50); // start first AliveNotification message in 10-50 seconds
    638                                          }                                
    639                                      }
    640          
    641                                      if (isHwEnabledOk)
    642                                      {
    643                                          CdcAliveDeviceListAdd(pCdc->currentHecIdx); // add HEC devices (but Activator) to the Alive List
    644                                          pCdc->aHec[pCdc->currentHecIdx].status.channelState = CDC_AHEC;
    645                                          DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: HEC %d status has changed to AHEC.\n", (int) pCdc->currentHecIdx);
    646                                      }
    647                                      
    648                                   }
    649                                   else
    650                                   {
    651                                       DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: VHEC %d wasn't activated. Will be deactivated.\n", (int) pCdc->currentHecIdx);
    652                                       
    653                                       CdcHecSetStateSend(CDC_HEC_INACTIVE, 1, &pCdc->currentHecIdx); // deactivation of failed VHEC    
    654                                       CdcHecDescriptorRemove(pCdc->currentHecIdx); // removal of failed VHEC
    655                                       pCdc->currentHecIdx++; // step to next HEC
    656                                   }
    657                                   pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_INQUIRE_START; // move to another PHEC search                    
    658                              }
    659                          }
    660                          break;
    661          
    662                  case CDC_TASK_CONNECT_STATE_REMOVE_FAILED:
    663                          // find all HECs from the list that failed to activate
    664                          tmpCond = false;
    665                          for (i = 0; i < pCdc->connectSettings.hecActDelayed; i++)
    666                          {
    667                              if (pCdc->delayedHecIdx[i] != 0xFF)
    668                              {
    669                                  CdcHecSetStateSend(CDC_HEC_INACTIVE, 1, &pCdc->delayedHecIdx[i]); // deactivation of failed VHEC    
    670                                  CdcHecDescriptorRemove(pCdc->delayedHecIdx[i]); // removal of failed VHEC
    671                                  pCdc->delayedHecIdx[i] = 0xFF;
    672                                  tmpCond = true; // indication of a found failed HEC
    673                                  break;
    674                              }
    675                          }
    676          
    677                          if (!tmpCond) // if all failed HECs have been sanitized
    678                          {
    679                              pCdc->connectSettings.hecActDelayed = 0; // reset number of delayed HECs (all have been processed)
    680                              if (pCdc->connectSettings.isEndOfList)
    681                              {
    682                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT]: Task finished (Multi-HEC mode)\n");
    683                                  pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_REPORT_RESULTS; // end the task                               
    684                              }
    685                              else
    686                              {
    687                                  pCdc->currentHecIdx++; // step to next HEC
    688                                  pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_INQUIRE_START; // move to another PHEC search  
    689                              }
    690                          }
    691                          else
    692                          {
    693                              pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_REMOVE_FAILED; // come back to continue  
    694                          }
    695                          break;
    696          
    697                  case CDC_TASK_CONNECT_STATE_REPORT_RESULTS:
    698                          CdcIoPortsStatusUpdate(); // activate ports involved in the new AHECs 
    699                          pCdc->cdcTaskState = CDC_TASK_EMPTY_STATE_NONE; // reset stage
    700                          pCdc->cdcTaskFlags &= ~CDC_TASK_CONNECT; // stop the task
    701                          pCdc->cdcTaskMask = CDC_TASK_MASK_ALL_UNMASKED; // reset task mask as this task is done     
    702                          cdcFeedbackMsg = CDC_FB_MSG_CONNECT_DONE;                    
    703                          break;
    704                  default:
    705          				 break;
    706              }
    707          
    708              return cdcFeedbackMsg;
    709          }
    710          
    711          
    712          //-------------------------------------------------------------------------------------------------
    713          //! @brief      Establishes connection to adjacent device using
    714          //!             simplified activation method: control to adjacent device
    715          //!
    716          //! @return     Feedback message to the caller (Task status or error reports)
    717          //-------------------------------------------------------------------------------------------------
    718          
    719          static uint8_t CdcTaskConnectAdjacent(void)
    720          {
    721              uint8_t     cdcFeedbackMsg = CDC_FB_MSG_NONE;
    722              bool_t      tmpCond;
    723          
    724              switch(pCdc->cdcTaskState)
    725              {
    726                  case CDC_TASK_EMPTY_STATE_NONE: // all tasks shall start from empty state
    727                          pCdc->cdcTaskMask = CDC_TASK_CONNECT_ADJACENT; // mask out other tasks until this one is done
    728                          pCdc->cdcTaskState = CDC_TASK_CONNECT_ADJ_STATE_INIT;
    729                          // don't break here to save time and go ahead to the fist step
    730                  
    731                  case CDC_TASK_CONNECT_ADJ_STATE_INIT:
    732                          pCdc->cdcTaskState = CDC_TASK_CONNECT_ADJ_STATE_ACTIVATE_START; // next stage
    733                          pCdc->verifiedDevNum[0] = 0;
    734                          //break;
    735                          
    736                  case CDC_TASK_CONNECT_ADJ_STATE_ACTIVATE_START:
    737                          // Issue activation command
    738                          CdcHecSetStateAdjacentSend(CDC_HEC_ACTIVE, pCdc->currentHecIdx);
    739                          CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RESPONSE_TIME_MS), &pCdc->cdcTaskTimeCount);
    740                          CdcTimeCounterSet(CDC_TIME_SEC2TCK(CDC_MAX_MONITORING_TIME_SEC), &pCdc->cdcTotalMonTimeCount);
    741                          pCdc->cdcTaskState = CDC_TASK_CONNECT_ADJ_STATE_WAIT_ACT_REP; // next stage
    742                          DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT_ADJACENT]: Waiting for response for HEC %d\n", (int) pCdc->currentHecIdx);
    743                          break;
    744                          
    745                  case CDC_TASK_CONNECT_ADJ_STATE_WAIT_ACT_REP:
    746                          // wait until adjacent device respond
    747          
    748                          // Set recall timer to maximum in order to allow the task counters to set it to a new value
    749                          CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);
    750          
    751                          CdcTimeCounterUpdate(&pCdc->cdcTaskTimeCount);                    
    752                          CdcTimeCounterUpdate(&pCdc->cdcTotalMonTimeCount);
    753          
    754                          tmpCond = (pCdc->verifiedDevNum[0] == 1);
    755                          
    756                          if (CdcIsTimeCounterExpired(&pCdc->cdcTaskTimeCount) || CdcIsTimeCounterExpired(&pCdc->cdcTotalMonTimeCount) || tmpCond)
    757                          {
    758                              DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT_ADJACENT]: Stopped waiting for Activation response\n");
    759                               // Change curent HEC status to AHEC if adjacent devices is active
    760                               if (tmpCond) 
    761                               {
    762                                   // Activate eHDMI function
    763                                   if (CdcEhdmiHwEnable(true))
    764                                   {
    765                                       pCdc->aHec[pCdc->currentHecIdx].status.channelState = CDC_AHEC;
    766                                       pCdc->deviceStatus.hecFuncState = CDC_HEC_STATE_ACTIVE;
    767                                       DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT_ADJACENT]: HEC %d status has changed to AHEC.\n", (int) pCdc->currentHecIdx);
    768                                   }
    769                               }
    770                               else
    771                               {
    772                                   DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_CONNECT_ADJACENT]: HEC %d wasn't activated. Removed.\n", (int) pCdc->currentHecIdx);
    773                                   CdcHecDescriptorRemove(pCdc->currentHecIdx); // removal of failed VHEC
    774                               }
    775                               pCdc->cdcTaskState = CDC_TASK_CONNECT_ADJ_STATE_REPORT_RESULTS; // move to another PHEC search                    
    776          
    777                               // minimize the time of the next call
    778                               CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MIN_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);  
    779                          }
    780                          break;
    781          
    782                  case CDC_TASK_CONNECT_ADJ_STATE_REPORT_RESULTS:
    783                          CdcIoPortsStatusUpdate(); // activate ports involved in the new AHECs 
    784                          pCdc->cdcTaskState = CDC_TASK_EMPTY_STATE_NONE; // reset stage
    785                          pCdc->cdcTaskFlags &= ~CDC_TASK_CONNECT_ADJACENT; // stop the task
    786                          pCdc->cdcTaskMask = CDC_TASK_MASK_ALL_UNMASKED; // reset task mask as this task is done     
    787                          cdcFeedbackMsg = CDC_FB_MSG_CONNECT_ADJ_DONE;                    
    788                          break;
    789                  default:
    790          				 break;
    791              }
    792          
    793              return cdcFeedbackMsg;
    794          }
    795          
    796          
    797          //-------------------------------------------------------------------------------------------------
    798          //! @brief      Deactivation of an AHEC by Activator request is done by sending
    799          //!             out SetState message (no response gathering)
    800          //!
    801          //!             Deactivation of an AHEC by Passive device is done by sending
    802          //!             RequestDeactivation message
    803          //!             Task approach is needed if more than one AHEC has to be deactivated
    804          //!
    805          //! @return      Feedback message to the caller (Task status or error reports)
    806          //-------------------------------------------------------------------------------------------------
    807          
    808          static uint8_t CdcTaskDisconnect(void)
    809          {
    810              uint8_t     cdcFeedbackMsg = CDC_FB_MSG_NONE;
    811          
    812              switch(pCdc->cdcTaskState)
    813              {    
    814                  case CDC_TASK_EMPTY_STATE_NONE: // all tasks shall start from empty state
    815                          pCdc->cdcTaskMask = CDC_TASK_DISCONNECT; // mask out other tasks until this one is done
    816                          pCdc->cdcTaskState = CDC_TASK_DISCONNECT_STATE_DEACTIVATE;
    817                          // don't break here to save time and go ahead to the fist step
    818                  
    819                  case CDC_TASK_DISCONNECT_STATE_DEACTIVATE:
    820                      
    821                          if (pCdc->aHec[pCdc->currentHecIdx].status.isActivator == true)
    822                          {
    823                              // Activator deactivates AHEC by sending SetState command
    824                              CdcHecSetStateSend(CDC_HEC_INACTIVE, 1, &pCdc->currentHecIdx); // one HEC at a time
    825                              CdcAliveDeviceListRemove(pCdc->currentHecIdx); // remove devices from Alive List (if possible)                        
    826                              CdcHecDescriptorRemove(pCdc->currentHecIdx); // release resources for HEC
    827                              CdcHecDisableCheck(); // disable HEC hardware if no active HECs
    828                          }
    829                          else
    830                          {
    831                              // Passive device must request deactivation from the Activator
    832                              CdcHecDeactivationRequestSend(pCdc->currentHecIdx);
    833                          }
    834                          
    835                          pCdc->cdcTaskState = CDC_TASK_DISCONNECT_STATE_REPORT_RESULTS; // next stage
    836                          break;
    837                          
    838                  case CDC_TASK_DISCONNECT_STATE_REPORT_RESULTS:                
    839                          CdcIoPortsStatusUpdate(); // deactivate ports involved in the deactivated HEC
    840                          pCdc->cdcTaskState = CDC_TASK_EMPTY_STATE_NONE; // reset stage
    841                          pCdc->cdcTaskFlags &= ~CDC_TASK_DISCONNECT; // stop the task
    842                          pCdc->cdcTaskMask = CDC_TASK_MASK_ALL_UNMASKED; // reset task mask as this task is done    
    843                          cdcFeedbackMsg = CDC_FB_MSG_DISCONNECT_DONE;                    
    844                          break;
    845                  default:
    846          				 break;
    847              }
    848              
    849              return cdcFeedbackMsg;    
    850          }
    851          
    852          
    853          //-------------------------------------------------------------------------------------------------
    854          //! @brief      Deactivates all currently open AHECs
    855          //!
    856          //! @return     Feedback message to the caller (Task status or error reports)
    857          //-------------------------------------------------------------------------------------------------
    858          
    859          static uint8_t CdcTaskDisconnectAll(void)
    860          {
    861              uint8_t     cdcFeedbackMsg = CDC_FB_MSG_NONE;
    862          
    863              switch(pCdc->cdcTaskState)
    864              {
    865                  case CDC_TASK_EMPTY_STATE_NONE: // all tasks shall start from empty state
    866                          pCdc->cdcTaskMask = CDC_TASK_DISCONNECT_ALL; // mask out other tasks until this one is done
    867                          pCdc->cdcTaskState = CDC_TASK_DISCONNECT_ALL_STATE_DEACTIVATE_INIT;
    868                          // don't break here to save time and go ahead to the fist step
    869                  
    870                  case CDC_TASK_DISCONNECT_ALL_STATE_DEACTIVATE_INIT:
    871                          pCdc->currentHecIdx = 0;   // initialize HEC index
    872                          pCdc->cdcTaskState = CDC_TASK_DISCONNECT_ALL_STATE_DEACTIVATE; // next stage
    873                          //break;
    874          
    875                  case CDC_TASK_DISCONNECT_ALL_STATE_DEACTIVATE:
    876          
    877                          while (pCdc->currentHecIdx < CDC_NUMBER_OF_HECS_MAX)
    878                          {
    879                              if ((pCdc->aHec[pCdc->currentHecIdx].status.isInUse == true) && 
    880                                  (pCdc->aHec[pCdc->currentHecIdx].status.channelState > CDC_PHEC))
    881                              {
    882                                  // Found AHEC or VHEC; begin deactivation process. Increment the current HEC index when done                          
    883                                  if (pCdc->aHec[pCdc->currentHecIdx].status.isActivator == true)
    884                                  {
    885                                      // Activator deactivates AHEC by sending SetState command
    886                                      // Must check if CEC write FIFO isn't full before sending out a new message
    887                                      CdcHecSetStateSend(CDC_HEC_INACTIVE, 1, &pCdc->currentHecIdx); // one HEC at a time
    888                                      CdcAliveDeviceListRemove(pCdc->currentHecIdx); // remove devices from Alive List (if possible)                                
    889                                      CdcHecDescriptorRemove(pCdc->currentHecIdx); // release resources for the HEC                                
    890                                      CdcHecDisableCheck(); // disable HEC hardware if no active HECs
    891                                      
    892                                      // Then it's necessary to wait for some time to let the Activator's message to get out (?)
    893                                      CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MSG_OUT_TIME_MS), &pCdc->cdcTaskTimeCount);
    894                                      pCdc->cdcTaskState = CDC_TASK_DISCONNECT_ALL_STATE_DEACTIVATE_WAIT;                                
    895                                  }
    896                                  else
    897                                  {
    898                                      // Passive device must request deactivation from the Activator
    899                                      CdcHecDeactivationRequestSend(pCdc->currentHecIdx);  
    900                                      // Then it's necessary to wait for MRT to let the Activator respond with Deactivation message
    901                                      CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RESPONSE_TIME_MS), &pCdc->cdcTaskTimeCount);
    902                                      pCdc->cdcTaskState = CDC_TASK_DISCONNECT_ALL_STATE_DEACTIVATE_WAIT;
    903                                  }
    904          
    905                                  pCdc->currentHecIdx++;
    906                                  break; // do one message sending at a time
    907                              }
    908                              pCdc->currentHecIdx++;
    909                          }                
    910          
    911                          if (pCdc->currentHecIdx == CDC_NUMBER_OF_HECS_MAX) // if all HECs have been processed
    912                          {
    913                              pCdc->cdcTaskState = CDC_TASK_DISCONNECT_ALL_STATE_REPORT_RESULTS; // next stage
    914                          }
    915                          break;
    916          
    917                  case CDC_TASK_DISCONNECT_ALL_STATE_DEACTIVATE_WAIT:
    918                          // wait until the Activator respond
    919                          // criteria: timeout since the DeactivationRequest message sending 
    920          
    921                          // Set recall timer to maximum in order to allow the task counters to set it to a new value
    922                          CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);
    923                          
    924                          CdcTimeCounterUpdate(&pCdc->cdcTaskTimeCount);
    925                          
    926                          if (CdcIsTimeCounterExpired(&pCdc->cdcTaskTimeCount))
    927                          {
    928                              
    929                              pCdc->cdcTaskState = CDC_TASK_DISCONNECT_ALL_STATE_DEACTIVATE; // return from waiting
    930                          }
    931                          break;
    932          
    933                  case CDC_TASK_DISCONNECT_ALL_STATE_REPORT_RESULTS:
    934                          CdcIoPortsStatusUpdate(); // deactivate ports involved in the deactivated HEC
    935                          pCdc->cdcTaskState = CDC_TASK_EMPTY_STATE_NONE; // reset stage
    936                          pCdc->cdcTaskFlags &= ~CDC_TASK_DISCONNECT_ALL; // stop the task
    937                          pCdc->cdcTaskMask = CDC_TASK_MASK_ALL_UNMASKED; // reset task mask as this task is done                  
    938                          cdcFeedbackMsg = CDC_FB_MSG_DISCONNECT_ALL_DONE;
    939                          break;    
    940                  default:
    941          				 break;
    942              }
    943              
    944              return cdcFeedbackMsg;
    945          }
    946          
    947          
    948          //-------------------------------------------------------------------------------------------------
    949          //! @brief      Deactivate all AHECs including a failed device
    950          //!
    951          //! @return     Feedback message to the caller (Task status or error reports)
    952          //-------------------------------------------------------------------------------------------------
    953          
    954          static uint8_t CdcTaskDisconnectLost(void)
    955          {
    956              uint8_t     cdcFeedbackMsg = CDC_FB_MSG_NONE;
    957          
    958              switch(pCdc->cdcTaskState)
    959              {
    960                  case CDC_TASK_EMPTY_STATE_NONE: // all tasks shall start from empty state
    961                          pCdc->cdcTaskMask = CDC_TASK_DISCONNECT_LOST; // mask out other tasks until this one is done
    962                          pCdc->cdcTaskState = CDC_TASK_DISCONNECT_LOST_STATE_DEACTIVATE_INIT;
    963                          // don't break here to save time and go ahead to the fist step
    964                  
    965                  case CDC_TASK_DISCONNECT_LOST_STATE_DEACTIVATE_INIT:
    966                           pCdc->currentHecIdx = 0;   // initialize HEC index
    967                           pCdc->cdcTaskState = CDC_TASK_DISCONNECT_LOST_STATE_DEACTIVATE; // next stage
    968                           //break;
    969                  
    970                   case CDC_TASK_DISCONNECT_LOST_STATE_DEACTIVATE:
    971                  
    972                           while (pCdc->currentHecIdx < CDC_NUMBER_OF_HECS_MAX)
    973                           {
    974                               if ((pCdc->aHec[pCdc->currentHecIdx].status.isInUse == true) && 
    975                                   (pCdc->aHec[pCdc->currentHecIdx].status.channelState > CDC_PHEC))
    976                               {
    977                                  if (((pCdc->aHec[pCdc->currentHecIdx].status.isActivator == true) &&
    978                                       CdcIsDeviceBelongsToHec(pCdc->aHec[pCdc->currentHecIdx].firstDevPhysAddr,
    979                                                               pCdc->aHec[pCdc->currentHecIdx].lastDevPhysAddr,
    980                                                               pCdc->aliveDevPhysAddr)) || 
    981                                      (pCdc->aHec[pCdc->currentHecIdx].activatorPhysAddr == pCdc->aliveDevPhysAddr))
    982                                   {
    983                                       // Found AHEC or VHEC that contain the lost device; begin deactivation process. 
    984                                       if (pCdc->aHec[pCdc->currentHecIdx].status.isActivator == true)
    985                                       {
    986                                           // Activator deactivates AHEC by sending SetState command
    987                                           // Must check if CEC write FIFO isn't full before sending out a new message
    988                                           CdcHecSetStateSend(CDC_HEC_INACTIVE, 1, &pCdc->currentHecIdx); // one HEC at a time
    989                                           // Then it's necessary to wait for some time to let the Activator's message to get out (?)
    990                                           CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MSG_OUT_TIME_MS), &pCdc->cdcTaskTimeCount);
    991                                           pCdc->cdcTaskState = CDC_TASK_DISCONNECT_LOST_STATE_DEACTIVATE_WAIT;                                
    992                                       }
    993                                       else
    994                                       {
    995                                           // Passive device remove HEC containing the lost device without any signalling                           
    996                                           // No need for waiting, schedule the next cycle to continue immediatelly 
    997                                           pCdc->cdcTaskState = CDC_TASK_DISCONNECT_LOST_STATE_DEACTIVATE;
    998                                       }
    999                                       CdcAliveDeviceListRemove(pCdc->currentHecIdx); // remove devices from Alive List (if possible)                                
   1000                                       CdcHecDescriptorRemove(pCdc->currentHecIdx); // release resources for the HEC                                
   1001                                       CdcHecDisableCheck(); // disable HEC hardware if no active HECs
   1002                                       
   1003                                       pCdc->currentHecIdx++;
   1004                                       break; // do one message sending at a time
   1005                                   }
   1006                               }
   1007                               pCdc->currentHecIdx++;
   1008                           }                
   1009                  
   1010                           if (pCdc->currentHecIdx == CDC_NUMBER_OF_HECS_MAX) // if all HECs have been processed
   1011                           {  
   1012                              pCdc->cdcTaskState = CDC_TASK_DISCONNECT_LOST_STATE_REPORT_RESULTS; // next stage
   1013                           }
   1014                           break;
   1015                  
   1016                   case CDC_TASK_DISCONNECT_LOST_STATE_DEACTIVATE_WAIT:
   1017                           // wait until activator's deactivation message is processed
   1018                           // criteria: timeout since the starting of deactivation 
   1019          
   1020                           // Set recall timer to maximum in order to allow the task counters to set it to a new value
   1021                           CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);
   1022                           
   1023                           CdcTimeCounterUpdate(&pCdc->cdcTaskTimeCount);
   1024                           
   1025                           if (CdcIsTimeCounterExpired(&pCdc->cdcTaskTimeCount))
   1026                           {
   1027                               pCdc->cdcTaskState = CDC_TASK_DISCONNECT_LOST_STATE_DEACTIVATE; // return from waiting
   1028                           }
   1029                           break;
   1030                           
   1031                   case CDC_TASK_DISCONNECT_LOST_STATE_REPORT_RESULTS:
   1032                           CdcIoPortsStatusUpdate(); // deactivate ports involved in the deactivated HEC
   1033                           pCdc->cdcTaskState = CDC_TASK_EMPTY_STATE_NONE; // reset stage
   1034                           pCdc->cdcTaskFlags &= ~CDC_TASK_DISCONNECT_LOST; // stop the task
   1035                           pCdc->cdcTaskMask = CDC_TASK_MASK_ALL_UNMASKED; // reset task mask as this task is done       
   1036                           cdcFeedbackMsg = CDC_FB_MSG_DISCONNECT_LOST_DONE;                     
   1037                           break;
   1038                   default:
   1039          				 break;
   1040              }
   1041          
   1042              return cdcFeedbackMsg;
   1043          }
   1044          
   1045          
   1046          #if (IS_RX == ENABLE)
   1047          //-------------------------------------------------------------------------------------------------
   1048          //! @brief      Send HPD SetState message and wait until the HDMI Source responds
   1049          //!
   1050          //! @return     Feedback message to the caller (Task status or error reports)
   1051          //-------------------------------------------------------------------------------------------------
   1052          
   1053          uint8_t CdcTaskHpdSignal(void)
   1054          {
   1055              uint8_t     cdcFeedbackMsg = CDC_FB_MSG_NONE;
   1056          
   1057              // Send HPD SetState message and wait until the HDMI Source responds 
   1058              switch(pCdc->cdcTaskState)
   1059              {
   1060                  case CDC_TASK_EMPTY_STATE_NONE: // all tasks shall start from empty state
   1061                          pCdc->cdcTaskMask = CDC_TASK_HPD_SIGNAL; // mask out other tasks until this one is done
   1062                          pCdc->cdcTaskState = CDC_TASK_HPD_SIGNAL_STATE_START;
   1063                          // don't break here to save time and go ahead to the first step
   1064                  
   1065                  case CDC_TASK_HPD_SIGNAL_STATE_START: // First stage: Sending an HPD SetState message                  
   1066                          CdcHpdSetStateSend(pCdc->currentPortIdx); 
   1067                          pCdc->cdcTaskState = CDC_TASK_HPD_SIGNAL_STATE_RESPONSE_WAIT; // next stage
   1068                          DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_HPD_SIGNAL]: Waiting for HPD ReportState\n");
   1069                          CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RESPONSE_TIME_MS), &pCdc->cdcTaskTimeCount);
   1070                          break;
   1071                  
   1072                  case CDC_TASK_HPD_SIGNAL_STATE_RESPONSE_WAIT:
   1073                          // wait until Source device responds
   1074                          // criteria: MRT timeout 
   1075          
   1076                          // Set recall timer to maximum in order to allow the task counters to set it to a new value
   1077                          CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);
   1078                          
   1079                          CdcTimeCounterUpdate(&pCdc->cdcTaskTimeCount);
   1080          
   1081                          if (CdcIsTimeCounterExpired(&pCdc->cdcTaskTimeCount))
   1082                          {
   1083                              // stop the task and provide error feedback
   1084                              pCdc->cdcTaskState = CDC_TASK_EMPTY_STATE_NONE;  // reset stage
   1085                              pCdc->cdcTaskFlags &= ~CDC_TASK_HPD_SIGNAL;  // stop the task
   1086                              pCdc->cdcTaskMask = CDC_TASK_MASK_ALL_UNMASKED; // reset task mask as this task is done     
   1087                              cdcFeedbackMsg = CDC_FB_MSG_ERR_HPD_SIGNAL;
   1088                              DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_HPD_SIGNAL]: HDMI Source haven't responded\n");
   1089                          }
   1090                          break;
   1091          
   1092                  case CDC_TASK_HPD_SIGNAL_STATE_REPORT_RESULTS: 
   1093                          pCdc->cdcTaskState = CDC_TASK_EMPTY_STATE_NONE;  // reset stage
   1094                          pCdc->cdcTaskFlags &= ~CDC_TASK_HPD_SIGNAL; // stop the task
   1095                          pCdc->cdcTaskMask = CDC_TASK_MASK_ALL_UNMASKED; // reset task mask as this task is done     
   1096                          cdcFeedbackMsg = CDC_FB_MSG_HPD_SIGNAL_DONE; // successful end of the HPD Signalling task                   
   1097                          break;
   1098          
   1099                  default:
   1100          				 break;
   1101              }
   1102          
   1103              return cdcFeedbackMsg;
   1104          }
   1105          #endif
   1106          
   1107          //-------------------------------------------------------------------------------------------------
   1108          //! @brief      HPD Capability verification task; sends InqureState Message to
   1109          //!             an adjacent device and checks the response
   1110          //!
   1111          //! @return     Feedback message to the caller (Task status or error reports)
   1112          //-------------------------------------------------------------------------------------------------
   1113          
   1114          uint8_t CdcTaskHpdCapabilityVerification(void)
   1115          {
   1116              uint8_t     cdcFeedbackMsg = CDC_FB_MSG_NONE;
   1117          
   1118              // HPD Capability verification task
   1119              // Sends InqureState Message to an adjacent device and checks the response
   1120              switch(pCdc->cdcTaskState)
   1121              {
   1122                  case CDC_TASK_EMPTY_STATE_NONE: // all tasks shall start from empty state
   1123                           pCdc->cdcTaskMask = CDC_TASK_HPD_CAPAB_VERIF; // mask out other tasks until this one is done
   1124                           pCdc->cdcTaskState = CDC_TASK_HPD_CAPAB_STATE_START;
   1125                           // don't break here to save time and go ahead to the fist step
   1126                   
   1127                   case CDC_TASK_HPD_CAPAB_STATE_START: // First stage: Sending an InquireState message to adjacent source device                  
   1128                           if (CdcHecInquireStateOfAdjacentSend(false, pCdc->currentPortIdx)) // input port mode
   1129                           { // if error
   1130                               DEBUG_PRINT(CDC_MSG_ALWAYS, "[CDC_TASK_HPD_CAPAB_VERIF]: The adjacent device doesn't exist\n");
   1131                           }
   1132                           pCdc->cdcTaskState = CDC_TASK_HPD_CAPAB_STATE_RESPONSE_WAIT; // next stage
   1133                           DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_HPD_CAPAB_VERIF]: Waiting for HPD capability verification ReportState\n");
   1134                           CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RESPONSE_TIME_MS), &pCdc->cdcTaskTimeCount);
   1135                           break;
   1136                   
   1137                   case CDC_TASK_HPD_CAPAB_STATE_RESPONSE_WAIT:
   1138                           // wait until Source device responds
   1139                           // criteria: MRT timeout 
   1140          
   1141                           // Set recall timer to maximum in order to allow the task counters to set it to a new value
   1142                           CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);
   1143                           
   1144                           CdcTimeCounterUpdate(&pCdc->cdcTaskTimeCount);
   1145                  
   1146                           if (CdcIsTimeCounterExpired(&pCdc->cdcTaskTimeCount))
   1147                           {
   1148                               // stop the task and provide error feedback
   1149                               pCdc->cdcTaskState = CDC_TASK_EMPTY_STATE_NONE;   // reset stage
   1150                               pCdc->cdcTaskFlags &= ~CDC_TASK_HPD_CAPAB_VERIF;  // stop the task
   1151                               pCdc->cdcTaskMask = CDC_TASK_MASK_ALL_UNMASKED;  // reset task mask as this task is done     
   1152                               cdcFeedbackMsg = CDC_FB_MSG_ERR_HPD_CAP_FAILED;
   1153                               DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_HPD_SIGNAL]: HDMI Source haven't responded to HPD capability verification request\n");
   1154                           }
   1155                           break;
   1156                  
   1157                   case CDC_TASK_HPD_CAPAB_STATE_REPORT_RESULTS: 
   1158                           pCdc->cdcTaskState = CDC_TASK_EMPTY_STATE_NONE;  // reset stage
   1159                           pCdc->cdcTaskFlags &= ~CDC_TASK_HPD_CAPAB_VERIF; // stop the task
   1160                           pCdc->cdcTaskMask = CDC_TASK_MASK_ALL_UNMASKED; // reset task mask as this task is done     
   1161                           cdcFeedbackMsg = CDC_FB_MSG_HPD_CAPABILITY_CONF; // HPD capability of the adjacent source is confirmed                   
   1162                           break;
   1163                   default:
   1164          				 break;
   1165              }
   1166                  
   1167              return cdcFeedbackMsg;    
   1168          }
   1169          
   1170          
   1171          //-------------------------------------------------------------------------------------------------
   1172          //! @brief      Performs CDC message parsing and support basic CDC functionality
   1173          //!             of passive devices
   1174          //!
   1175          //!             This task can't be masked and will run in background of the
   1176          //!             other active task, if an incoming CDC message is pending
   1177          //!
   1178          //! @param[in]  pCdcMessage - pointer to a pending CDC message or 0, if there is no message awaiting
   1179          //!
   1180          //! @return     Feedback message to the caller (Task status or error reports)
   1181          //-------------------------------------------------------------------------------------------------
   1182          
   1183          static uint8_t CdcTaskBase(SiiCpiData_t *pCdcMessage)
   1184          {
   1185              uint8_t     cdcFeedbackMsg = CDC_FB_MSG_NONE;
   1186              uint16_t    initiatorPhysAddr;
   1187              uint16_t    targetPhysAddr;
   1188              uint16_t    firstPhysAddr;
   1189              uint16_t    lastPhysAddr;
   1190              uint8_t     inputPortIndex;
   1191              uint8_t     aInputPortRtIdx[2];
   1192              uint8_t     outputPortRtFlg;
   1193              uint8_t     hecIdx;    
   1194              uint8_t     hecCount;
   1195              uint8_t     numberOfHecs;
   1196              bool_t      tmpCond;
   1197              uint8_t     errCode = CDC_ERRCODE_NO_ERROR;
   1198              uint8_t     i;
   1199              uint8_t     j;
   1200          
   1201          
   1202              if (pCdcMessage != 0) //decode a message, update status
   1203              {
   1204                  initiatorPhysAddr = (pCdcMessage->args[0] << 8) + pCdcMessage->args[1];
   1205          
   1206                  // check if the message belongs to CDC group and has broadcast destination
   1207                  if ((pCdcMessage->opcode == CDC_CEC_OPCODE) && ((pCdcMessage->srcDestAddr & 0xF) == 0xF))
   1208                  {
   1209                      switch (pCdcMessage->args[2]) // CDC operation code
   1210                      {
   1211                          case CDCOP_HEC_INQUIRE_STATE:
   1212                              
   1213                              if (pCdcMessage->argCount != 7)
   1214                              {
   1215                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: ERROR in InquireState message: wrong length!\n");
   1216                                  break;
   1217                              }
   1218                              
   1219                              firstPhysAddr = (pCdcMessage->args[3] << 8) + pCdcMessage->args[4];
   1220                              lastPhysAddr  = (pCdcMessage->args[5] << 8) + pCdcMessage->args[6];
   1221                              
   1222                              // reply with ReportState message only if the device belongs to the inquired HEC
   1223                              if (CdcIsDeviceBelongsToHec(firstPhysAddr, lastPhysAddr, pCdc->physAddr))
   1224                              {
   1225                                  // report without error if all relevant ports are HEC-capable
   1226                                  if (CdcCapablePortGet(firstPhysAddr, lastPhysAddr, aInputPortRtIdx, &outputPortRtFlg))
   1227                                  {                            
   1228                                      DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: received InquireState message from PA = %04x\n", initiatorPhysAddr);
   1229                                      if (outputPortRtFlg != 0)
   1230                                      {
   1231                                          DEBUG_PRINT(CDC_MSG_DBG, "* HEC capable Output port is involved\n");
   1232                                      }
   1233          
   1234                                      for (i = 0; i < 2; i++)
   1235                                      {
   1236                                          if (aInputPortRtIdx[i] != 0xFF)
   1237                                          {
   1238                                              DEBUG_PRINT(CDC_MSG_DBG, "* HEC capable Input port %d is involved\n", (int) aInputPortRtIdx[i]);
   1239                                          }
   1240                                      }
   1241                                  }
   1242                                  else
   1243                                  {
   1244                                      // report an error when required ports are HEC incapable
   1245                                      pCdc->deviceStatus.cdcErrorState = CDC_ERRCODE_NOT_SUPPORTED_CAPABILITY; 
   1246                                  }
   1247                                  
   1248                                  CdcHecReportStateSend(initiatorPhysAddr, CDC_REPORT_STATE_SHORT_MODE);                        
   1249                              }
   1250                              break;
   1251                              
   1252                          case CDCOP_HEC_REPORT_STATE: 
   1253                              
   1254                              errCode = pCdcMessage->args[5] & 0x03;
   1255                              
   1256                              if ((pCdcMessage->argCount != 6) && (pCdcMessage->argCount != 8))
   1257                              {
   1258                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: ERROR in ReportState message: wrong length!\n");
   1259                                  break;
   1260                              }
   1261                              else if (errCode != CDC_ERRCODE_NO_ERROR)
   1262                              {
   1263                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Device PA = %04x reported an error: ", initiatorPhysAddr);
   1264                                  switch (errCode)
   1265                                  {
   1266                                      case CDC_ERRCODE_NOT_SUPPORTED_CAPABILITY:
   1267                                          DEBUG_PRINT(CDC_MSG_DBG, "capability not supported.\n");
   1268                                          break;
   1269                                      case CDC_ERRCODE_INCOMPATIBLE_STATE:
   1270                                          DEBUG_PRINT(CDC_MSG_DBG, "incompatible state.\n");
   1271                                          break;
   1272                                      case CDC_ERRCODE_OTHER_ERROR:
   1273                                          DEBUG_PRINT(CDC_MSG_DBG, "other error.\n");
   1274                                          break;
   1275                                  }
   1276                                  
   1277                                  CdcTimeCounterReset(&pCdc->cdcTaskTimeCount); // stop waiting to react immediatelly
   1278                                  break;
   1279                              }
   1280                              
   1281                               
   1282                              targetPhysAddr = (pCdcMessage->args[3] << 8) + pCdcMessage->args[4];
   1283          
   1284                              if ((targetPhysAddr == 0xFFFF) && (pCdcMessage->argCount == 8)) // Capability notification broadcast
   1285                              {
   1286                                  DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: received Capability Notification message from PA = %04x\n", initiatorPhysAddr);
   1287                                  // Check if some of AHECs have to be deactivated if the initiating device reports 
   1288                                  // its HEC capability change and takes part in those AHECs
   1289          
   1290                                  // -- Normally, all devices shall disconnect all their open HECs
   1291                                  //    before changing HEC support state to not supported
   1292          
   1293                                  // Update found device list taking into account the new capability information
   1294                                  tmpCond = false; // not found by default
   1295                                  for (i = 0; i < pCdc->numberOfAllHosts; i++)
   1296                                  {
   1297                                      if (pCdc->cdcFoundHostsList[i].physAddr == initiatorPhysAddr)
   1298                                      {
   1299                                          if (((pCdcMessage->args[5] >> 6) & 0x03) != CDC_HEC_FUNC_NOT_SUPPORTED)
   1300                                          {  // update port capability bits and device status
   1301                                              pCdc->cdcFoundHostsList[i].hostInfo.portHecCapBits = 0x7FFF & ((pCdcMessage->args[6] << 8) | pCdcMessage->args[7]);
   1302                                              pCdc->cdcFoundHostsList[i].devStat.hecFuncState  = ((pCdcMessage->args[5] >> 6) & 0x03);                                      
   1303                                              pCdc->cdcFoundHostsList[i].devStat.hostFuncState = ((pCdcMessage->args[5] >> 4) & 0x03); 
   1304                                              pCdc->cdcFoundHostsList[i].devStat.encFuncState  = ((pCdcMessage->args[5] >> 2) & 0x03);                                  
   1305                                              pCdc->cdcFoundHostsList[i].devStat.cdcErrorState =  (pCdcMessage->args[5] & 0x03);                                                                              
   1306                                          }
   1307                                          else
   1308                                          {
   1309                                              // remove incapable device from the list
   1310                                              for (j = i; j < (pCdc->numberOfAllHosts - 1); j++)
   1311                                              {
   1312                                                  pCdc->cdcFoundHostsList[j] = pCdc->cdcFoundHostsList[j+1];
   1313                                              }
   1314                                              pCdc->numberOfAllHosts--;
   1315                                          }
   1316                                          tmpCond = true; // set found flag
   1317                                          break;
   1318                                      }
   1319                                  }
   1320          
   1321                                  if (!tmpCond) // if initiator haven't been found in the list
   1322                                  {
   1323                                      CdcHecAddNewDeviceToHostList(pCdcMessage, initiatorPhysAddr);
   1324                                  }
   1325          
   1326                                  CdcDiscoveryDataArrange();  
   1327          
   1328                                  // check if initiating device has been excluded from the list of
   1329                                  // potentially reachable hosts 
   1330                                  tmpCond = true; // will flip to false, if the device have been found in the list 
   1331                                  for (i = 0; i < pCdc->numberOfFoundHosts; i++)
   1332                                  {
   1333                                      if (pCdc->cdcFoundHostsList[i].physAddr == initiatorPhysAddr)
   1334                                      {
   1335                                          tmpCond = false; // device is still in the list 
   1336                                          break;
   1337                                      }
   1338                                  }
   1339                                  // if so, disconnect all HECs that include the failed device
   1340                                  // Make sure other tasks are inactive, leave the affected HECs to be 
   1341                                  // deactivated by timeout otherwise
   1342                                  if (tmpCond)
   1343                                  {
   1344                                      CdcLostDeviceDisconnect(initiatorPhysAddr);
   1345                                  }
   1346                                      
   1347                                  cdcFeedbackMsg = CDC_FB_MSG_CAPABILITY_CHANGED;
   1348                                  break;
   1349                              }
   1350                              else if (targetPhysAddr != pCdc->physAddr)
   1351                              {
   1352                                  break; // don't process message addressed to another device
   1353                              }
   1354                              
   1355                              DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: received ReportState message from PA = %04x\n", initiatorPhysAddr);
   1356                              
   1357                              // Process ReportState messages for response gathering stage of ENC search task 
   1358                              if (pCdc->cdcTaskState == CDC_TASK_FIND_STATE_GATHER_RESPONSES)
   1359                              {
   1360                                  if (pCdc->cdcTaskFlags & CDC_TASK_HOSTS_SEARCH)
   1361                                  {
   1362                                      // reset the time counter if new ReportState message arrived
   1363                                      CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RESPONSE_TIME_MS), &pCdc->cdcTaskTimeCount);
   1364                                     
   1365                                      // Collect HEC & Ext NW capable device PAs if ...
   1366                                      if (pCdcMessage->argCount == 8) // Discovery mode of ReportState 
   1367                                      {
   1368                                          CdcHecAddNewDeviceToHostList(pCdcMessage, initiatorPhysAddr);
   1369                                      }
   1370                                  }
   1371                              }
   1372                              // Process ReportState messages for InquireState response gathering stage of Connect Task 
   1373                              else if (pCdc->cdcTaskState == CDC_TASK_CONNECT_STATE_GATHER_INQ_REP)
   1374                              {
   1375                                  // reset the time counter if new ReportState message arrived
   1376                                  CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RESPONSE_TIME_MS), &pCdc->cdcTaskTimeCount);
   1377          
   1378                                  // Make sure all devices in tested PHEC report HEC support
   1379                                  // if not, the HEC can't obtain VHEC status
   1380                                  if (((pCdcMessage->args[5] >> 6) & 0x03) == CDC_HEC_FUNC_NOT_SUPPORTED) // HEC function isn't available
   1381                                  {
   1382                                      DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Device PA = %04x doesn't support HEC function. PHEC %d can't be verified.\n",
   1383                                                  initiatorPhysAddr, (int) pCdc->currentHecIdx);
   1384                                      CdcHecDescriptorRemove(pCdc->currentHecIdx); // Remove failed PHEC                                
   1385                                      pCdc->currentHecIdx++; // step to next HEC
   1386                                      pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_INQUIRE_START; // move to another PHEC search                            
   1387                                      CdcTimeCounterReset(&pCdc->cdcTaskTimeCount); // stop waiting to react immediately
   1388                                  }
   1389                                  else if (errCode == CDC_ERRCODE_NO_ERROR)
   1390                                  {   // add to the number of verified devices, if the device also belongs to HEC
   1391                                      firstPhysAddr = pCdc->aHec[pCdc->currentHecIdx].firstDevPhysAddr;
   1392                                      lastPhysAddr  = pCdc->aHec[pCdc->currentHecIdx].lastDevPhysAddr;
   1393                                      if (CdcIsDeviceBelongsToHec(firstPhysAddr, lastPhysAddr, initiatorPhysAddr))
   1394                                      {
   1395                                          pCdc->verifiedDevNum[0]++;                                  
   1396                                          DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Device PA = %04x supports HEC function.\n", initiatorPhysAddr);
   1397                                      }
   1398                                  }
   1399                              }
   1400                              else if (pCdc->cdcTaskState == CDC_TASK_CONNECT_STATE_GATHER_ACT_REP)
   1401                              {
   1402                                  // reset the time counter if new ReportState message arrived
   1403                                  CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RESPONSE_TIME_MS), &pCdc->cdcTaskTimeCount);
   1404                                  
   1405                                  if ((!pCdc->connectSettings.isMultHecMode) && (pCdcMessage->argCount == 6)) // short mode of ReportState
   1406                                  {
   1407                                      // Make sure all devices in tested VHEC report activated status
   1408                                      // if not, the HEC can't obtain AHEC status
   1409                                      if (((pCdcMessage->args[5] >> 6) & 0x03) != CDC_HEC_STATE_ACTIVE) // HEC isn't active
   1410                                      {
   1411                                          DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Device PA = %04x isn't active. AHEC %d can't be verified.\n",
   1412                                                      initiatorPhysAddr, (int) pCdc->currentHecIdx);
   1413                                          CdcHecDescriptorRemove(pCdc->currentHecIdx); // Remove failed PHEC
   1414                                          pCdc->currentHecIdx++; // step to next HEC
   1415                                          pCdc->cdcTaskState = CDC_TASK_CONNECT_STATE_INQUIRE_START; // move to another PHEC search                            
   1416                                          CdcTimeCounterReset(&pCdc->cdcTaskTimeCount); // stop waiting to react immediately
   1417                                      }
   1418                                      else if (errCode == CDC_ERRCODE_NO_ERROR)
   1419                                      {   // add to the number of verified devices, if the device also belongs to HEC
   1420                                          firstPhysAddr = pCdc->aHec[pCdc->currentHecIdx].firstDevPhysAddr;
   1421                                          lastPhysAddr  = pCdc->aHec[pCdc->currentHecIdx].lastDevPhysAddr;
   1422                                          if (CdcIsDeviceBelongsToHec(firstPhysAddr, lastPhysAddr, initiatorPhysAddr))
   1423                                          {
   1424                                              pCdc->verifiedDevNum[0]++;                                  
   1425                                              DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Device PA = %04x is HEC-active.\n", initiatorPhysAddr);
   1426                                          }
   1427                                      }
   1428                                      
   1429                                  }
   1430                                  else if (pCdc->connectSettings.isMultHecMode) // Multi-HEC activation mode
   1431                                  {
   1432                                      uint8_t hecFuncState = (pCdcMessage->args[5] >> 6) & 0x03;
   1433                                      
   1434                                      // collect positive responses for every VHEC in multi-VHEC activation command
   1435                                      if (((hecFuncState == CDC_HEC_STATE_ACTIVE) && (pCdcMessage->argCount == 6)) ||
   1436                                          ((hecFuncState == CDC_HEC_ACTIVATION_FLD) && (pCdcMessage->argCount == 8)))
   1437                                      {   // add to the number of verified device
   1438                                          for (i = 0; i < pCdc->connectSettings.hecActDelayed; i++)
   1439                                          {
   1440                                              if (CdcIsDeviceBelongsToHec(pCdc->aHec[pCdc->delayedHecIdx[i]].firstDevPhysAddr, 
   1441                                                                          pCdc->aHec[pCdc->delayedHecIdx[i]].lastDevPhysAddr, 
   1442                                                                          initiatorPhysAddr))
   1443                                              {
   1444                                                  if (pCdcMessage->argCount == 8) // multi-HEC mode of ReportState (device is part of more than one HECs)
   1445                                                  {   // check if ports are active to support this HEC
   1446                                                      if (!CdcIsHecEnabledInDev(pCdc->delayedHecIdx[i], initiatorPhysAddr, 
   1447                                                                           (pCdcMessage->args[6] << 8) | pCdcMessage->args[7]))
   1448                                                      {
   1449                                                          DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Device PA = %04x ports can't support HEC %d.\n", initiatorPhysAddr, (int) i);
   1450                                                          continue; // jump to the next HEC, if failed to confirm port activation
   1451                                                      }
   1452                                                  }
   1453          
   1454                                                  pCdc->verifiedDevNum[i]++;
   1455                                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Device PA = %04x is active for HEC %d.\n", initiatorPhysAddr, (int) i);
   1456                                              }
   1457                                          }
   1458                                      }
   1459                                      else
   1460                                      {
   1461                                          DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Device PA = %04x isn't active. AHECs can't be verified.\n", initiatorPhysAddr);
   1462                                          CdcTimeCounterReset(&pCdc->cdcTaskTimeCount); // stop waiting to react immediately
   1463                                      }
   1464                                  }
   1465                                      
   1466                              }
   1467                              else if (pCdc->cdcTaskState == CDC_TASK_CONNECT_ADJ_STATE_WAIT_ACT_REP)
   1468                              {
   1469                                  
   1470                                  if (pCdcMessage->argCount == 6) // short mode of ReportState
   1471                                  {
   1472                                      // Make sure adjacent device reports activated status
   1473                                      // if not, the HEC can't obtain AHEC status
   1474                                      if (((pCdcMessage->args[5] >> 6) & 0x03) == CDC_HEC_STATE_ACTIVE) // HEC is active
   1475                                      {
   1476                                          firstPhysAddr = pCdc->aHec[pCdc->currentHecIdx].firstDevPhysAddr;
   1477                                          lastPhysAddr  = pCdc->aHec[pCdc->currentHecIdx].lastDevPhysAddr;
   1478                                          if (CdcIsDeviceBelongsToHec(firstPhysAddr, lastPhysAddr, initiatorPhysAddr))
   1479                                          {
   1480                                              pCdc->verifiedDevNum[0] = 1;                                  
   1481                                              DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Adjacent device PA = %04x is HEC-active.\n", initiatorPhysAddr);
   1482                                          }
   1483                                      }
   1484                                  }
   1485                              }
   1486                              else if (pCdc->cdcTaskState == CDC_TASK_HPD_CAPAB_STATE_RESPONSE_WAIT)
   1487                              {
   1488                                  // Make sure the response comes from an adjacent HDMI source
   1489                                  // and the device doesn't report an error status
   1490                                  if (CdcIsLinkedDirectly(pCdc->physAddr, initiatorPhysAddr, pCdc->currentPortIdx) &&
   1491                                      ((pCdcMessage->args[5] & 0x03) == CDC_ERRCODE_NO_ERROR))
   1492                                  {           
   1493                                      DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: PA = %04x confirms HPD-over-CDC capability\n", initiatorPhysAddr);
   1494                                      pCdc->cdcTaskState = CDC_TASK_HPD_CAPAB_STATE_REPORT_RESULTS; // break waiting
   1495                                  }
   1496                              }
   1497                              break;
   1498                              
   1499                          case CDCOP_HEC_SET_STATE_ADJACENT:
   1500                              
   1501                              if (pCdcMessage->argCount != 6)
   1502                              {
   1503                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: ERROR in SetStateAdjacent message: wrong length!\n");
   1504                                  break;
   1505                              }
   1506          
   1507                              lastPhysAddr  = (pCdcMessage->args[3] << 8) + pCdcMessage->args[4]; // shall be equal to PA of this device ???
   1508                              if (lastPhysAddr == pCdc->physAddr)
   1509                              {
   1510                                  uint8_t     adjacentFlg;
   1511          
   1512                                  // Make sure the request comes from an adjacent device, either HDMI Sink or Source,
   1513                                  // and receiving (this) device has capable input or output port that connects it to the initiator
   1514                                  adjacentFlg = 0; // adjacency flag
   1515                                  if (CdcIsCapableToAdjacent(initiatorPhysAddr, lastPhysAddr, &adjacentFlg) && (pCdc->deviceStatus.hecFuncState != CDC_HEC_FUNC_NOT_SUPPORTED))
   1516                                  {
   1517                                      // Immediately enable the AHEC without verification of the channel and Alive Notifications
   1518                                      // Activation command
   1519                                      if (pCdcMessage->args[5] == CDC_HEC_ACTIVE)
   1520                                      {
   1521                                          DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: received SetStateAdjacent::Activate message from PA = %04x\n", initiatorPhysAddr);
   1522          
   1523                                          // Add new AHEC to the Instance Record
   1524                                          hecIdx = CdcHecDescriptorAdd(false);
   1525                                          if (hecIdx == 0xFF)
   1526                                          {
   1527                                              DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Can't add new HEC descriptor.\n");
   1528                                              pCdc->deviceStatus.cdcErrorState = CDC_ERRCODE_OTHER_ERROR; // memory limitation error
   1529                                          }
   1530                                          else
   1531                                          {
   1532                                              pCdc->aHec[hecIdx].activatorPhysAddr = initiatorPhysAddr;
   1533                                              pCdc->aHec[hecIdx].firstDevPhysAddr = initiatorPhysAddr;
   1534                                              pCdc->aHec[hecIdx].lastDevPhysAddr = lastPhysAddr;
   1535                                              pCdc->aHec[hecIdx].status.channelState = CDC_AHEC; // Passive device registers AHECs only
   1536                                              pCdc->aHec[hecIdx].status.isAdjacent = true;
   1537          
   1538                                              // Activate eHDMI function
   1539                                              if (CdcEhdmiHwEnable(true))
   1540                                              {
   1541                                                  pCdc->deviceStatus.hecFuncState = CDC_HEC_STATE_ACTIVE;
   1542                                                  CdcIoPortsStatusUpdate();// activate involved ports
   1543                                              }
   1544                                          }
   1545          
   1546                                      }
   1547                                      else // Deactivation command
   1548                                      if (pCdcMessage->args[5] == CDC_HEC_INACTIVE)
   1549                                      {
   1550                                          DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: received SetStateAdjacent::Deactivate message from PA = %04x\n", initiatorPhysAddr);
   1551          
   1552                                          // Remove the AHEC from the Instance Record
   1553                                          hecIdx = CdcHecIndexGet(initiatorPhysAddr, initiatorPhysAddr, lastPhysAddr);
   1554                                          if (hecIdx == 0xFF)
   1555                                          {
   1556                                              DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Can't find existing HEC descriptor to delete.\n");
   1557                                          }
   1558                                          else
   1559                                          {
   1560                                              CdcHecDescriptorRemove(hecIdx);
   1561                                              CdcHecDisableCheck(); // disable HEC hardware if no active HECs
   1562          
   1563                                              // Update I/O ports status
   1564                                              // Deactivate ports that no longer participate in active HECs
   1565                                              CdcIoPortsStatusUpdate();
   1566                                          }
   1567          
   1568                                      }
   1569                                      
   1570                                      CdcHecReportStateSend(initiatorPhysAddr, CDC_REPORT_STATE_SHORT_MODE);
   1571                                  }
   1572                                  else if (adjacentFlg == 1) // if two devices are adjacent but not capable for connection
   1573                                  {
   1574                                      // report an error when required ports are HEC incapable
   1575                                      pCdc->deviceStatus.cdcErrorState = CDC_ERRCODE_NOT_SUPPORTED_CAPABILITY;
   1576                                      CdcHecReportStateSend(initiatorPhysAddr, CDC_REPORT_STATE_SHORT_MODE);
   1577                                  }
   1578                              }                  
   1579                              break;
   1580                              
   1581                          case CDCOP_HEC_SET_STATE:
   1582                              numberOfHecs = (pCdcMessage->argCount - 6) / 2; // total number of HECs in the SetState command
   1583                              if ((numberOfHecs < 1) || (numberOfHecs > 4))
   1584                              {
   1585                                  DEBUG_PRINT(CDC_MSG_DBG, ("[CDC_TASK_BASE_SERVICE]: ERROR in SetState message format!\n"));
   1586                                  break;
   1587                              }
   1588                              
   1589                              hecCount = 0; // number of HECs where this device participate (=0 by default)
   1590                              firstPhysAddr = (pCdcMessage->args[3] << 8) + pCdcMessage->args[4];
   1591                              lastPhysAddr  = (pCdcMessage->args[5] << 8) + pCdcMessage->args[6];
   1592          
   1593                              // Activation command
   1594                              if (pCdcMessage->args[7] == CDC_HEC_ACTIVE) 
   1595                              {
   1596                                  bool_t isAtLeastOneDeviceBelongsToHec = false;
   1597                                  
   1598                                  // It can be from 1 to 4 HECs that need to be activated or omited
   1599                                  for (i = 0; i < numberOfHecs; i++) // can be up to 4 terminator's PAs
   1600                                  {
   1601                                      // reply with ReportState message only if the device belongs to the inquired HEC
   1602                                      if (CdcIsDeviceBelongsToHec(firstPhysAddr, lastPhysAddr, pCdc->physAddr))
   1603                                      {
   1604                                          isAtLeastOneDeviceBelongsToHec = true;
   1605                                          
   1606                                          // report no error if all relevant ports are HEC capable
   1607                                          if (CdcCapablePortGet(firstPhysAddr, lastPhysAddr, aInputPortRtIdx, &outputPortRtFlg))
   1608                                          {
   1609                                                  DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: received SetState::Activate message from PA = %04x, (HEC %d)\n", initiatorPhysAddr, (int) i);
   1610          
   1611                                                  // Make sure the HEC is new and hasn't been activated already
   1612                                                  hecIdx = CdcHecIndexGet(initiatorPhysAddr, firstPhysAddr, lastPhysAddr);
   1613                                                  if (hecIdx == 0xFF) // existing HEC not found
   1614                                                  {
   1615                                                      hecCount++; // count this HEC, if this device is a part of it and capable to handle the HEC
   1616                                                  
   1617                                                      // Add new AHEC to the Instance Record
   1618                                                      hecIdx = CdcHecDescriptorAdd(false); 
   1619                                                      if (hecIdx == 0xFF)
   1620                                                      {                                    
   1621                                                          DEBUG_PRINT(CDC_MSG_DBG, ("[CDC_TASK_BASE_SERVICE]: Can't add new HEC descriptor.\n"));
   1622                                                          pCdc->deviceStatus.cdcErrorState = CDC_ERRCODE_OTHER_ERROR; // memory limitation error
   1623                                                      }
   1624                                                      else
   1625                                                      {
   1626                                                          pCdc->aHec[hecIdx].activatorPhysAddr = initiatorPhysAddr;
   1627                                                          pCdc->aHec[hecIdx].firstDevPhysAddr = firstPhysAddr;
   1628                                                          pCdc->aHec[hecIdx].lastDevPhysAddr = lastPhysAddr;
   1629                                                          pCdc->aHec[hecIdx].status.channelState = CDC_AHEC; // Passive device registers AHECs only
   1630                                                          
   1631                                                          CdcAliveDeviceListAdd(hecIdx); // add HEC's activator to Alive List     
   1632                                                          CdcIoPortsActivate(aInputPortRtIdx, outputPortRtFlg); // activate involved ports                                       
   1633                                                      }
   1634                                                  }
   1635                                                  else if ((pCdc->aHec[hecIdx].status.channelState == CDC_AHEC) && (pCdc->deviceStatus.cdcErrorState == CDC_ERRCODE_NO_ERROR))
   1636                                                  {
   1637                                                      hecCount++; // count this compatible AHEC without deactivation
   1638                                                  }
   1639                                                  else
   1640                                                  {
   1641                                                      DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: HEC already exists and it is incompatible state. The HEC must be removed first.\n");
   1642                                                      pCdc->deviceStatus.cdcErrorState = CDC_ERRCODE_INCOMPATIBLE_STATE;
   1643                                                  }
   1644                                                                              
   1645                                          }
   1646                                          else
   1647                                          {
   1648                                              // report an error when required ports are HEC incapable
   1649                                              pCdc->deviceStatus.cdcErrorState = CDC_ERRCODE_NOT_SUPPORTED_CAPABILITY;
   1650                                          }
   1651                                      }
   1652                                      
   1653                                      lastPhysAddr  = (pCdcMessage->args[8 + 2 * i] << 8) + pCdcMessage->args[9 + 2 * i];
   1654                                  }
   1655                                  
   1656                              
   1657                                  // Report activation state
   1658                                  // Only one report is sent for any number of HECs in one SetState command
   1659                                  if (isAtLeastOneDeviceBelongsToHec) // don't report, if not in declared HECs
   1660                                  {
   1661                                      // Activate eHDMI function
   1662                                      if (hecCount > 0)
   1663                                      {
   1664                                          if (pCdc->deviceStatus.hecFuncState < CDC_HEC_STATE_ACTIVE)
   1665                                          {
   1666                                              if (CdcEhdmiHwEnable(true))
   1667                                              {   
   1668                                                  pCdc->deviceStatus.hecFuncState = CDC_HEC_STATE_ACTIVE; 
   1669                                                  CdcAliveTimerSet(10, 50); // set random delay for NotifyAlive messages (10 - 50 sec)                                                                    
   1670                                              }
   1671                                          }
   1672                                      }
   1673          
   1674                                      if (numberOfHecs == 1)
   1675                                      {   
   1676                                          uint8_t hecFuncState = pCdc->deviceStatus.hecFuncState;
   1677                                          // simplified forms of report is used for single HEC activation command
   1678                                          if (pCdc->deviceStatus.cdcErrorState == CDC_ERRCODE_NOT_SUPPORTED_CAPABILITY)
   1679                                          {   // temporary change the device status in order to report "HEC not supported"
   1680                                              // at one or two of the ports
   1681                                              pCdc->deviceStatus.hecFuncState = CDC_HEC_NOT_SUPPORTED;
   1682                                          }
   1683                                          CdcHecReportStateSend(initiatorPhysAddr, CDC_REPORT_STATE_SHORT_MODE);
   1684                                          pCdc->deviceStatus.hecFuncState = hecFuncState; // restore the device status                               
   1685                                      }
   1686                                      else
   1687                                      {   // HEC activation fields must be sent for multi-HEC activation command
   1688                                          CdcHecReportStateSend(initiatorPhysAddr, CDC_REPORT_STATE_MULTIVHEC_MODE);                                     
   1689                                      }
   1690                                  }                        
   1691                              
   1692                              }
   1693          
   1694                              // Deactivation command
   1695                              if (CdcIsDeviceBelongsToHec(firstPhysAddr, lastPhysAddr, pCdc->physAddr) &&
   1696                                  (pCdcMessage->args[7] == CDC_HEC_INACTIVE) && (numberOfHecs == 1)) 
   1697                              {
   1698                                  DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: received SetState::Deactivate message from PA = %04x\n", initiatorPhysAddr);
   1699                              
   1700                                  // Remove the AHEC from the Instance Record
   1701                                  hecIdx = CdcHecIndexGet(initiatorPhysAddr, firstPhysAddr, lastPhysAddr);
   1702                                  if (hecIdx == 0xFF)
   1703                                  {                                    
   1704                                      DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: Can't find existing HEC descriptor to delete.\n");
   1705                                  }
   1706                                  else
   1707                                  {
   1708                                      CdcAliveDeviceListRemove(hecIdx); // remove devices from Alive List (if possible)                                    
   1709                                      CdcHecDescriptorRemove(hecIdx);
   1710                                      CdcHecDisableCheck(); // disable HEC hardware if no active HECs
   1711                              
   1712                                      // Update I/O ports status
   1713                                      // Deactivate ports that no longer participate in active HECs
   1714                                      CdcIoPortsStatusUpdate();
   1715                                  }
   1716                                  // No report is needed for deactivation command                               
   1717                              }
   1718                              
   1719                              break;
   1720                              
   1721                          case CDCOP_HEC_REQUEST_DEACTIVATION:
   1722          
   1723                              if (pCdcMessage->argCount != 9)
   1724                              {
   1725                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: ERROR in DeactivationRequest message: wrong length!\n");
   1726                                  break;
   1727                              }
   1728                              
   1729                              // Only Activator of deactivated AHEC must respond to the message
   1730                              targetPhysAddr = (pCdcMessage->args[3] << 8) + pCdcMessage->args[4]; // activator's physical address
   1731                              firstPhysAddr = (pCdcMessage->args[5] << 8) + pCdcMessage->args[6];
   1732                              lastPhysAddr  = (pCdcMessage->args[7] << 8) + pCdcMessage->args[8]; 
   1733                              
   1734                              // reply with SetState message only if the device is activator of the registered AHEC
   1735                              // and initiating device belongs to the HEC it requests to deactivate 
   1736                              hecIdx = CdcHecIndexGet(targetPhysAddr, firstPhysAddr, lastPhysAddr);
   1737                              if ((hecIdx != 0xFF) && (pCdc->aHec[hecIdx].status.channelState == CDC_AHEC) &&
   1738                                   CdcIsDeviceBelongsToHec(firstPhysAddr, lastPhysAddr, initiatorPhysAddr))
   1739                              {
   1740                                  DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: received RequestDeactivation message from PA = %04x\n", initiatorPhysAddr);
   1741                                  SiiCdcDeviceDisconnect(false, targetPhysAddr, firstPhysAddr, lastPhysAddr); 
   1742                              }
   1743                              break;
   1744                              
   1745                          case CDCOP_HEC_NOTIFY_ALIVE:
   1746                              // find out if the initiator is in the list of monitored devices
   1747                              // reset Alive Time counter to 140 sec for the initiator
   1748                              if (CdcAliveDeviceListTimeReset(initiatorPhysAddr) == true) // device has been found in AliveDevice List
   1749                              {                            
   1750                                  DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: received NotifyAlive message from PA = %04x\n", initiatorPhysAddr);
   1751                              }
   1752                              break;
   1753                              
   1754                          case CDCOP_HEC_DISCOVER:
   1755                              // reply with ReportState message
   1756                              if (pCdc->deviceStatus.hecFuncState != CDC_HEC_FUNC_NOT_SUPPORTED)
   1757                              {
   1758                                  DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: received Discover message from PA = %04x\n", initiatorPhysAddr);
   1759                                  CdcHecReportStateSend(initiatorPhysAddr, CDC_REPORT_STATE_DISCOVER_MODE);
   1760                              }
   1761                              break;
   1762                              
   1763                          case CDCOP_HPD_SET_STATE:
   1764          
   1765                              if (pCdcMessage->argCount != 4)
   1766                              {
   1767                                  DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: ERROR in HpdSetState message: wrong length!\n");
   1768                                  break;
   1769                              }
   1770                              
   1771                              // Source replies with HPD ReportState message if the message came from the port of adjacent Sink
   1772                              // that is connected to this Source
   1773                              inputPortIndex = (pCdcMessage->args[3] >> 4) & 0x0F; // index of an input port that sent the HPD SetState command
   1774                              if (CdcIsLinkedDirectly(initiatorPhysAddr, pCdc->physAddr, inputPortIndex))
   1775                              {
   1776                                  DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: received HPD SetState message from PA = %04x\n", initiatorPhysAddr);
   1777                                  // set HPD state of the output port
   1778                                  pCdc->ports.output.hpdState = pCdcMessage->args[3] & 0x0F;
   1779                                  CdcHpdReportStateSend();                            
   1780                                  cdcFeedbackMsg = CDC_FB_MSG_HPD_STATE_CHANGED;
   1781                              }
   1782                              break;
   1783                              
   1784                          case CDCOP_HPD_REPORT_STATE:
   1785                              // Make sure the HPD ReportState comes from adjacent Source over currently selected input port
   1786                              // during HPD Signalling Task execution on the waiting stage
   1787                              if ((pCdc->cdcTaskFlags & CDC_TASK_HPD_SIGNAL) && (pCdc->cdcTaskState == CDC_TASK_HPD_SIGNAL_STATE_RESPONSE_WAIT))
   1788                              {
   1789                                  if (CdcIsLinkedDirectly(pCdc->physAddr, initiatorPhysAddr, pCdc->currentPortIdx))
   1790                                  {           
   1791                                      DEBUG_PRINT(MSG_STAT, "[CDC_TASK_BASE_SERVICE]: received HPD ReportState message from PA = %04x\n", initiatorPhysAddr);
   1792                                      pCdc->cdcTaskState = CDC_TASK_HPD_SIGNAL_STATE_REPORT_RESULTS; // break waiting
   1793                                  }
   1794                              }
   1795                              break;
   1796                      }
   1797                  }
   1798                  else
   1799                  {
   1800          //            DEBUG_PRINT(CDC_MSG_DBG, "[CDC_TASK_BASE_SERVICE]: non-CDC CEC opcode or non-broadcast destination\n");
   1801                      cdcFeedbackMsg = CDC_FB_MSG_ERR_NONCDC_CMD;
   1802                  }
   1803          
   1804              }
   1805              else
   1806              {
   1807                  if ((pCdc->numberOfAliveDev > 0) && (pCdc->deviceStatus.hecFuncState >= CDC_HEC_STATE_ACTIVE))
   1808                  {                
   1809                      // if it's time to send alive notification, do it also
   1810                      // if participating in AHECs (either as activator or passive device),
   1811                      // and if Alive Device list has at least one entry     
   1812                      if (CdcIsTimeCounterExpired(&pCdc->aliveNtfDelayCount)) // if timer expired
   1813                      {
   1814                          CdcHecNotifyAliveSend();
   1815                          CdcAliveTimerSet(60, 62); // send consecutive notification in 60-65 seconds
   1816                          DEBUG_PRINT(MSG_STAT, ("[CDC_TASK_BASE_SERVICE]: sent NotifyAlive message.\n"));
   1817                      }
   1818                  }
   1819                  
   1820              }
   1821          
   1822              return cdcFeedbackMsg;        
   1823          }
   1824          
   1825          
   1826          //-------------------------------------------------------------------------------------------------
   1827          //! @brief      Task dispatching function
   1828          //!
   1829          //!             Shall be called periodically.
   1830          //!             Using of SiiCdcNextInvocationTimeGet() helps to figure out
   1831          //!             exact recall time that can vary depending on current task status.
   1832          //!             Alternatively, simple periodic polling would work as well;
   1833          //!             in the case of polling, CDC_MIN_RECALL_TIME_MS is a suggested
   1834          //!             recall time.
   1835          //!
   1836          //! @param[in]  sysTimerCountMs - current value of the system time counter (in milliseconds)
   1837          //! @param[in]  pCdcMessage     - pointer to a pending CDC message or 0,
   1838          //!                               if there is no message awaiting
   1839          //!
   1840          //! @return     Feedback message to the caller (Task status or error reports)
   1841          //-------------------------------------------------------------------------------------------------
   1842          
   1843          uint8_t SiiCdcTaskProcess(uint16_t sysTimerCountMs, SiiCpiData_t *pCdcMessage)
   1844          {
   1845              uint8_t  cdcFeedbackMsg = CDC_FB_MSG_NONE;
   1846              uint16_t cdcTaskFlagsMasked;
   1847              uint16_t devIdx;    
   1848          
   1849          
   1850              // Keep all tasks frozen if the Base task is off
   1851              if (pCdc->cdcTaskFlags & CDC_TASK_BASE_SERVICE)
   1852              {
   1853          
   1854                  // Update time reading variables
   1855                  pCdc->sysTimerCountPrvMs = pCdc->sysTimerCountCurMs; // memorise previous timer reading
   1856                  pCdc->sysTimerCountCurMs = sysTimerCountMs; // set current timer reading  
   1857                  
   1858                  if (((pCdc->cdcTaskFlags & CDC_TASK_MASK_ALL_BUT_BASE) == 0) && (pCdcMessage == 0))
   1859                  {
   1860                      // Initialize the recall time counter by maximum possible value
   1861                      // in order to ensure rare recalls of the task handler when tasks are inactive
   1862                      CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MAX_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);
   1863                  }
   1864                  else
   1865                  {   // Ensure fast recall if there are active tasks or pending messages as they could 
   1866                      // require immediate subsequent action (e.g., launching of active tasks) 
   1867                      // Actual recall time will be corrected by task internal timer updates, if any
   1868                      CdcTimeCounterSet(CDC_TIME_MS2TCK(CDC_MIN_RECALL_TIME_MS), &pCdc->cdcRecallTimeCount);        
   1869                  }
   1870          
   1871                  if ((pCdc->numberOfAliveDev > 0) && (pCdc->deviceStatus.hecFuncState >= CDC_HEC_STATE_ACTIVE))
   1872                  {                            
   1873                      CdcTimeCounterUpdate(&pCdc->aliveNtfDelayCount);
   1874                  }
   1875          
   1876                  // Update AliveDevice List times and react on timeouts
   1877                  if ((devIdx = CdcAliveDeviceListTimeUpdate()) != 0xFFFF) // if timeout detected for some device
   1878                  {
   1879                      // Disconnect all HECs that include the failed device
   1880                      // Make sure other tasks are inactive, leave the timout pending otherwise
   1881                      CdcLostDeviceDisconnect(pCdc->aAliveDevice[devIdx].physAddr);
   1882                  }
   1883          
   1884                  // Update the Discovery repetition timer
   1885                  CdcTimeCounterUpdate(&pCdc->cdcDiscoveryTimeCount);
   1886                  
   1887                  // Do one task at a time. Tasks shall never be running concurrently except the Base Service that
   1888                  // can run in background of another task, not corrupting its context.
   1889                  // Base Service has highest priority if a CDC message is pending and lowest priority otherwise
   1890                  
   1891                  cdcTaskFlagsMasked = (pCdc->cdcTaskFlags & pCdc->cdcTaskMask);
   1892          
   1893                  if (pCdcMessage != 0) // CDC message is pending
   1894                  {   
   1895                      cdcFeedbackMsg = CdcTaskBase(pCdcMessage);      
   1896                  }
   1897                  else
   1898                  {
   1899                      if (cdcTaskFlagsMasked & CDC_TASK_HOSTS_SEARCH)
   1900                      {
   1901                          cdcFeedbackMsg = CdcTaskDiscover();
   1902                      }
   1903                      else if (cdcTaskFlagsMasked & CDC_TASK_CONNECT)
   1904                      {
   1905                          cdcFeedbackMsg = CdcTaskConnect();        
   1906                      }
   1907                      else if (cdcTaskFlagsMasked & CDC_TASK_DISCONNECT)
   1908                      {
   1909                          cdcFeedbackMsg = CdcTaskDisconnect();
   1910                      }
   1911          
   1912                      else if (cdcTaskFlagsMasked & CDC_TASK_CONNECT_ADJACENT)
   1913                      {
   1914                          cdcFeedbackMsg = CdcTaskConnectAdjacent();        
   1915                      }                
   1916                      else if (cdcTaskFlagsMasked & CDC_TASK_DISCONNECT_ALL)
   1917                      {
   1918                          cdcFeedbackMsg = CdcTaskDisconnectAll();
   1919                      }
   1920                      else if (cdcTaskFlagsMasked & CDC_TASK_DISCONNECT_LOST)
   1921                      {
   1922                          cdcFeedbackMsg = CdcTaskDisconnectLost();
   1923                      }   
   1924                      else if (cdcTaskFlagsMasked & CDC_TASK_HPD_SIGNAL)
   1925                      {
   1926          #if (IS_RX == ENABLE)
   1927                          cdcFeedbackMsg = CdcTaskHpdSignal();
   1928          #else
   1929                          cdcFeedbackMsg = CDC_FB_MSG_ERROR;
   1930          #endif
   1931                      }
   1932                      else if (cdcTaskFlagsMasked & CDC_TASK_HPD_CAPAB_VERIF)
   1933                      {
   1934                          cdcFeedbackMsg = CdcTaskHpdCapabilityVerification();
   1935                      }
   1936                      // Base Task can't be masked and can run in background of the other active task if incoming CDC message is pending
   1937                      else
   1938                      {
   1939                          cdcFeedbackMsg = CdcTaskBase(0);
   1940                      }
   1941                  }
   1942                  
   1943              }
   1944              
   1945              return cdcFeedbackMsg;
   1946          }
   1947          
   1948          
   1949          //-------------------------------------------------------------------------------------------------
   1950          //! @brief      Returns longest possible time delay before the next invocation
   1951          //!             of the SiiCdcTaskProcess() function
   1952          //!
   1953          //!             This function can be used to set a countdown timer and call
   1954          //!             the SiiCdcTaskProcess() on the timer's expiration event unless
   1955          //!             new CDC message is pending
   1956          //!
   1957          //! @param[in]  sysTimerCountMs - current value of the system time counter (in milliseconds)
   1958          //!
   1959          //! @return     time in milliseconds
   1960          //-------------------------------------------------------------------------------------------------
   1961          
   1962          uint16_t SiiCdcNextInvocationTimeGet(uint16_t sysTimerCountMs)
   1963          {
   1964              uint32_t totalDelayMs;
   1965              uint16_t invDelayMs;
   1966          
   1967              if (CdcIsTimeCounterExpired(&pCdc->cdcRecallTimeCount))
   1968              {
   1969                  totalDelayMs = 0;
   1970              }
   1971              else
   1972              {
   1973                  totalDelayMs =  (uint32_t) pCdc->cdcRecallTimeCount.tRov * 0x10000 /* 2^16 */ + 
   1974                                  (uint32_t) pCdc->cdcRecallTimeCount.tRes * CDC_TIME_TCK_MS - (uint32_t) sysTimerCountMs;
   1975              }
   1976              
   1977              // Apply limits to recall delay
   1978              if (totalDelayMs < CDC_MIN_RECALL_TIME_MS)
   1979              {
   1980                  invDelayMs = CDC_MIN_RECALL_TIME_MS;
   1981              }
   1982              else if (totalDelayMs > CDC_MAX_RECALL_TIME_MS)
   1983              {
   1984                  invDelayMs = CDC_MAX_RECALL_TIME_MS;        
   1985              }
   1986              else
   1987              {
   1988                  invDelayMs = (uint16_t) totalDelayMs;
   1989              }
   1990          
   1991              //DEBUG_PRINT(CDC_MSG_DBG, "SiiCdcNextInvocationTimeGet(): -- recall in -- %d ms\n", invDelayMs);
   1992                
   1993              return invDelayMs;   
   1994          }
   1995          
   1996          
   1997          //-------------------------------------------------------------------------------------------------
   1998          //! @brief      Launches CDC Active and Passive Services
   1999          //!
   2000          //!             Active CDC service maintains operation of all activated by this
   2001          //!             device HECs. Passive CDC Service maintains responsiveness to
   2002          //!             CDC requests and sending Alive messages (when participating in
   2003          //!             AHECs)
   2004          //!
   2005          //! @retval     true, if the task can't be scheduled,
   2006          //! @retval     false - otherwise
   2007          //-------------------------------------------------------------------------------------------------
   2008          
   2009          bool_t SiiCdcSrvStart(void)
   2010          {
   2011              bool_t errStatus = false;
   2012              
   2013              // check if Passive or Active services can be started
   2014              if (pCdc->deviceStatus.hecFuncState != CDC_HEC_FUNC_NOT_SUPPORTED)
   2015              {
   2016                  pCdc->cdcTaskFlags |= CDC_TASK_BASE_SERVICE;        
   2017              }
   2018              else
   2019              {       
   2020                  errStatus = true;        
   2021                  DEBUG_PRINT(CDC_MSG_ALWAYS, "WARNING in SiiCdcSrvStart(): Services can't be started.\n");
   2022              }
   2023              
   2024              return errStatus;
   2025          }
   2026          
   2027          
   2028          //-------------------------------------------------------------------------------------------------
   2029          //! @brief      Stops CDC Active and Passive Services
   2030          //-------------------------------------------------------------------------------------------------
   2031          
   2032          void SiiCdcSrvStop(void)
   2033          {
   2034              pCdc->cdcTaskFlags &= ~CDC_TASK_BASE_SERVICE;
   2035          }
   2036          
   2037          
   2038          //-------------------------------------------------------------------------------------------------
   2039          //! @brief      Retrieves status of a task
   2040          //!
   2041          //! @retval     true if the task is active,
   2042          //! @retval     false - otherwise
   2043          //-------------------------------------------------------------------------------------------------
   2044          
   2045          bool_t CdcTaskStatusGet(uint16_t cdcTaskId)
   2046          {
   2047              return (pCdc->cdcTaskFlags & cdcTaskId);
   2048          }
   2049          
   2050          
   2051          //-------------------------------------------------------------------------------------------------
   2052          //! @brief      Discovery of all devices having HEC capability and supports Host
   2053          //!             or External network function throughout entire HDMI network
   2054          //!
   2055          //!             Discovery process shall not be conducted more frequently than
   2056          //!             once in 3 minutes. This rule is enforced in this function; it
   2057          //!             will return non-zero, if called before 3 minutes since the last call
   2058          //!
   2059          //! @retval     0        - if the search task is scheduled successfully,
   2060          //! @retval     [1-0xFE] - the number of seconds before next permitted Discovery,
   2061          //! @retval     0xFF     - other error
   2062          //-------------------------------------------------------------------------------------------------
   2063          
   2064          uint8_t SiiCdcSrvHostsFind(void)
   2065          {
   2066              uint16_t timeLeftSec = 0;
   2067                  
   2068              if (CdcIsTimeCounterExpired(&pCdc->cdcDiscoveryTimeCount))
   2069              {        
   2070                  // schedule immediate start of the search
   2071                  pCdc->cdcTaskFlags |= CDC_TASK_HOSTS_SEARCH;
   2072              }
   2073              else
   2074              {
   2075                  timeLeftSec = CdcTimeCounterLeftSecGet(&pCdc->cdcDiscoveryTimeCount);
   2076                  DEBUG_PRINT(CDC_MSG_ALWAYS, "WARNING: Discovery function will be available after %d seconds\n", timeLeftSec);
   2077              }
   2078          
   2079              if (timeLeftSec < 0xFF)
   2080              {
   2081                  return (uint8_t) timeLeftSec;
   2082              }
   2083              else
   2084              {
   2085                  return 0xFF; // error code
   2086              }
   2087          }
   2088          
   2089          
   2090          //-------------------------------------------------------------------------------------------------
   2091          //! @brief      Returns physical address of a nearest (HEC of a minimum length)
   2092          //!             device from the found list that has external network capability (ENC)
   2093          //!
   2094          //!             This function can be used in order to find shortest path to
   2095          //!             the Internet access point
   2096          //!
   2097          //! @return     Physical Address of a nearest external network capable device,
   2098          //! @retval     0xFFFF - if ENC device wasn't found
   2099          //-------------------------------------------------------------------------------------------------
   2100          
   2101          uint16_t SiiCdcNearestEncDeviceGet(void)
   2102          {
   2103              uint8_t  i;
   2104              uint8_t  iMin = 0;
   2105              uint8_t  hecLen;
   2106              uint8_t  hecLenMin = 0xFF;
   2107              
   2108              for (i = 0; i < pCdc->numberOfFoundHosts; i++)
   2109              {
   2110                  if (pCdc->cdcFoundHostsList[i].devStat.encFuncState != CDC_ENC_NOT_SUPPORTED)
   2111                  {
   2112                      hecLen = CdcHecLengthGet(pCdc->physAddr, pCdc->cdcFoundHostsList[i].physAddr); 
   2113                      if (hecLen < hecLenMin)
   2114                      {
   2115                          hecLenMin = hecLen;
   2116                          iMin = i;
   2117                      }
   2118                  }
   2119              }
   2120          
   2121              if (hecLenMin != 0xFF)   
   2122              {
   2123                  return pCdc->cdcFoundHostsList[iMin].physAddr;
   2124              }
   2125              else
   2126              {
   2127                  return 0xFFFF;
   2128              }
   2129          }
   2130          
   2131          
   2132          //-------------------------------------------------------------------------------------------------
   2133          //! @brief      Establishes connection to a specified device or group of devices
   2134          //!
   2135          //!             This function should be used after discovery process, so that the
   2136          //!             cdcFoundHostsList[] list isn't empty. It must be used by Activator
   2137          //!             of the HEC
   2138          //!
   2139          //! @param[in]  isConnectEntireList - if true, will connect all devices from the
   2140          //!                                   cdcFoundHostsList[] that have selection bit
   2141          //!                                   (hostInfo.isSelected) asserted. The lastPhysAddr
   2142          //!                                   parameter is ignored in this case.
   2143          //!                                   if false, only one device having specified
   2144          //!                                   physical address will be connected.
   2145          //! @param[in]  firstPhysAddr       - physical address of a first HEC device to be
   2146          //!                                   connected to the last device or devices in
   2147          //!                                   the cdcFoundHostsList[]. Typically,
   2148          //!                                   the first device is an activator of the HEC
   2149          //! @param[in]  lastPhysAddr        - physical address of a second device to be
   2150          //!                                   connected to the first device
   2151          //!
   2152          //! @retval     true, if the connect task can't be scheduled,
   2153          //! @retval     false - otherwise
   2154          //-------------------------------------------------------------------------------------------------
   2155          
   2156          bool_t SiiCdcDeviceConnect(bool_t isConnectEntireList, uint16_t firstPhysAddr, uint16_t lastPhysAddr)
   2157          {
   2158              uint8_t i;
   2159              uint8_t idx;
   2160              bool_t  errStatus = false;
   2161          
   2162              // check if this device is HEC capable
   2163              if (pCdc->deviceStatus.hecFuncState == CDC_HEC_FUNC_NOT_SUPPORTED)
   2164              {
   2165                  DEBUG_PRINT(CDC_MSG_ALWAYS, "ERROR in SiiCdcDeviceConnect(): Device is HEC incapable and can't initiate HEC communications\n");
   2166                  errStatus = true;
   2167              }
   2168              else
   2169              {
   2170                  // check if the found device list has the device entry(ies)
   2171                  if ((isConnectEntireList && pCdc->numberOfFoundHosts > 0) || (!isConnectEntireList))
   2172                  {
   2173                      // create new HEC descriptor(s) and label the HEC as PHEC 
   2174                      if (isConnectEntireList)
   2175                      {
   2176                          pCdc->connectSettings.isMultHecMode = true;  // use multi-HEC activation mode for more than 1 device
   2177                          
   2178                          for (i = 0; i < pCdc->numberOfFoundHosts; i++)
   2179                          {   
   2180                              // connect only selected devices having unequal PAs
   2181                              if (pCdc->cdcFoundHostsList[i].hostInfo.isSelected && (firstPhysAddr != pCdc->cdcFoundHostsList[i].physAddr))
   2182                              {                        
   2183                                  // check if activator itself can be a part of the new HEC, if it belongs to the HEC
   2184                                  if (CdcIsCapableForHec(pCdc->physAddr, pCdc->cdcFoundHostsList[i].physAddr, false))
   2185                                  {
   2186                                      if (CdcHecIndexGet(pCdc->physAddr, firstPhysAddr, pCdc->cdcFoundHostsList[i].physAddr) == 0xFF) // make sure that new HEC is unique
   2187                                      {
   2188                                          if ((idx = CdcHecDescriptorAdd(true)) != 0xFF)
   2189                                          {                    
   2190                                              pCdc->aHec[idx].activatorPhysAddr   = pCdc->physAddr;
   2191                                              pCdc->aHec[idx].firstDevPhysAddr    = firstPhysAddr; 
   2192                                              pCdc->aHec[idx].lastDevPhysAddr     = pCdc->cdcFoundHostsList[i].physAddr;
   2193                                              pCdc->aHec[idx].status.channelState = CDC_PHEC; 
   2194                                          }
   2195                                          else
   2196                                          {
   2197                                              errStatus = true;
   2198                                              break;
   2199                                          } 
   2200                                      }
   2201                                      // if HEC isn't unique, don't rise error flag because connection should be already established
   2202                                  }
   2203                                  else
   2204                                  {
   2205                                      DEBUG_PRINT(CDC_MSG_ALWAYS, "WARNING in SiiCdcDeviceConnect(): Device is incapable to be an activator for a HEC\n");
   2206                                  }
   2207                              }
   2208                          }
   2209                      }
   2210                      else // one HEC
   2211                      {            
   2212                          pCdc->connectSettings.isMultHecMode = false;  // use single-HEC activation mode for 1 device case
   2213                          
   2214                          // check if activator itself can be a part of the new HEC, if it belongs to the HEC
   2215                          if (CdcIsCapableForHec(firstPhysAddr, lastPhysAddr, false))
   2216                          {
   2217                              if (CdcHecIndexGet(pCdc->physAddr, firstPhysAddr, lastPhysAddr) == 0xFF) // make sure that new HEC is unique
   2218                              {
   2219                                  if ((idx = CdcHecDescriptorAdd(true)) != 0xFF)
   2220                                  {                
   2221                                      pCdc->aHec[idx].activatorPhysAddr   = pCdc->physAddr;
   2222                                      pCdc->aHec[idx].firstDevPhysAddr    = firstPhysAddr;
   2223                                      pCdc->aHec[idx].lastDevPhysAddr     = lastPhysAddr;
   2224                                      pCdc->aHec[idx].status.channelState = CDC_PHEC; 
   2225                                  }
   2226                                  else
   2227                                  {
   2228                                      errStatus = true;
   2229                                  }
   2230                              }
   2231                          }
   2232                          else
   2233                          {
   2234                              DEBUG_PRINT(CDC_MSG_ALWAYS, "WARNING in SiiCdcDeviceConnect(): Device is incapable to be an activator for a HEC\n");
   2235                          }
   2236                          
   2237                      }
   2238          
   2239                      // schedule immediate start of connection task
   2240                      if (errStatus == false) 
   2241                      {
   2242                          pCdc->cdcTaskFlags |= CDC_TASK_CONNECT;
   2243                      }
   2244                  }
   2245                  else
   2246                  {
   2247                      errStatus = true; // can't run the task
   2248                  }
   2249              }
   2250              
   2251              return errStatus;
   2252          }
   2253          
   2254          
   2255          //-------------------------------------------------------------------------------------------------
   2256          //! @brief      Establishes connection to a specified device using "HEC control
   2257          //!             to Adjacent Device" method.
   2258          //!
   2259          //! @param[in]  adjacentPhysAddr  - physical address of an adjacent device
   2260          //!
   2261          //! @retval     true, if the connect task can't be scheduled,
   2262          //! @retval     false - otherwise
   2263          //-------------------------------------------------------------------------------------------------
   2264          
   2265          bool_t SiiCdcDeviceAdjacentConnect(uint16_t adjacentPhysAddr)
   2266          {
   2267              uint8_t idx;    
   2268              bool_t  errStatus = false;
   2269              
   2270              // check if this device is HEC capable
   2271              if (pCdc->deviceStatus.hecFuncState == CDC_HEC_FUNC_NOT_SUPPORTED)
   2272              {
   2273                  DEBUG_PRINT(CDC_MSG_ALWAYS, "ERROR in SiiCdcDeviceAdjacentConnect(): Device is HEC incapable and can't initiate HEC communications\n");
   2274                  errStatus = true;
   2275              }
   2276              else
   2277              {
   2278                  // check if activator itself can be a part of the new HEC (strict check)
   2279                  if (CdcIsCapableForHec(pCdc->physAddr, adjacentPhysAddr, true))
   2280                  {
   2281                      if (CdcHecIndexGet(pCdc->physAddr, pCdc->physAddr, adjacentPhysAddr) == 0xFF) // make sure that new HEC is unique
   2282                      {
   2283                          if ((idx = CdcHecDescriptorAdd(true)) != 0xFF)
   2284                          {                
   2285                              pCdc->aHec[idx].activatorPhysAddr   = pCdc->physAddr;
   2286                              pCdc->aHec[idx].firstDevPhysAddr    = pCdc->physAddr;
   2287                              pCdc->aHec[idx].lastDevPhysAddr     = adjacentPhysAddr;
   2288                              pCdc->aHec[idx].status.channelState = CDC_PHEC; 
   2289                              pCdc->aHec[idx].status.isAdjacent   = true;
   2290          
   2291                              pCdc->currentHecIdx = idx;
   2292                              pCdc->cdcTaskFlags |= CDC_TASK_CONNECT_ADJACENT; // schedule immediate start of connection task                   
   2293                          }
   2294                          else
   2295                          {
   2296                              errStatus = true;
   2297                          }
   2298                      }
   2299                      else
   2300                      {
   2301                          DEBUG_PRINT(CDC_MSG_ALWAYS, ("WARNING in SiiCdcDeviceAdjacentConnect(): HEC already exist.\n"));
   2302                          
   2303                      }
   2304                  }
   2305                  else
   2306                  {
   2307                       DEBUG_PRINT(CDC_MSG_ALWAYS, "WARNING in SiiCdcDeviceAdjacentConnect(): Device is incapable to be an activator for a HEC\n");
   2308                  }
   2309               
   2310               }
   2311              
   2312              
   2313              return errStatus;    
   2314          }
   2315          
   2316          
   2317          //-------------------------------------------------------------------------------------------------
   2318          //! @brief      Terminates connection to a specified device or all connected devices
   2319          //!
   2320          //!             This function can be used by Activator of the HEC
   2321          //!
   2322          //! @param[in]  isDisconnectAll    - if true, will close all active HECs. The second & third
   2323          //!                                  parameters are ignored in this case.
   2324          //!                                  If false, only one device having specified
   2325          //!                                  physical address will be disconnected.
   2326          //! @param[in]  actPhysAddr        - physical address of HEC's activator
   2327          //! @param[in]  firstPhysAddr      - physical address of a first HEC device
   2328          //! @param[in]  lastPhysAddr       - physical address of a second device in HEC
   2329          //!
   2330          //! @retval     true, if the disconnect task can't be scheduled,
   2331          //! @retval     false - otherwise
   2332          //-------------------------------------------------------------------------------------------------
   2333          
   2334          bool_t SiiCdcDeviceDisconnect(bool_t isDisconnectAll, uint16_t actPhysAddr, uint16_t firstPhysAddr, uint16_t lastPhysAddr)
   2335          {
   2336              bool_t  errStatus = false;
   2337          
   2338              if (isDisconnectAll)
   2339              {       
   2340                  // schedule immediate start of disconnection task 
   2341                  pCdc->cdcTaskFlags |= CDC_TASK_DISCONNECT_ALL;
   2342              }
   2343              else // disconnect only one device 
   2344              {
   2345                  pCdc->currentHecIdx = CdcHecIndexGet(actPhysAddr, firstPhysAddr, lastPhysAddr);
   2346          
   2347                  if (pCdc->currentHecIdx < 0xFF)
   2348                  {
   2349                      if (pCdc->aHec[pCdc->currentHecIdx].status.channelState > CDC_PHEC)
   2350                      {
   2351                          // schedule immediate start of disconnection task 
   2352                          pCdc->cdcTaskFlags |= CDC_TASK_DISCONNECT;
   2353                      }
   2354                      else
   2355                      {
   2356                          errStatus = true; // HEC isn't active            
   2357                      }
   2358                  }
   2359                  else
   2360                  {
   2361                      errStatus = true; // the AHEC wasn't found 
   2362                  }
   2363              }
   2364          
   2365              return errStatus;
   2366          }
   2367          
   2368          
   2369          //-------------------------------------------------------------------------------------------------
   2370          //! @brief      Terminates connection to a specified adjacent device
   2371          //!
   2372          //!             This function should be used by Activator of the HEC, however,
   2373          //!             passive device can reset it's connection to the adjacent
   2374          //!             device (activator) when it has been physically disconnected
   2375          //!
   2376          //! @param[in]  adjacentPhysAddr - physical address of an adjacent device
   2377          //!
   2378          //! @retval     true, if the disconnect task can't be scheduled,
   2379          //! @retval     false - otherwise
   2380          //-------------------------------------------------------------------------------------------------
   2381          
   2382          bool_t SiiCdcDeviceAdjacentDisconnect(uint16_t adjacentPhysAddr)
   2383          {
   2384              bool_t  errStatus = false;
   2385          
   2386              pCdc->currentHecIdx = CdcHecIndexGet(pCdc->physAddr, pCdc->physAddr, adjacentPhysAddr);
   2387          
   2388              if (pCdc->currentHecIdx < 0xFF)
   2389              {
   2390                  if ((pCdc->aHec[pCdc->currentHecIdx].status.isAdjacent == true) &&
   2391                      (pCdc->aHec[pCdc->currentHecIdx].status.channelState > CDC_PHEC))
   2392                  {
   2393                      // disconnection of adjacent device doesn't require state reporting,
   2394                      // therefore, non-task approach is relevant. Just send disconnection CDC command
   2395                      CdcHecSetStateAdjacentSend(CDC_HEC_INACTIVE, pCdc->currentHecIdx);
   2396                      
   2397                      CdcHecDescriptorRemove(pCdc->currentHecIdx); // release resources for HEC
   2398                      CdcHecDisableCheck(); // disable HEC hardware if no active HECs
   2399                      CdcIoPortsStatusUpdate(); // deactivate ports involved in the deactivated HEC            
   2400                  }
   2401                  else
   2402                  {
   2403                      errStatus = true; // HEC isn't active or activated by control to adjacent device           
   2404                  }
   2405              }
   2406              else
   2407              {   // check if Adjacent Device is the activator of a HEC 
   2408                  pCdc->currentHecIdx = CdcHecIndexGet(adjacentPhysAddr, pCdc->physAddr, adjacentPhysAddr);
   2409                  
   2410                  if (pCdc->currentHecIdx < 0xFF)
   2411                  {
   2412                      if (pCdc->aHec[pCdc->currentHecIdx].status.isAdjacent == true)
   2413                      {
   2414                          // force the HEC disconnection
   2415                          CdcHecDescriptorRemove(pCdc->currentHecIdx); // release resources for HEC
   2416                          CdcHecDisableCheck(); // disable HEC hardware if no active HECs
   2417                          CdcIoPortsStatusUpdate(); // deactivate ports involved in the deactivated HEC 
   2418                      }
   2419                      else
   2420                      {
   2421                          errStatus = true; // AHEC isn't activated by control to adjacent device 
   2422                      }
   2423                  }
   2424                  else
   2425                  {
   2426                      errStatus = true; // the AHEC wasn't found 
   2427                  }
   2428              }
   2429          
   2430              return errStatus;
   2431          }
   2432          
   2433          //-------------------------------------------------------------------------------------------------
   2434          //! @brief      Deactivates all AHECs that include a device having
   2435          //!             given physical address.
   2436          //!
   2437          //! @param[in]  physAddr - physical address of the failed device
   2438          //-------------------------------------------------------------------------------------------------
   2439          
   2440          static void CdcLostDeviceDisconnect(uint16_t physAddr)
   2441          {
   2442              if ((pCdc->cdcTaskFlags & CDC_TASK_MASK_ALL_BUT_BASE) == 0)
   2443              {
   2444                      // disconnect only one device (other timeouts will be pending)
   2445                      pCdc->aliveDevPhysAddr = physAddr;
   2446                      // schedule immediate start of disconnection task
   2447                      pCdc->cdcTaskFlags |= CDC_TASK_DISCONNECT_LOST;
   2448              }
   2449          }
   2450          
   2451          //-------------------------------------------------------------------------------------------------
   2452          //! @brief      Determines if the specified port is an active CDC port
   2453          //!
   2454          //! @param[in]  isOutput  - true, if output port is addressed
   2455          //! @param[in]  portIndex - input port index (zero-based)
   2456          //!
   2457          //! @retval     true if HEC channel is attached to the specified HDMI port and is active,
   2458          //! @retval     false if HDMI port has no active HEC channels
   2459          //-------------------------------------------------------------------------------------------------
   2460          
   2461          bool_t SiiCdcPortIsActive(const bool_t isOutput, const uint8_t portIndex)
   2462          {
   2463              bool_t    isActive = false;
   2464          
   2465              if (( isOutput == true) && (pCdc->ports.numberOfOutputs != 0))
   2466              {
   2467                  isActive = (pCdc->ports.output.hecSupport == true ) &&
   2468                             (pCdc->ports.output.hecActive == true );
   2469              }
   2470              else if ((isOutput == false) && (pCdc->ports.numberOfInputs > portIndex)) // inputs
   2471              {
   2472                  isActive = (pCdc->ports.input[portIndex].hecSupport == true ) &&
   2473                             (pCdc->ports.input[portIndex].hecActive == true );
   2474              }
   2475          
   2476              return isActive;
   2477          }
   2478          
   2479          
   2480          #if (IS_RX == ENABLE)
   2481          //-------------------------------------------------------------------------------------------------
   2482          //! @brief      Sets new HPD state to selected port and sends an HPD State
   2483          //!             message to HDMI Source device
   2484          //!
   2485          //!             This function shall be used by an HDMI Sink device
   2486          //!
   2487          //! @param[in]  inputPortIndex - zero based input port number
   2488          //! @param[in]  hpdState       - HPD state of the input port
   2489          //!
   2490          //! @retval     true, if the HPD signaling task can't be scheduled,
   2491          //! @retval     false - otherwise
   2492          //-------------------------------------------------------------------------------------------------
   2493          
   2494          bool_t SiiCdcHpdSetState(uint8_t inputPortIndex, CdcHpdState_t hpdState)
   2495          {
   2496              bool_t  errStatus = true;
   2497              
   2498              if (inputPortIndex < pCdc->ports.numberOfInputs)
   2499              {
   2500                  if (pCdc->ports.input[inputPortIndex].hecSupport != CDC_HEC_NOT_SUPPORTED) 
   2501                  {
   2502                      pCdc->currentPortIdx = inputPortIndex;
   2503                      pCdc->ports.input[inputPortIndex].hpdState = hpdState;
   2504                      
   2505                      // schedule immediate start of HPD signaling task
   2506                      pCdc->cdcTaskFlags |= CDC_TASK_HPD_SIGNAL;            
   2507                      errStatus = false;
   2508                  }
   2509              }
   2510              
   2511              return errStatus;    
   2512          }
   2513          #endif
   2514          
   2515          
   2516          #if (IS_TX == ENABLE)
   2517          //-------------------------------------------------------------------------------------------------
   2518          //! @brief      Gets current HPD state of a Source device
   2519          //!
   2520          //!             This function shall be used by an HDMI Source device
   2521          //!
   2522          //! @return     HPD state code or CDC_HPD_UNKNOWN_STATE, if output is in
   2523          //!             error state or doesn't exist (root device)
   2524          //-------------------------------------------------------------------------------------------------
   2525          
   2526          CdcHpdState_t SiiCdcHpdStateGet(void)
   2527          {
   2528              CdcHpdState_t hpdState = CDC_HPD_UNKNOWN_STATE;
   2529              
   2530              if ((pCdc->ports.numberOfOutputs == 1) && 
   2531                  ( (pCdc->ports.output.hpdErrorState == CDC_HPD_ERRCODE_NO_ERROR) || 
   2532                    (pCdc->ports.output.hpdErrorState == CDC_HPD_ERRCODE_NO_ERROR_NO_VIDEO)  ))
   2533              {
   2534                  hpdState = pCdc->ports.output.hpdState;
   2535              }
   2536          
   2537              return hpdState;
   2538          }
   2539          #endif
   2540          
   2541          
   2542          #if (IS_RX == ENABLE)
   2543          //-------------------------------------------------------------------------------------------------
   2544          //! @brief      Launches verification task that checks if selected adjacent
   2545          //!             device supports HPD-over-CDC messaging
   2546          //!
   2547          //!             This function shall be used by an HDMI Sink device
   2548          //!
   2549          //! @param[in]  inputPortIndex - zero based input port number
   2550          //!
   2551          //! @retval     true, if the HPD capability verification task can't be scheduled,
   2552          //! @retval     false - otherwise
   2553          //-------------------------------------------------------------------------------------------------
   2554          
   2555          bool_t SiiCdcHpdCapabilityInquire(uint8_t inputPortIndex)
   2556          {
   2557              bool_t  errStatus = true;
   2558              
   2559              if (inputPortIndex < pCdc->ports.numberOfInputs)
   2560              {
   2561                  if (pCdc->ports.input[inputPortIndex].hecSupport != CDC_HEC_NOT_SUPPORTED) 
   2562                  {
   2563                      pCdc->currentPortIdx = inputPortIndex;
   2564                      
   2565                      // schedule immediate start of HPD capability verification task 
   2566                      pCdc->cdcTaskFlags |= CDC_TASK_HPD_CAPAB_VERIF;            
   2567                      errStatus = false;
   2568                  }
   2569              }
   2570              
   2571              return errStatus;    
   2572          }
   2573          
   2574          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  CdcAliveTimerSet
              0 -> CdcTimeCounterSet
             16 -> Mrand
       12  CdcHecAddNewDeviceToHostList
        8  CdcHecDisableCheck
              8 -> CdcEhdmiHwEnable
        8  CdcLostDeviceDisconnect
       48  CdcTaskBase
             48 -> CdcAliveDeviceListAdd
             48 -> CdcAliveDeviceListRemove
             48 -> CdcAliveDeviceListTimeReset
             48 -> CdcAliveTimerSet
             48 -> CdcCapablePortGet
             48 -> CdcDiscoveryDataArrange
             48 -> CdcEhdmiHwEnable
             48 -> CdcHecAddNewDeviceToHostList
             48 -> CdcHecDescriptorAdd
             48 -> CdcHecDescriptorRemove
             48 -> CdcHecDisableCheck
             48 -> CdcHecIndexGet
             48 -> CdcHecNotifyAliveSend
             48 -> CdcHecReportStateSend
             48 -> CdcHpdReportStateSend
             48 -> CdcIoPortsActivate
             48 -> CdcIoPortsStatusUpdate
             48 -> CdcIsCapableToAdjacent
             48 -> CdcIsDeviceBelongsToHec
             48 -> CdcIsHecEnabledInDev
             48 -> CdcIsLinkedDirectly
             48 -> CdcIsTimeCounterExpired
             48 -> CdcLostDeviceDisconnect
             48 -> CdcTimeCounterReset
             48 -> CdcTimeCounterSet
             48 -> SiiCdcDeviceDisconnect
       32  CdcTaskConnect
             32 -> CdcAliveDeviceListAdd
             32 -> CdcAliveTimerSet
             32 -> CdcEhdmiHwEnable
             32 -> CdcHecDescriptorRemove
             32 -> CdcHecInquireStateSend
             32 -> CdcHecLengthGet
             32 -> CdcHecSetStateSend
             32 -> CdcIoPortsStatusUpdate
             32 -> CdcIsDeviceBelongsToHec
             32 -> CdcIsTimeCounterExpired
             32 -> CdcTimeCounterSet
             32 -> CdcTimeCounterUpdate
       16  CdcTaskConnectAdjacent
             16 -> CdcEhdmiHwEnable
             16 -> CdcHecDescriptorRemove
             16 -> CdcHecSetStateAdjacentSend
             16 -> CdcIoPortsStatusUpdate
             16 -> CdcIsTimeCounterExpired
             16 -> CdcTimeCounterSet
             16 -> CdcTimeCounterUpdate
       16  CdcTaskDisconnectAll
             16 -> CdcAliveDeviceListRemove
             16 -> CdcHecDeactivationRequestSend
             16 -> CdcHecDescriptorRemove
             16 -> CdcHecDisableCheck
             16 -> CdcHecSetStateSend
             16 -> CdcIoPortsStatusUpdate
             16 -> CdcIsTimeCounterExpired
             16 -> CdcTimeCounterSet
             16 -> CdcTimeCounterUpdate
       16  CdcTaskDisconnectLost
             16 -> CdcAliveDeviceListRemove
             16 -> CdcHecDescriptorRemove
             16 -> CdcHecDisableCheck
             16 -> CdcHecSetStateSend
             16 -> CdcIoPortsStatusUpdate
             16 -> CdcIsDeviceBelongsToHec
             16 -> CdcIsTimeCounterExpired
             16 -> CdcTimeCounterSet
             16 -> CdcTimeCounterUpdate
       16  CdcTaskDiscover
             16 -> CdcDiscoveryDataArrange
             16 -> CdcHecDiscoverSend
             16 -> CdcIsTimeCounterExpired
             16 -> CdcTimeCounterSet
             16 -> CdcTimeCounterUpdate
       16  CdcTaskHpdCapabilityVerification
             16 -> CdcHecInquireStateOfAdjacentSend
             16 -> CdcIsTimeCounterExpired
             16 -> CdcTimeCounterSet
             16 -> CdcTimeCounterUpdate
       16  CdcTaskHpdSignal
             16 -> CdcHpdSetStateSend
             16 -> CdcIsTimeCounterExpired
             16 -> CdcTimeCounterSet
             16 -> CdcTimeCounterUpdate
        0  CdcTaskStatusGet
       32  SiiCdcConfig
              0 -> CdcDiscoveryDataArrange
             32 -> CdcHecInstanceRecordReset
             32 -> CdcHecReportStateSend
             32 -> __aeabi_memcpy4
       16  SiiCdcDeviceAdjacentConnect
             16 -> CdcHecDescriptorAdd
             16 -> CdcHecIndexGet
             16 -> CdcIsCapableForHec
       24  SiiCdcDeviceAdjacentDisconnect
             24 -> CdcHecDescriptorRemove
             24 -> CdcHecDisableCheck
             24 -> CdcHecIndexGet
             24 -> CdcHecSetStateAdjacentSend
             24 -> CdcIoPortsStatusUpdate
       32  SiiCdcDeviceConnect
             32 -> CdcHecDescriptorAdd
             32 -> CdcHecIndexGet
             32 -> CdcIsCapableForHec
       16  SiiCdcDeviceDisconnect
             16 -> CdcHecIndexGet
        8  SiiCdcDeviceEncStateSet
              0 -> CdcDiscoveryDataArrange
              8 -> CdcHecReportStateSend
       16  SiiCdcDeviceHecSupEnable
              0 -> CdcDiscoveryDataArrange
             16 -> CdcHecReportStateSend
             16 -> SiiCdcDeviceDisconnect
        8  SiiCdcDeviceHostStateSet
              0 -> CdcDiscoveryDataArrange
              8 -> CdcHecReportStateSend
        8  SiiCdcHpdCapabilityInquire
       16  SiiCdcHpdSetState
       24  SiiCdcNearestEncDeviceGet
             24 -> CdcHecLengthGet
       16  SiiCdcNextInvocationTimeGet
             16 -> CdcIsTimeCounterExpired
       24  SiiCdcPortHecSupEnable
             24 -> CdcAdjacentPhysAddrGet
              0 -> CdcDiscoveryDataArrange
             24 -> CdcHecReportStateSend
             24 -> CdcLostDeviceDisconnect
        0  SiiCdcPortIsActive
       16  SiiCdcSrvHostsFind
             16 -> CdcIsTimeCounterExpired
             16 -> CdcTimeCounterLeftSecGet
        0  SiiCdcSrvStart
        0  SiiCdcSrvStop
        8  SiiCdcTaskInit
              8 -> CdcTimeCounterReset
              8 -> Mrand
       24  SiiCdcTaskProcess
             24 -> CdcAliveDeviceListRemove
             24 -> CdcAliveDeviceListTimeUpdate
             24 -> CdcHecDeactivationRequestSend
             24 -> CdcHecDescriptorRemove
             24 -> CdcHecDisableCheck
             24 -> CdcHecSetStateSend
             24 -> CdcIoPortsStatusUpdate
             24 -> CdcLostDeviceDisconnect
             24 -> CdcTaskBase
             24 -> CdcTaskConnect
             24 -> CdcTaskConnectAdjacent
             24 -> CdcTaskDisconnectAll
             24 -> CdcTaskDisconnectLost
             24 -> CdcTaskDiscover
             24 -> CdcTaskHpdCapabilityVerification
             24 -> CdcTaskHpdSignal
             24 -> CdcTimeCounterSet
             24 -> CdcTimeCounterUpdate


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable30
      16  ?Subroutine0
       6  ?Subroutine1
      24  ?Subroutine10
      10  ?Subroutine11
      10  ?Subroutine12
      10  ?Subroutine13
      20  ?Subroutine14
      14  ?Subroutine15
      12  ?Subroutine16
      12  ?Subroutine17
      14  ?Subroutine18
      10  ?Subroutine19
      12  ?Subroutine2
       8  ?Subroutine20
      12  ?Subroutine21
      12  ?Subroutine22
      10  ?Subroutine23
      20  ?Subroutine24
      20  ?Subroutine25
      14  ?Subroutine26
      12  ?Subroutine27
      14  ?Subroutine28
       8  ?Subroutine29
      10  ?Subroutine3
      12  ?Subroutine30
      18  ?Subroutine31
      14  ?Subroutine32
       6  ?Subroutine4
      10  ?Subroutine5
      10  ?Subroutine6
      16  ?Subroutine7
      20  ?Subroutine8
      20  ?Subroutine9
      60  CdcAliveTimerSet
     172  CdcHecAddNewDeviceToHostList
      48  CdcHecDisableCheck
      34  CdcLostDeviceDisconnect
    1672  CdcTaskBase
     938  CdcTaskConnect
     234  CdcTaskConnectAdjacent
     234  CdcTaskDisconnectAll
     282  CdcTaskDisconnectLost
     156  CdcTaskDiscover
     120  CdcTaskHpdCapabilityVerification
     116  CdcTaskHpdSignal
      16  CdcTaskStatusGet
     106  SiiCdcConfig
     118  SiiCdcDeviceAdjacentConnect
     126  SiiCdcDeviceAdjacentDisconnect
     254  SiiCdcDeviceConnect
      84  SiiCdcDeviceDisconnect
      28  SiiCdcDeviceEncStateSet
      90  SiiCdcDeviceHecSupEnable
      28  SiiCdcDeviceHostStateSet
      50  SiiCdcHpdCapabilityInquire
      62  SiiCdcHpdSetState
      80  SiiCdcNearestEncDeviceGet
      66  SiiCdcNextInvocationTimeGet
     142  SiiCdcPortHecSupEnable
      48  SiiCdcPortIsActive
      60  SiiCdcSrvHostsFind
      36  SiiCdcSrvStart
      22  SiiCdcSrvStop
      78  SiiCdcTaskInit
     344  SiiCdcTaskProcess

 
 6 348 bytes in section .text
 
 6 348 bytes of CODE memory

Errors: none
Warnings: 5
